# -*- coding: utf-8 -*-
# import OpenOPC
# pyinstaller --onefile --windowed  main9metran.py --copy-metadata nidaqmx

# –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
import ast
import asyncio
import faulthandler
import fileinput
import io
import itertools
import math
import os
import queue
import random
import re
import socket
import struct
import subprocess
import sys
import threading
import time
import warnings
from datetime import datetime
from functools import partial
from time import sleep
from collections import defaultdict

# –¢—Ä–µ—Ç—å–µ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
import keyboard
import numpy as np
import pandas as pd
from asteval import Interpreter
from nidaqmx.constants import AcquisitionType
import nidaqmx
import nidaqmx.system
from ping3 import ping
from pyModbusTCP.client import ModbusClient
from pymodbus.client.mixin import ModbusClientMixin

# PyQt5
from PyQt5.QtCore import (
    Qt, QDateTime, QTimer, QPoint, QProcess, QRegExp, QFile, QSettings,
    pyqtSignal, QTime, QEvent, QSize, QRect, QCoreApplication, pyqtSlot
)
from PyQt5.QtGui import (
    QFont, QRegExpValidator, QPixmap, QKeySequence, QPainter, QColor, QBrush
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QLabel, QPushButton, QCheckBox, QComboBox, QDoubleSpinBox, QSpinBox, QTimeEdit, QLineEdit,
    QFileDialog, QScrollArea, QTextEdit, QInputDialog, QColorDialog,
    QSizePolicy, QDesktopWidget, QSlider, QAction, QShortcut,
    QAbstractSpinBox, QGraphicsOpacityEffect, QMessageBox, QLayout
)
import pyqtgraph as pg
from pymodbus.constants import Endian
from pymodbus.payload import BinaryPayloadDecoder
from pyqtgraph import TextItem

## –í–∫–ª—é—á–µ–Ω–∏–µ faulthandler
# faulthandler.enable()

# (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å stderr
if sys.stderr is None:
    sys.stderr = io.StringIO()


def measure_time(func):
    """
    –î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏.
    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
    - func (function): –§—É–Ω–∫—Ü–∏—è, –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ—Ç–æ—Ä–æ–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∏–∑–º–µ—Ä–∏—Ç—å.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
    - function: –û–±–µ—Ä–Ω—É—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–≤–æ–¥–∏—Ç –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.
    """

    def wrapper(*args, **kwargs):
        """
        –û–±–µ—Ä—Ç–∫–∞ –≤–æ–∫—Ä—É–≥ –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.
        –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        - *args: –ü–æ–∑–∏—Ü–∏–æ–Ω–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.
        - **kwargs: –ò–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        - –†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.
        """
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ {func.__name__}:", execution_time)
        return result

    return wrapper


warnings.simplefilter(action='ignore', category=FutureWarning)


class ServerSocket(threading.Thread):
    """
    –ö–ª–∞—Å—Å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–∫–µ—Ç–æ–≤ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ.
    –°–µ—Ä–≤–µ—Ä —Å–ª—É—à–∞–µ—Ç –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–ª–∏–µ–Ω—Ç–∞–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –∞—Ç—Ä–∏–±—É—Ç–∞ data.
    """
    data = []

    def __init__(self, host='', port=8888):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–µ—Ä–∞.

        :param host: IP-–∞–¥—Ä–µ—Å –¥–ª—è –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–ª—É—à–∞–µ—Ç –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã.
        :param port: –ü–æ—Ä—Ç –¥–ª—è –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 8888.
        """
        super().__init__()
        self.host = host
        self.port = port

    async def handle_client(self, reader, writer):
        """
        –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞.

        :param reader: –æ–±—ä–µ–∫—Ç –¥–ª—è —á—Ç–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞.
        :param writer: –æ–±—ä–µ–∫—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç—É.
        """
        writer.get_extra_info('peername')
        message = ';'.join([str(item) for item in ServerSocket.data])
        writer.write(message.encode('utf-8'))
        await writer.drain()
        writer.close()
        await writer.wait_closed()

    async def run_server(self):
        """
        –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞.
        """
        server = await asyncio.start_server(self.handle_client, self.host, self.port)
        async with server:
            await server.serve_forever()

    def run(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self.run_server())


class WarningWindow(QMessageBox):
    """
    –ö–ª–∞—Å—Å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–∫–Ω–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã.
    """

    def __init__(self, sometext='', out=True):
        """
                –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–∫–Ω–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è.

                –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
                - sometext (str): –¢–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –≤ –æ–∫–Ω–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è.
                - out (bool): –ï—Å–ª–∏ True, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –±—É–¥–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É "Ok". –ï—Å–ª–∏ False, –æ–∫–Ω–æ –ø—Ä–æ—Å—Ç–æ –∑–∞–∫—Ä–æ–µ—Ç—Å—è.
        """
        super().__init__()

        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        self.setWindowTitle("Error")
        self.setText(str(sometext))
        self.setIcon(QMessageBox.Warning)
        self.setFont(QFont("Arial", 23))
        self.setStandardButtons(QMessageBox.Ok)

        if out:
            self.button(QMessageBox.Ok).clicked.connect(QApplication.quit)
        else:
            self.button(QMessageBox.Ok).clicked.connect(self.close)

        self.show()


def warning_window(sometext, out=True):
    """
       –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ–∫–Ω–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è.

       –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
       - sometext (str): –¢–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –≤ –æ–∫–Ω–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è.
       - out (bool, –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ): –ï—Å–ª–∏ True, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –±—É–¥–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É "Ok".
                                 –ï—Å–ª–∏ False, –æ–∫–Ω–æ –ø—Ä–æ—Å—Ç–æ –∑–∞–∫—Ä–æ–µ—Ç—Å—è. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é True.

       –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:
       warning_window("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞!", out=False)
       """
    WarningWindow(sometext=sometext, out=out).exec_()


WORK_DIR = ''  # –†–∞–±–æ—á–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è, –≥–¥–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –∏–ª–∏ –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è —Ñ–∞–π–ª—ã –∏ –¥–∞–Ω–Ω—ã–µ
global Imitation
Imitation = False


class IpConfigDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("–î–æ–±–∞–≤–∏—Ç—å IP")
        self.setLayout(QVBoxLayout())

        self.combo = QComboBox()
        self.combo.addItems(['modbus', 'opc', 'daq', 'elemer'])

        self.line_edit = QLineEdit("192.168.")
        self.line_edit.setPlaceholderText("–í–≤–µ–¥–∏—Ç–µ IP-–∞–¥—Ä–µ—Å")

        self.button_box = QPushButton("OK")
        self.button_box.clicked.connect(self.accept)

        self.layout().addWidget(QLabel("–¢–∏–ø —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:"))
        self.layout().addWidget(self.combo)
        self.layout().addWidget(QLabel("IP-–∞–¥—Ä–µ—Å:"))
        self.layout().addWidget(self.line_edit)
        self.layout().addWidget(self.button_box)

    def get_result(self):
        return self.line_edit.text(), self.combo.currentText()


class Window(QWidget):
    """–û–∫–Ω–æ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å—Ö–µ–º—ã –∏–∑ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—Ö–µ–º."""
    my_signal = pyqtSignal(str)  # –°–∏–≥–Ω–∞–ª –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ö–µ–º—ã
    qsettings = QSettings('Teplo', "m11m")  # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    program_directory = os.path.dirname(os.path.abspath(sys.argv[0]))  # –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã

    def __init__(self):
        super().__init__()

        self.setWindowFlags(Qt.FramelessWindowHint)
        self.horizont = QHBoxLayout(self)
        self.setGeometry(500, 500, 550, 100)

        self.combo_box = QComboBox()
        self.combo_box.setGeometry(50, 50, 250, 30)
        self._populate_combobox_with_schemes(self.program_directory)

        last_index = Window.qsettings.value('last_index', 0)
        self.combo_box.setCurrentIndex(last_index)

        self.btn1 = QPushButton('–æ–∫')
        self.btn2 = QPushButton('+')
        self.btn3 = QPushButton('–≤—ã—Ö')
        self._setup_buttons()

        self.checkbox_config = QCheckBox()
        self.checkbox_config.stateChanged.connect(self.imitation)
        self.horizont.addWidget(self.checkbox_config)

        self.countdown_label = QLabel("–ê–≤—Ç–æ–≤—ã–±–æ—Ä —á–µ—Ä–µ–∑: 10 —Å–µ–∫")
        self.horizont.addWidget(self.countdown_label)

        self._setup_timer()

        self.setFont(QFont('Arial', 14))
        self.flag = False

    def _populate_combobox_with_schemes(self, program_directory):
        for folder_name in os.listdir(program_directory):
            folder_path = os.path.join(program_directory, folder_name)
            if os.path.isdir(folder_path) and folder_name != "__pycache__":
                self.combo_box.addItem(folder_name)

    def _setup_buttons(self):
        self.horizont.addWidget(self.combo_box, 4)
        self.horizont.addWidget(self.btn1)
        self.horizont.addWidget(self.btn2)
        self.horizont.addWidget(self.btn3)
        self.btn1.clicked.connect(self.return_selected_scheme)
        self.btn2.clicked.connect(self.add_new_scheme)
        self.btn3.clicked.connect(lambda: os._exit(0))

    def _setup_timer(self):
        self.timer = QTimer(self)
        self.timer.setSingleShot(True)
        self.timer.setInterval(10000)

        self.remaining_time = 10
        self.update_timer = QTimer(self)
        self.update_timer.setInterval(1000)
        self.update_timer.timeout.connect(self._update_countdown)

        self.timer.timeout.connect(self.return_selected_scheme)
        self.timer.start()
        self.update_timer.start()

        self.combo_box.currentTextChanged.connect(self._cancel_timer)

    def _update_countdown(self):
        self.remaining_time -= 1
        if self.remaining_time <= 0:
            self.countdown_label.setText("–ê–≤—Ç–æ–≤—ã–±–æ—Ä...")
            self.update_timer.stop()
        else:
            self.countdown_label.setText(f"–ê–≤—Ç–æ–≤—ã–±–æ—Ä —á–µ—Ä–µ–∑: {self.remaining_time} —Å–µ–∫")

    def _cancel_timer(self):
        self.timer.stop()
        self.update_timer.stop()
        self.countdown_label.hide()

    def imitation(self):
        global Imitation
        Imitation = True

    def return_selected_scheme(self):
        Window.qsettings.setValue('last_index', self.combo_box.currentIndex())
        self.close()
        self.my_signal.emit(self.combo_box.currentText())

    def add_new_scheme(self):
        self.timer.stop()
        self.update_timer.stop()

        folder_name = self._get_folder_name()
        if not folder_name:
            return

        new_folder_path = self._create_new_folder(folder_name, self.program_directory)
        if not new_folder_path:
            return

        self._set_image_for_scheme(new_folder_path)
        self._set_settings_for_scheme(new_folder_path)

        self.my_signal.emit(os.path.join(self.program_directory, folder_name))
        self.reformat_combobox(os.path.join(new_folder_path, "setting1.txt"), folder_name)

    def _get_folder_name(self):
        folder_name, ok_pressed = QInputDialog.getText(self, '–ù–∞–∑–≤–∞–Ω–∏–µ', '–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ')
        if ok_pressed and folder_name and self.combo_box.findText(folder_name) == -1:
            self.combo_box.addItem(folder_name)
            self.combo_box.setCurrentIndex(self.combo_box.count() - 1)
            return folder_name
        return None

    def _create_new_folder(self, folder_name, settings_directory):
        new_folder_path = os.path.join(settings_directory, folder_name)
        if not os.path.exists(new_folder_path):
            os.makedirs(new_folder_path)
            return new_folder_path
        return None

    def _set_image_for_scheme(self, new_folder_path):
        selected_image = QFileDialog.getOpenFileName(self, "–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", new_folder_path,
                                                     "Images (*.png *.xpm *.jpg *.bmp)")[0]
        target_file_path = os.path.join(new_folder_path, "BG.png")
        if selected_image:
            QFile.copy(selected_image, target_file_path)
        else:
            open(target_file_path, 'a').close()

    def _set_settings_for_scheme(self, new_folder_path):
        selected_txt = QFileDialog.getOpenFileName(self, "–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏", new_folder_path,
                                                   "–¢–µ–∫—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã (*.txt)")[0]
        if selected_txt:
            target_file_path = os.path.join(new_folder_path, os.path.basename(selected_txt))
            QFile.copy(selected_txt, target_file_path)
        else:
            default_file_path = "setting1_default.txt"
            new_file_name = "setting1.txt"
            target_file_path = os.path.join(new_folder_path, new_file_name)
            QFile.copy(default_file_path, target_file_path)
            QFile(target_file_path).rename(os.path.join(new_folder_path, new_file_name))

    def reformat_combobox(self, target_file_path, folder_name):
        def update_config_ips(lines):
            updated_lines = []
            for line in lines:
                if "IZDELIE" in line:
                    line = f'{"IZDELIE"}= "{folder_name}"\n'
                if 'IPS' in line and "##" not in line:
                    num_ips = QInputDialog.getInt(self, 'Input Dialog', '–ß–∏—Å–ª–æ ip:', 1)[0]
                    ips = 'IPS = {'
                    for _ in range(num_ips):
                        ips += get_ip_config()
                    ips += '}\n'
                    line = ips
                updated_lines.append(line)
            return updated_lines

        def get_ip_config():
            dialog = IpConfigDialog()
            if dialog.exec_() == QDialog.Accepted:
                ip, proto = dialog.get_result()
                return f'"{ip}":"{proto}",'
            return ''

        with open(target_file_path, 'r') as f:
            lines = f.readlines()

        updated_lines = update_config_ips(lines)

        with open(target_file_path, 'w') as f:
            f.writelines(updated_lines)

        items = [self.combo_box.itemText(i) for i in range(self.combo_box.count())]
        sorted_items = sorted(items)
        self.combo_box.clear()
        self.combo_box.addItems(sorted_items)
        self.combo_box.setCurrentText(folder_name)


if __name__ == '__main__':
    app = QApplication(sys.argv)

    window = Window()
    selected_scheme = {'dir': None}  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª–æ–≤–∞—Ä—å, —á—Ç–æ–±—ã –æ–±–æ–π—Ç–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏


    def store_selected_dir(chosen_dir):
        selected_scheme['dir'] = os.path.join(Window.program_directory, chosen_dir)


    window.my_signal.connect(store_selected_dir)
    window.show()

    app.exec_()  # –ë–ª–æ–∫–∏—Ä—É—é—â–∏–π –≤—ã–∑–æ–≤ ‚Äî –∂–¥—ë—Ç, –ø–æ–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±–µ—Ä–µ—Ç —Å—Ö–µ–º—É

    # –ü—Ä–æ–≤–µ—Ä–∫–∞: –≤—ã–±—Ä–∞–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—Ö–µ–º—É
    WORK_DIR = selected_scheme['dir']
    if not WORK_DIR or not os.path.exists(WORK_DIR):
        warning_window("–°—Ö–µ–º–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞ –∏–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", out=True)

    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    config_defaults = {
        'textbox_w': 800,
        'textbox_h': 180,
        'imitation': False,
        'adjust_index': (lambda x: x - 1),
        'IZDELIE': '',
        'IMG': os.path.join(WORK_DIR, 'BG.png'),
        'setting': os.path.join(WORK_DIR, 'setting1.txt'),
        'IPS': {},
        'sensor_size': 14,
        'hidename': 0,
        'format_time': "%H_%M_%S__%d-%m-%y",
        'pack': 4,
        'GRID': '#' * 79,
        'COLORS': {
            "–ö—Ä–∞—Å–Ω—ã–π": "FF5733", "–ó–µ–ª—ë–Ω—ã–π": "00ff00", "–°–∏–Ω–∏–π": "50b4bd",
            '–ß–µ—Ä–Ω—ã–π': '000000', '–ì–æ–ª—É–±–æ–π': '01fdfc', '–¢—ë–º–Ω–æ—Å–µ—Ä—ã–π': '49423d',
            '–°–µ—Ä—ã–π': '808080', '–°–≤–µ—Ç–ª–æ—Å–µ—Ä—ã–π': 'bbbbbb', '–ü—É—Ä–ø—É—Ä–Ω—ã–π': 'e600e6',
            '–ñ—ë–ª—Ç—ã–π': 'fde910', '–ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π': 'transparent'
        },
        'daq_prefix': ['net', '.device01'],
        'graph_step': 1000,
        'graph_point': 300,
        'SIDE': {'–õ–µ–≤–æ': 'left', '–ü—Ä–∞–≤–æ': 'right', '–í–µ—Ä—Ö': 'top', '–ù–∏–∑': 'bottom'},
        'dampers_signals': {},
        'damper_data_queue': {},
        'ORIENTATION': {"–ì–æ—Ä–∏–∑–∞–Ω—Ç–∞–ª—å–Ω–æ": 'H', '–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ': 'V'}
    }


    def update_config_from_file(filename, config):
        try:
            with open(filename, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#') or '=' not in line:
                        continue
                    key, value = line.split('=', 1)
                    try:
                        config[key.strip()] = ast.literal_eval(value.strip())
                    except Exception as e:
                        print(
                            f"[config warning] –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —Ä–∞–∑–æ–±—Ä–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ '{value.strip()}' –¥–ª—è –∫–ª—é—á–∞ '{key.strip()}': {e}")
        except FileNotFoundError:
            warning_window(f"–§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω: {filename}", True)
            sys.exit(1)
        return config


    try:
        config = update_config_from_file(config_defaults['setting'], config_defaults)
    except FileNotFoundError:
        warning_window(f"–§–∞–π–ª –Ω–∞—Å—Ç—Ä–æ–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω:\n{config_defaults['setting']}", out=True)
        sys.exit(1)

    config['imitation'] = Imitation


def check_and_warn_about_connection(config):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –∫–∞–∂–¥—ã–º IP-–∞–¥—Ä–µ—Å–æ–º –∏ –≤—ã–≤–æ–¥–∏—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è."""

    def ping_and_warn(ip, retries=3, delay=5):
        if len(ip) < 5:
            return True
        for attempt in range(retries):
            try:
                if ping(ip, timeout=1):
                    return True
            except Exception as e:
                print(f"[ping error] {ip}: {e}")
            warning_window(f'Try to reconnect {ip} (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{retries})', False)
            for _ in range(delay * 10):  # —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å GUI
                QCoreApplication.processEvents()
                sleep(0.1)
        return False

    if not config.get('imitation', False):
        for ip in config['IPS'].keys():
            if not ping_and_warn(ip):
                warning_window(f"{ip} \n lost connection")
                break


check_and_warn_about_connection(config)


def initialize_data_streams(channels, dampers_list):
    """–°–æ–∑–¥–∞–µ—Ç –ø–æ—Ç–æ–∫–∏ –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤ –≤ —Å–µ—Ç–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö."""
    queue_names = []
    config['threads'] = []

    function_dict = {
        'modbus': partial(fetch_data_from_modbus, device_type='modbus'),
        'elemer': partial(fetch_data_from_modbus, device_type='elemer'),
        'daq': partial(fetch_daq_data),
        'opc': partial(fetch_opc_data),
        'port': partial(fetch_port)
    }

    for index, (ip_address, protocol_type) in enumerate(config['IPS'].items()):
        queue_name = f'data_{protocol_type}_{index}'
        config[queue_name] = queue.LifoQueue()
        queue_names.append(config[queue_name])

        # –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        client = None
        if protocol_type in ['modbus', 'elemer']:
            client = ModbusClient(host=ip_address, port=502, unit_id=1, auto_open=True)
            relevant_sensors = [s for s in channels if s.reg == index]
            config.setdefault('queue_expected_lengths', {})[queue_name] = len(relevant_sensors)
        # –ü–æ–¥–±–æ—Ä –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
        if function_dict.get(protocol_type):
            if client:
                args = (index, client, channels, dampers_list, config[queue_name])
            elif protocol_type == 'daq':
                args = (config[queue_name], index, dampers_list)
            elif protocol_type in ['opc', 'port']:
                args = (index, ip_address, channels, config[queue_name])
            else:
                args = ()

            data_thread = threading.Thread(
                target=function_dict[protocol_type],
                args=args,
                name=f"{protocol_type}_thread_{index}",
                daemon=True
            )
            data_thread.start()
            config['threads'].append(data_thread)
            print(f"[INFO] –ü–æ—Ç–æ–∫ {data_thread.name} –∑–∞–ø—É—â–µ–Ω –¥–ª—è {ip_address} ({protocol_type})")
        else:
            warning_window(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–æ—Ç–æ–∫–æ–ª: {protocol_type}", out=False)

    return queue_names


def fetch_port(protocol_index, server_ip, channels, data_queue):
    sensors = [sensor for sensor in channels if sensor.reg == protocol_index]
    sensor_data_indices = [sensor.ch for sensor in sensors]

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(('', int(server_ip) + 1))
        dataname, _ = sock.recvfrom(1024)
        dataname = dataname.decode('windows-1251').split(';')
        config['ports'] = {f'{server_ip}_port_names': [f'{i + 1} {name}' for i, name in enumerate(dataname)]}
        sock.close()
    except Exception as e:
        print(f"[PORT] –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('', int(server_ip)))
    backup_data = [float('nan')] * len(sensor_data_indices)

    try:
        while True:
            try:
                data, _ = sock.recvfrom(1024)
                parts = data.decode('utf-8').split(';')
                values = [float(parts[i].replace(',', '.')) for i in sensor_data_indices]
                backup_data = values.copy()
            except Exception as e:
                print(f"[PORT] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: {e}")
                values = backup_data.copy()
                time.sleep(0.5)

            data_queue.put(values)
            time.sleep(0.1)
    finally:
        sock.close()


def format_modopc(ip_address):
    """–§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–µ–Ω–∏ –º–æ–¥—É–ª—è –¥–ª—è OPC —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ IP-–∞–¥—Ä–µ—Å–∞."""
    ip_part = config['daq_prefix'][0] + ''.join([part.zfill(3) for part in ip_address.split('.', 2)[2].split('.')]) + \
              config['daq_prefix'][1]
    return ip_part


def fetch_opc_data(protocol_index, server_ip, channels, data_queue):
    sensors = [sensor for sensor in channels if sensor.reg == protocol_index]
    opc_url = f"opc.tcp://{server_ip}:4840"
    client = UaClient(opc_url)
    backup_data = [float('nan')] * len(sensors)

    try:
        client.connect()
        print(f"[OPC UA] Connected to {opc_url}")

        node_ids = [f"ns=2;s={sensor.name}" for sensor in sensors]

        while True:
            try:
                values = [float(client.get_node(nid).get_value()) for nid in node_ids]
                backup_data = values.copy()
            except Exception as e:
                print(f"[OPC UA] Read error: {e}")
                values = backup_data.copy()
                time.sleep(0.5)

            data_queue.put(values)
            time.sleep(0.1)
    except Exception as e:
        print(f"[OPC UA] Connection error: {e}")
    finally:
        try:
            client.disconnect()
        except:
            pass


def read_sensors_ops(sensors, opc_device, opc_client):
    """
    –ß–∏—Ç–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –¥–∞—Ç—á–∏–∫–æ–≤ —Å OPC —Å–µ—Ä–≤–µ—Ä–∞.

    :param sensors: –°–ø–∏—Å–æ–∫ –¥–∞—Ç—á–∏–∫–æ–≤, –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø—Ä–æ—á–∏—Ç–∞—Ç—å.
    :param opc_device: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–∞ OPC —Å–µ—Ä–≤–µ—Ä–µ.
    :param opc_client: –ö–ª–∏–µ–Ω—Ç –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ OPC —Å–µ—Ä–≤–µ—Ä—É.
    :return: –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–π –∑–Ω–∞—á–µ–Ω–∏—è –¥–∞—Ç—á–∏–∫–æ–≤.
    """
    # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ OPC —Å–µ—Ä–≤–µ—Ä—É
    opc_client.connect('Metran-910.OPC')

    # –ß—Ç–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–∞—Ç—á–∏–∫–∞
    for sensor in sensors:
        sensor_value = opc_client.properties(f"{opc_device}.AI{sensor.ch + 1:02d}Value", 2)
        yield round(sensor_value, 4)

    # –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å OPC —Å–µ—Ä–≤–µ—Ä–æ–º
    opc_client.close()


def fetch_data_from_modbus(protocol_index, modbus_client, channels, dampers_list, data_queue, device_type='modbus'):
    try:
        relevant_sensors = [sensor for sensor in channels if sensor.reg == protocol_index]
        relevant_dampers = {
            (damper.name, damper.reg): [damper.chdv_open, damper.chdv_close]
            for damper in dampers_list if damper.reg == protocol_index
        }

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞—Å–ª–æ–Ω–æ–∫
        try:
            max_value = max(max(vals) for vals in relevant_dampers.values())
            config['dampers_signals'][protocol_index] = {key: 0 for key in range(0, max_value + 1)}
            dampers_signals = config['dampers_signals'][protocol_index].copy()

            try:
                input_signals = modbus_client.read_discrete_inputs(0, 9)
                config['damper_data_queue'][protocol_index] = input_signals or [0] * 10
            except Exception as e:
                print(f"[modbus-{device_type}] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –≤—Ö–æ–¥–æ–≤: {e}")
                config['damper_data_queue'][protocol_index] = [0] * 10
        except Exception:
            dampers_signals = config['dampers_signals'][protocol_index] = 0

        backup_data = [float('nan')] * len(relevant_sensors)  # —Ä–µ–∑–µ—Ä–≤ –Ω–∞ —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏

        while True:
            try:
                # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —á—Ç–µ–Ω–∏—è —Å–µ–Ω—Å–æ—Ä–æ–≤
                modbus_data = list(fetch_sensor_data(relevant_sensors, modbus_client, device_type))

                # üö® –ß—Ç–µ–Ω–∏–µ –≤—Ö–æ–¥–æ–≤ –ö–ê–ñ–î–´–ô –¶–ò–ö–õ
                try:
                    input_signals = modbus_client.read_discrete_inputs(0, 9)
                    if input_signals != config['damper_data_queue'][protocol_index]:
                        print(
                            f"[modbus-{device_type}] –í—Ö–æ–¥—ã –∏–∑–º–µ–Ω–∏–ª–∏—Å—å: {config['damper_data_queue'][protocol_index]} ‚Üí {input_signals}")
                        config['damper_data_queue'][protocol_index] = input_signals
                except Exception as e:
                    print(f"[modbus-{device_type}] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –≤—Ö–æ–¥–æ–≤ –≤ —Ü–∏–∫–ª–µ: {e}")

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞—Å–ª–æ–Ω–æ–∫
                if config['dampers_signals'][protocol_index] != dampers_signals:
                    try:
                        modbus_client.write_multiple_coils(
                            0, list(config['dampers_signals'][protocol_index].values())
                        )
                        dampers_signals = config['dampers_signals'][protocol_index].copy()
                    except Exception as e:
                        print(f"[modbus-{device_type}] –û—à–∏–±–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞—Å–ª–æ–Ω–∫–∞–º–∏: {e}")

                backup_data = modbus_data.copy()

            except Exception as e:
                print(f"[modbus-{device_type}] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: {e}")
                modbus_data = backup_data.copy() if backup_data else [float('nan')] * len(relevant_sensors)

            data_queue.put(modbus_data)
            time.sleep(0.1)

    except Exception as e:
        warning_window(f'{e}  {device_type.capitalize()} connection failed')


def fetch_sensor_data(sensor_list, modbus_client, device_type='modbus'):
    for sensor in sensor_list:
        try:
            if device_type == 'modbus':
                register_address = sensor.ch * 2
                word_count = 2
            else:  # 'elemer'
                register_address = 0x4000 + sensor.ch * 4
                word_count = 4
                response = modbus_client.read_input_registers(register_address, 2 if device_type == 'modbus' else 4)
                print(response)
                decoded_value = BinaryPayloadDecoder.fromRegisters(response, Endian.BIG,
                                                                   wordorder=Endian.LITTLE).decode_32bit_float()
                yield round(decoded_value, 4)

            response = modbus_client.read_input_registers(register_address, word_count)
            if response is None:
                raise ValueError("–ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞")

            decoded_value = ModbusClientMixin.convert_from_registers(
                response,
                ModbusClientMixin.DATATYPE.FLOAT32,
                word_order="little"
            )
            yield round(decoded_value, 4)
        except Exception as e:
            print(f"[modbus-{device_type}] –æ—à–∏–±–∫–∞ –Ω–∞ –¥–∞—Ç—á–∏–∫–µ {sensor.name} (ch={sensor.ch}): {e}")
            yield float('nan')


def generate_daq_configuration(ips_config):
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é DAQ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥—É–ª–µ–π –∏ –∏—Ö —Ç–∏–ø–æ–≤.

    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
    - ips_config: —Å–ª–æ–≤–∞—Ä—å —Å IP-–∞–¥—Ä–µ—Å–∞–º–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤.

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
    - daq_config: —Å–ª–æ–≤–∞—Ä—å —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥—É–ª—è—Ö –∏ –∏—Ö —Ç–∏–ø–∞—Ö.
    """

    # –°–ª–æ–≤–∞—Ä—å –º–æ–¥–µ–ª–µ–π –º–æ–¥—É–ª–µ–π –∏ –∏—Ö —Ç–∏–ø–æ–≤
    MODULE_MAPPINGS = {
        '9208': 'ai', '9403': 'do', '9425': 'di',
        '9265': 'ao', '9213': 'tc', '9214': 'tc',
        '9217': 'rtd', '9222': 'vi'
    }

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
    system = nidaqmx.system.System.local()
    devices_list = system.devices
    daq_config = {}

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–∂–¥–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –≤ —Å–ø–∏—Å–∫–µ (–ø—Ä–æ–≤–µ—Ä—è–µ—Ç ip)
    for device_identifier in devices_list.device_names:
        try:
            device_ip = devices_list[device_identifier].tcpip_ethernet_ip
        except Exception:
            continue

        # –ï—Å–ª–∏ IP —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        if device_ip in ips_config:
            current_device = devices_list[device_identifier]
            current_device.reserve_network_device(True)

            # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –º–æ–¥—É–ª–µ–π –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            modules_info = {module.name: module.product_type for module in current_device.chassis_module_devices}

            for module_name, module_type in modules_info.items():
                module_key = next((key for key, value in MODULE_MAPPINGS.items() if key in module_type), None)
                if module_key:
                    daq_config[f"{module_name}/{module_key}/{MODULE_MAPPINGS[module_key]}"] = config.get(
                        module_name.replace('-', '_'), '')
    return daq_config


# –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏—è config['imitation] –∏ –Ω–∞–ª–∏—á–∏–µ 'daq' –≤ –∑–Ω–∞—á–µ–Ω–∏—è—Ö —Å–ª–æ–≤–∞—Ä—è config['IPS']
if not config['imitation'] and any(value == 'daq' for value in config['IPS'].values()):
    config['daq_configuration'] = generate_daq_configuration(config['IPS'])


def task_dido(dampers_list, index):
    """
    –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞—á–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å DAQ (Data Acquisition) —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º.
    :param dampers_list: –°–ø–∏—Å–æ–∫ –¥–µ–º–ø—Ñ–µ—Ä–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.
    :param index: –ò–Ω–¥–µ–∫—Å, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –¥–µ–º–ø—Ñ–µ—Ä–æ–≤ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–¥–∞—á DAQ.
    :return: –ö–æ—Ä—Ç–µ–∂, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π:
             - dampers_signals: –°–∏–≥–Ω–∞–ª—ã –¥–µ–º–ø—Ñ–µ—Ä–æ–≤.
             - do_task: –ó–∞–¥–∞—á–∞ –¥–ª—è —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞.
             - di_task: –ó–∞–¥–∞—á–∞ –¥–ª—è —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞.
             - di_max: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã–±–æ—Ä–æ–∫ –¥–ª—è —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞.
             """
    try:
        # –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä—å relevant_dampers –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ –¥–µ–º–ø—Ñ–µ—Ä–∞–º —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º –∏–Ω–¥–µ–∫—Å–æ–º
        relevant_dampers = {}

        # –§–∏–ª—å—Ç—Ä—É–µ–º dampers_list –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –¥–µ–º–ø—Ñ–µ—Ä–æ–≤ —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∏–Ω–¥–µ–∫—Å–æ–º
        for damper in [damper for damper in dampers_list if damper.reg == index]:
            relevant_dampers[damper.name, damper.reg] = [[damper.chr_open, damper.chr_close],
                                                         [damper.chdv_open, damper.chdv_close]]

        # –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è di –∏ do
        di_max = do_max = 32
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ DAQ-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ —Ñ–∞–π–ª–∞ config
        daq_di = next(key.split('/')[0] for key in config['daq_configuration'].keys() if 'di' in key)
        di_task = nidaqmx.Task()
        for i in range(di_max):
            di_task.di_channels.add_di_chan(f"{daq_di}/port0/line{i}")
        config['damper_data_queue'][index] = [item for sublist in di_task.read(number_of_samples_per_channel=1) for item
                                              in sublist]

        daq_do = next(key.split('/')[0] for key in config['daq_configuration'].keys() if 'do' in key)
        do_task = nidaqmx.Task()
        for i in range(do_max):
            do_task.do_channels.add_do_chan(f"{daq_do}/port0/line{i}")
        config['dampers_signals'][index] = {key: False for key in range(0, do_max)}
        dampers_signals = config['dampers_signals'][index].copy()

    except Exception:
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–π, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫
        dampers_signals = config['dampers_signals'][index] = di_max = do_task = di_task = 0

    return dampers_signals, do_task, di_task, di_max


def task_aigen(index):
    """
    –°–æ–∑–¥–∞—Ç—å –∏ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –∑–∞–¥–∞—á—É –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –º–æ–¥—É–ª—è–º–∏ AI (Analog Input) DAQ.

    :param index: –ò–Ω–¥–µ–∫—Å, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Å–µ–Ω—Å–æ—Ä–æ–≤.
    :return: –ö–æ—Ä—Ç–µ–∂, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π:
             - task: –ó–∞–¥–∞—á–∞ –¥–ª—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö —Å –º–æ–¥—É–ª–µ–π AI.
             - endcfg: –ö–æ–Ω–µ—á–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–¥—É–ª–µ–π AI.
    """

    ai_modules = ai_modules = {k: v for k, v in config.items() if ('DAQ' in k or 'SIU' in k) and v}
    # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É DAQ
    task = nidaqmx.Task()
    # –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤ –∫–∞–Ω–∞–ª–æ–≤ DAQ
    daq_channel_ranges = {}
    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–µ–Ω—Å–æ—Ä—ã, –æ—Ç–Ω–æ—Å—è—â–∏–µ—Å—è –∫ –∑–∞–¥–∞–Ω–Ω–æ–º—É –∏–Ω–¥–µ–∫—Å—É
    relevant_sensors = [sensor for sensor in dlgMain.sensor_list if sensor.reg == index]
    # –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä—å endcfg –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ DAQ –ø–æ –º–æ–¥—É–ª—è–º
    endcfg = {}
    # –ò—Ç–µ—Ä–∏—Ä—É–µ–º –ø–æ –º–æ–¥—É–ª—è–º AI
    for i, (module_name, values) in enumerate(ai_modules.items()):
        new_daq_channel_ranges = {}
        new_values = {}

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥—É–ª—è –±–µ–∑ —Å—Ä–µ–¥–Ω–µ–≥–æ —á–∏—Å–ª–∞
        module = re.sub(r"/\d+/", "/", module_name).replace("_", "-")
        endcfg[module] = {}

        # –ò—Ç–µ—Ä–∏—Ä—É–µ–º –ø–æ –∫–ª—é—á–∞–º –∏ –∑–Ω–∞—á–µ–Ω–∏—è–º –∫–∞–∂–¥–æ–≥–æ –º–æ–¥—É–ª—è
        for old_key, old_value in values.items():
            new_values[old_key] = old_value

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Ö –≤ –Ω–æ–≤–æ–º —Å–ª–æ–≤–∞—Ä–µ
        new_daq_channel_ranges[module] = dict(sorted(new_values.items()))

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–æ–≤–∞—Ä—å daq_channel_ranges
        daq_channel_ranges[module] = new_daq_channel_ranges[module]

        # –î–æ–±–∞–≤–ª—è–µ–º AI-–∫–∞–Ω–∞–ª—ã –¥–ª—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö —Å–µ–Ω—Å–æ—Ä–æ–≤
        for sensor in relevant_sensors:
            for key, val in daq_channel_ranges[module].items():
                if sensor.ch == key - 1:
                    chnl = sensor.ch % 16  # –ù–µ–æ–±—Ö–æ–¥–∏–º—ã–π –∫–∞–Ω–∞–ª –ø–æ—Å–ª–µ –≤—ã—á–∏—Ç–∞–Ω–∏—è 1 –∏ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É 0-15
                    task.ai_channels.add_ai_current_chan(f"{module}/ai{chnl}")
                    endcfg[module][chnl] = val
                    break
        print(endcfg)
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–¥–∞—á–∏ –¥–ª—è —á—Ç–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Å DAQ
    # –ò–∑–º–µ–Ω–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–∞–∫—Ç–æ–≤–æ–π —á–∞—Å—Ç–æ—Ç—ã –∏ —Ä–µ–∂–∏–º–∞ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –≤–∞–º
    task.timing.cfg_samp_clk_timing(rate=13, sample_mode=AcquisitionType.CONTINUOUS)
    # –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ, –µ—Å–ª–∏ –≤–∞–º –Ω—É–∂–Ω–æ –≤—ã–≤–µ—Å—Ç–∏ –∏–º–µ–Ω–∞ –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    for ai_channel in task.ai_channels:
        print(ai_channel.name)
    return task, endcfg


def fetch_daq_data(data_queue, index, dampers_list):
    try:
        dampers_signals, do_task, di_task, di_max = task_dido(dampers_list, index)
        task_ai, endcfg = task_aigen(index)
        task_ai.start()

        def generate_processed_data(endcfg, data):
            module_values = np.concatenate([np.array(list(cfg.values())) for cfg in endcfg.values()])
            chunks = [data[i:i + len(module_values)] for i in range(0, len(data), len(module_values))]
            chunk_array = np.array(chunks)
            processed_values = np.round(
                ((chunk_array * 1000 - 4) * (module_values[:, 1] - module_values[:, 0])) / 16 + module_values[:, 0], 4
            )
            return processed_values.reshape(-1)

        backup_data = [float('nan')] * sum(len(cfg) for cfg in endcfg.values())
        should_read_data = True

        while True:
            try:
                dataai = task_ai.read()
                if should_read_data:
                    config['damper_data_queue'][index] = list(
                        itertools.chain.from_iterable(di_task.read(number_of_samples_per_channel=1)))
                    should_read_data = False

                if config['dampers_signals'][index] != dampers_signals:
                    dampers_signals = config['dampers_signals'][index].copy()
                    do_task.write(data=list(config['dampers_signals'][index].values()))
                    should_read_data = True

                processed = list(generate_processed_data(endcfg, dataai))
                backup_data = processed.copy()
            except Exception as e:
                print(f"[DAQ] –û—à–∏–±–∫–∞: {e}")
                processed = backup_data.copy()
                time.sleep(0.5)

            data_queue.put(processed)
            time.sleep(0.1)

    except Exception as e:
        warning_window(f"DAQ init failed: {e}", False)


def process_data_channel(data_channel, dampers_list):
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ –≤—Å–µ—Ö –æ—á–µ—Ä–µ–¥–µ–π. –£—Å—Ç–æ–π—á–∏–≤–æ –∫ –ø–∞–¥–µ–Ω–∏—è–º –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤.
    """
    data_channel_condition = threading.Condition()
    config['processed_data_queue'] = queue.LifoQueue()

    with data_channel_condition:
        while data_channel is None:
            sleep(2)
            data_channel_condition.wait()

        if not config['imitation']:
            data_sources = initialize_data_streams(data_channel, dampers_list)

            while True:
                values = []
                for i, q in enumerate(data_sources):
                    try:
                        val = q.get(timeout=1)
                    except queue.Empty:
                        # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ: –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–ª–∏–Ω—É
                        queue_name = f"data_{list(config['IPS'].values())[i]}_{i}"
                        expected_len = config.get('queue_expected_lengths', {}).get(queue_name, 1)
                        val = [float('nan')] * expected_len
                    values.append(val)

                config['processed_data_queue'].put(values)


def fetch_live_data(max_attempts=5):
    """
    –ü—ã—Ç–∞–µ—Ç—Å—è –∏–∑–≤–ª–µ—á—å –¥–∞–Ω–Ω—ã–µ –∏–∑ –æ—á–µ—Ä–µ–¥–∏. –ï—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞, —Ñ—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç –∂–¥–∞—Ç—å –∏ –ø—ã—Ç–∞—Ç—å—Å—è —Å–Ω–æ–≤–∞.

    :param max_attempts: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ —á—Ç–µ–Ω–∏—è –∏–∑ –æ—á–µ—Ä–µ–¥–∏.
    :return: –ò–∑–≤–ª–µ—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–ª–∏ None, –µ—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞ –ø–æ—Å–ª–µ –≤—Å–µ—Ö –ø–æ–ø—ã—Ç–æ–∫.
    """
    attempts = 0
    while attempts < max_attempts:
        try:
            return config['processed_data_queue'].get()
        except queue.Empty:
            sleep(1)
            print('error processing')
            warning_window('connection problems', False)
            attempts += 1
        except Exception as e:
            print('error processing', e)
    return None


class MovableObject(QWidget):
    def mousePressEvent(self, evt):
        if getattr(self, 'moveon', False) and evt.button() == Qt.LeftButton:
            self._dragging_pos = evt.globalPos()
            self._drag_active = True
            self.raise_()  # ‚¨Ö –ø–æ–¥–Ω—è—Ç—å –ø–æ–≤–µ—Ä—Ö –≤—Å–µ—Ö

    def mouseMoveEvent(self, evt):
        if getattr(self, 'moveon', False) and getattr(self, '_drag_active', False):
            delta = evt.globalPos() - self._dragging_pos
            self.move(self.x() + delta.x(), self.y() + delta.y())
            self._dragging_pos = evt.globalPos()

    def mouseReleaseEvent(self, evt):
        self._dragging_pos = None
        self._drag_active = False

        if getattr(self, 'moveon', False) and 'setting' in config:
            with open(config['setting'], 'r') as f:
                lines = f.readlines()
            with open(config['setting'], 'w') as f:
                for line in lines:
                    if self.name + ' ' in line:
                        line = f'{line[:line.rfind(" (")]} ({self.x()} {self.y()})\n'
                    f.write(line)


class IndicatorLamp(MovableObject):
    def __init__(self, name: str, reg: int, ch: int, parent=None):
        super().__init__(parent)
        self.reg = reg - 1
        self.ch = ch - 1
        self.resize(100, 50)
        self.setToolTip(f"LAMP: reg={reg}, ch={ch}")
        self.name = name
        self.color = QColor("gray")
        self.moveon = False
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_state)
        self.timer.start(300)

    def update_state(self):
        try:
            val = config['damper_data_queue'][self.reg][self.ch]
            self.color = Qt.green if val else Qt.red  # ‚úÖ –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è
        except Exception:
            self.color = QColor("gray")
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # –ù–æ–≤—ã–π —Ä–∞–¥–∏—É—Å –∫—Ä—É–≥–∞
        circle_size = 24
        circle_margin = 4

        # –ö—Ä—É–ø–Ω—ã–π –∫—Ä—É–≥ —Å–ª–µ–≤–∞
        painter.setBrush(QBrush(self.color))
        painter.setPen(Qt.black)
        painter.drawEllipse(circle_margin, circle_margin, circle_size, circle_size)

        # –¢–µ–∫—Å—Ç —Å–ø—Ä–∞–≤–∞ –æ—Ç –∫—Ä—É–≥–∞
        painter.setFont(QFont('Arial', 10))
        text_rect = QRect(circle_size + 2 * circle_margin, circle_margin,
                          self.width() - (circle_size + 3 * circle_margin), circle_size)
        painter.drawText(text_rect, Qt.AlignVCenter | Qt.AlignLeft, self.name)


class Damper(MovableObject):
    sensor_data = []
    all_impuls = {}
    modbus_instances = {}  # Dictionary to store ModbusClient instances by modules
    opc_instances = {}  # Dictionary to store opc instances by modules
    lock = threading.Lock()
    DEFAULT_NAME = '–ó–£'
    DEFAULT_SIDE = 'G'

    def __init__(self, name=DEFAULT_NAME, side=DEFAULT_SIDE, chr_open=1, chr_close=2, chdv_open=1, chdv_close=2,
                 side_auto='left', reg=1,
                 parent=None):
        """Damper Initialization"""
        super().__init__(parent=parent)
        self.valve_widget = None
        self.modbus_lock = threading.Lock()
        self.reg = config['adjust_index'](reg)
        if not 0 <= self.reg < len(config['IPS']):
            raise ValueError("Invalid 'reg' value")
        self.ip = list(config['IPS'].keys())[self.reg]

        handlers = {
            'opc': self.initialize_opc_connection,
            'elemer': lambda: self.initialize_modbus_connection('elemer'),
            'modbus': lambda: self.initialize_modbus_connection('modbus'),
            'daq': self.initialize_daq_channels
        }
        handlers[config['IPS'].get(self.ip)]()

        self.chdv_open = config['adjust_index'](chdv_open)
        self.chdv_close = config['adjust_index'](chdv_close)
        self.chr_open = config['adjust_index'](chr_open)
        self.chr_close = config['adjust_index'](chr_close)

        self.widget_automat = None
        self.name = name
        self.side = side
        self.widget = QWidget(self)
        self.layout = QGridLayout()
        self.setup_ui_elements()
        self.auto_side = side_auto
        self.scaletext(config.get("damper_size", 2))

    def setup_ui_elements(self):
        """Setup UI elements for the damper."""
        self.lab = QPushButton(f'{self.name}')
        self.lab.setToolTip(
            f"–æ—Ç–∫—Ä: ch={self.chr_open}, –∑–∞–∫—Ä: ch={self.chr_close}\n"
            f"–∫–æ–Ω—Ü_–æ—Ç–∫—Ä: ch={self.chdv_open}, –∫–æ–Ω—Ü_–∑–∞–∫—Ä: ch={self.chdv_close}\n"
            f"—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä: {self.reg}"
        )
        self.lab.clicked.connect(self.info)
        self.lab.setStyleSheet(
            'font:bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0;text-align: top;')

        self.moveon = False
        self.widget.setLayout(self.layout)
        self.widget.setStyleSheet(
            ".QWidget {border: 1px solid black;border-radius: 25;background-color: rgb(255, 255, 255);}")

        self.setup_buttons()
        self.layout.setVerticalSpacing(0)
        self.layout.setHorizontalSpacing(0)
        self.widget.setFixedSize(120, 60)

        self.layout.addWidget(self.lab, 0, 0, 1, 2)
        self.layout.addWidget(self.red_button, 1, 0, 4, 1)
        self.layout.addWidget(self.green_button, 1, 1, 4, 1)

        if self.side == 'V':
            self.adjust_for_vertical_side()

        self.chkb = QCheckBox()
        self.chkb.stateChanged.connect(self.automatvisibl)
        self.chkb.setStyleSheet("QCheckBox::indicator { width: 10; height: 10;}")
        self.layout.addWidget(self.chkb, 0, 0, 3, 1)

        self.lab.clicked.connect(self.info)

    def setup_buttons(self):
        """Setup buttons for the damper."""

        def setup_button_func(button, on_press_action, on_release_action):
            button.mousePressEvent = lambda event: (
                self.Press(on_press_action) if event.button() == Qt.RightButton else (
                    self.onButtonPressed(on_press_action) if event.button() == Qt.LeftButton else None
                )
            )
            button.mouseReleaseEvent = lambda event: (
                self.onButtonPressed(on_release_action) if event.button() == Qt.LeftButton else None)

        self.red_button = QPushButton()
        setup_button_func(self.red_button, 'turnOnRed', 'turnOffRed')

        self.green_button = QPushButton()
        setup_button_func(self.green_button, 'turnOnGreen', 'turnOffGreen')

        self.pressed = None

        self.update_button_styles(self.red_button, self.green_button, '13px')
        self.red_button.setFixedSize(50, 35)
        self.green_button.setFixedSize(50, 35)
        self.lab.setFixedSize(100, 25)

    def Press(self, action):
        toggle_actions = {
            'turnOnGreen': 'turnOffGreen',
            'turnOnRed': 'turnOffRed'
        }

        if action in toggle_actions:
            toggled_action = toggle_actions[action] if self.pressed == action else action
            self.pressed = None if self.pressed == action else action
            self.onButtonPressed(toggled_action)

    def adjust_for_vertical_side(self):
        """Adjust UI elements for vertical side."""
        self.update_button_styles(self.red_button, self.green_button, '0px')
        self.layout.setHorizontalSpacing(1)
        self.widget.setFixedSize(65, 110)
        self.red_button.setFixedSize(25, 50)
        self.green_button.setFixedSize(25, 50)
        self.lab.setFixedSize(25, 95)
        self.layout.addWidget(self.lab, 0, 1, 2, 1)
        self.layout.addWidget(self.red_button, 1, 0, 1, 1)
        self.layout.addWidget(self.green_button, 0, 0, 1, 1)

    def initialize_modbus_connection(self, attribute_name):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Modbus –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤ –∞—Ç—Ä–∏–±—É—Ç–µ –æ–±—ä–µ–∫—Ç–∞.

        :param attribute_name: –ò–º—è –∞—Ç—Ä–∏–±—É—Ç–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∫–ª–∏–µ–Ω—Ç Modbus.
        """
        try:
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞ Modbus.
            modbus_client = ModbusClient(host=self.ip, port=502, unit_id=1, timeout=5, auto_open=True, auto_close=True)

            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ Modbus.
            Damper.modbus_instances.update({self.ip: modbus_client})

            # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞—Ç—Ä–∏–±—É—Ç–∞ –æ–±—ä–µ–∫—Ç–∞ —Å –∫–ª–∏–µ–Ω—Ç–æ–º Modbus.
            setattr(self, attribute_name, Damper.modbus_instances[self.ip])
        except Exception as error:
            # –í—ã–≤–æ–¥ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏.
            warning_window(f'–û—à–∏–±–∫–∞ –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–∞–Ω–∞–ª–æ–≤ modbus {error}', False)

    def initialize_opc_connection(self):
        from opcua import Client as UaClient

        try:
            url = f"opc.tcp://{self.ip}:4840"
            client = UaClient(url)
            client.connect()

            Damper.opc_instances[self.ip] = client
            self.opc = client

            # –ú–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å NodeId-—à–∞–±–ª–æ–Ω—ã, –µ—Å–ª–∏ –Ω—É–∂–Ω—ã
            self.opc_node_map = {
                "AI": lambda ch: f"ns=2;s={self.name}.AI{ch + 1:02d}Value",
                "DI": lambda ch: f"ns=2;s={self.name}.DI{ch + 1:02d}Value",
                "DO": lambda ch: f"ns=2;s={self.name}.DO{ch + 1:02d}Value",
                "AO": lambda ch: f"ns=2;s={self.name}.AO{ch + 1:02d}Value",
            }

        except Exception as error:
            warning_window(f"[OPC UA] Init error: {error}", False)

    def initialize_daq_channels(self):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–∞–Ω–∞–ª—ã –≤–≤–æ–¥–∞/–≤—ã–≤–æ–¥–∞ –¥–ª—è DAQ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.
        """
        try:
            # –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è, —Å–≤—è–∑—ã–≤–∞—é—â–µ–≥–æ —Ç–∏–ø—ã –∫–∞–Ω–∞–ª–æ–≤ (–≤–≤–æ–¥/–≤—ã–≤–æ–¥) —Å –∏–º–µ–Ω–∞–º–∏ –º–æ–¥—É–ª–µ–π.
            channel_to_module_map = {
                key.split('/')[-1]: key.split('/')[0]
                for key, value in config['daq_configuration'].items()
                if key.endswith(('do', 'di'))
            }

            # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –æ–±—ä–µ–∫—Ç–∞ —Å –∏–º–µ–Ω–∞–º–∏ –º–æ–¥—É–ª–µ–π –¥–ª—è –∫–∞–Ω–∞–ª–æ–≤ –≤–≤–æ–¥–∞/–≤—ã–≤–æ–¥–∞.
            self.daq_output_module = channel_to_module_map.get('do')
            self.daq_input_module = channel_to_module_map.get('di')
        except Exception as error:
            # –í—ã–≤–æ–¥ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏.
            warning_window(f'–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–∞–Ω–∞–ª–æ–≤ DAQ {error}', False)

    def update_button_styles(self, open_button, close_button, margin_top):
        """
        –û–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç–∏–ª–∏ –∫–Ω–æ–ø–æ–∫ "–û—Ç–∫—Ä—ã—Ç—å" –∏ "–ó–∞–∫—Ä—ã—Ç—å".

        :param open_button: –û–±—ä–µ–∫—Ç –∫–Ω–æ–ø–∫–∏ "–û—Ç–∫—Ä—ã—Ç—å".
        :param close_button: –û–±—ä–µ–∫—Ç –∫–Ω–æ–ø–∫–∏ "–ó–∞–∫—Ä—ã—Ç—å".
        :param margin_top: –ó–Ω–∞—á–µ–Ω–∏–µ –≤–µ—Ä—Ö–Ω–µ–≥–æ –æ—Ç—Å—Ç—É–ø–∞ –¥–ª—è –∫–Ω–æ–ø–æ–∫.
        """

        open_button_style = f"""
                             QPushButton{{
                             background-color: #A61300;
                             border-bottom-left-radius:10px;
                             border-top-right-radius:10px;
                             margin-top: {margin_top};
                             }}
                             QPushButton:pressed {{ background-color: #FF2800 }}
                             """

        close_button_style = f"""
                              QPushButton{{
                              background-color: #007C21;
                              border-top-left-radius:10px;
                              border-bottom-right-radius:10px;
                              margin-top: {margin_top};
                              }}
                              QPushButton:pressed {{ background-color:#64DF85 }}
                              """

        open_button.setStyleSheet(open_button_style)
        close_button.setStyleSheet(close_button_style)

    def automatvisibl(self):
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ª–∏ —Ñ–ª–∞–∂–æ–∫
        if self.chkb.isChecked():
            try:
                # –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–∫–∞–∑–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π valve_widget
                self.valve_widget.show()
            except Exception:
                # –ï—Å–ª–∏ valve_widget –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä ValveControlWidget

                self.valve_widget = ValveControlWidget(self, dlgMain, self.side, self.auto_side)
                self.valve_widget.show()
        else:
            # –ï—Å–ª–∏ —Ñ–ª–∞–∂–æ–∫ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, —Å–∫—Ä—ã–≤–∞–µ–º valve_widget
            self.valve_widget.hide()

    def _update_shutter_display_color(self):
        """
        –û–±–Ω–æ–≤–ª—è–µ—Ç —Ü–≤–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∑–∞—Å–ª–æ–Ω–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.
        """
        with threading.Lock():
            try:
                shutter_open, shutter_close = self._fetch_device_state()
                determined_color = self._get_shutter_color(shutter_open, shutter_close)
                self._apply_color_to_label(determined_color)
            except Exception:
                self._apply_color_to_label('#FFFF00')

    def _fetch_device_state(self):
        """
        –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Ç–∏–ø–∞.

        :return: –ö–æ—Ä—Ç–µ–∂ –∏–∑ –¥–≤—É—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π: –æ—Ç–∫—Ä—ã—Ç–æ –∏ –∑–∞–∫—Ä—ã—Ç–æ.
        """
        device_state_fetchers = {
            'daq': self._read_from_endcup,
            'opc': self._read_from_opc,
            'modbus': self._read_from_endcup,
            'elemer': self._read_from_endcup
        }
        return device_state_fetchers[config['IPS'].get(self.ip)]()

    def _get_shutter_color(self, shutter_open, shutter_close):
        """
        –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ü–≤–µ—Ç –∑–∞—Å–ª–æ–Ω–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è.

        :param shutter_open: –°–æ—Å—Ç–æ—è–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ–π –∑–∞—Å–ª–æ–Ω–∫–∏.
        :param shutter_close: –°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ–π –∑–∞—Å–ª–æ–Ω–∫–∏.
        :return: –°—Ç—Ä–æ–∫–∞, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è —Ü–≤–µ—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ HEX.
        """
        return '#00FF00' if shutter_open else ('#FF0000' if shutter_close else '#FFFF00')

    def _apply_color_to_label(self, color):
        """
        –ü—Ä–∏–º–µ–Ω—è–µ—Ç –∑–∞–¥–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç –∫ –º–µ—Ç–∫–µ –∑–∞—Å–ª–æ–Ω–∫–∏.

        :param color: –°—Ç—Ä–æ–∫–∞, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è —Ü–≤–µ—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ HEX.
        """
        self.lab.setStyleSheet(
            f"""font:bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0;background-color: {color};text-align: center;""")

    def _read_from_opc(self):
        try:
            node_open = self.opc.get_node(f"ns=2;s={self.name}.DI{self.chr_open + 1:02d}Value")
            node_close = self.opc.get_node(f"ns=2;s={self.name}.DI{self.chr_close + 1:02d}Value")
            val_open = node_open.get_value()
            val_close = node_close.get_value()
            return val_open, val_close
        except Exception as e:
            print(f"[OPC UA] read_from_opc error: {e}")
            return 0, 0

    def update_lab_color(self):
        open_signal, close_signal = self._read_from_endcup()
        if open_signal and not close_signal:
            color = '#00FF00'  # –∑–µ–ª—ë–Ω—ã–π ‚Äî –æ—Ç–∫—Ä—ã—Ç
        elif close_signal and not open_signal:
            color = '#FF0000'  # –∫—Ä–∞—Å–Ω—ã–π ‚Äî –∑–∞–∫—Ä—ã—Ç
        else:
            color = '#FFFF00'  # –∂—ë–ª—Ç—ã–π ‚Äî –≤ –¥–≤–∏–∂–µ–Ω–∏–∏/–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ

        self.lab.setStyleSheet(
            f"""font:bold;border-radius: 10px;border: 1px solid black;
            margin-bottom: 0;background-color: {color};text-align: center;""")

    def _read_from_endcup(self):

        shutter_open = config['damper_data_queue'][self.reg][self.chr_open]
        shutter_close = config['damper_data_queue'][self.reg][self.chr_close]
        return shutter_open, shutter_close

    def onButtonPressed(self, action_name_suffix):
        '''–ú–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ –∏–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.

        –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        - self: —Å—Å—ã–ª–∫–∞ `–Ω–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∞—Å—Å–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω —ç—Ç–æ—Ç –º–µ—Ç–æ–¥.
        - action_name_suffix: —Å—Ç—Ä–æ–∫–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è —Å—É—Ñ—Ñ–∏–∫—Å –∏–º–µ–Ω–∏ –¥–µ–π—Å—Ç–≤–∏—è –∏–ª–∏ –∫–Ω–æ–ø–∫–∏.

        –î–µ–π—Å—Ç–≤–∏—è:
        - –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –≤–∫–ª—é—á–µ–Ω–æ –ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ (is_on) –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–ª–∏—á–∏—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ 'On' –≤ action_name_suffix.
        - –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö (chdv_type), –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã, –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–ª–∏—á–∏—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ 'Green' –≤ action_name_suffix.
        - –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫ (thread) –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ `update_damper` —Å –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏.
        - –ü–æ—Ç–æ–∫—É –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è –∏–º—è, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –∏–º—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –∫–ª–∞—Å—Å–∞ –∏ action_name_suffix.
        - –ü–æ—Ç–æ–∫ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è.

        –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:
        –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –ø—Ä–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏ —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–∏ –≤–∫–ª—é—á–µ–Ω–∏–∏/–≤—ã–∫–ª—é—á–µ–Ω–∏–∏ —á–µ–≥–æ-—Ç–æ, –∏ –æ–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –º–Ω–æ–≥–æ–∑–∞–¥–∞—á–Ω–æ—Å—Ç—å (–ø–æ—Ç–æ–∫–∏) –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á.
        '''
        is_on = 'On' in action_name_suffix
        chdv_type = self.chdv_open if 'Green' in action_name_suffix else self.chdv_close
        with Damper.lock:
            trz = threading.Thread(target=self.update_damper,
                                   args=[is_on, chdv_type, action_name_suffix],
                                   name=f'{self.name}_{action_name_suffix}')
            trz.start()

    def pressing(self, bt, time):
        """
          –ú–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–ø–æ–ª–Ω—è–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ.

          –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
          - self: —Å—Å—ã–ª–∫–∞ –Ω–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∞—Å—Å–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω —ç—Ç–æ—Ç –º–µ—Ç–æ–¥.
          - bt: —Ç–∏–ø –∫–Ω–æ–ø–∫–∏ (Open –∏–ª–∏ Close).
          - time: –≤—Ä–µ–º—è –∑–∞–¥–µ—Ä–∂–∫–∏.

          –î–µ–π—Å—Ç–≤–∏—è:
          - –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π –∫–Ω–æ–ø–∫–∏ (Open –∏–ª–∏ Close) —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ª—è–º–±–¥–∞-—Ñ—É–Ω–∫—Ü–∏–π –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç –∏—Ö –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ.

          –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:
          –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–æ–∫ –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ.

          """
        button_actions = {
            'Open': lambda: (self.onButtonPressed('turnOnGreen'), sleep(time), self.onButtonPressed('turnOffGreen')),
            'Close': lambda: (self.onButtonPressed('turnOnRed'), sleep(time), self.onButtonPressed('turnOffRed'))
        }
        # –ü–æ–ª—É—á–∞–µ–º –Ω—É–∂–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–∞ –∫–Ω–æ–ø–∫–∏
        action = button_actions.get(bt)
        if not action:
            return
        # –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è
        t1 = threading.Thread(target=action, name=f'{self}_{bt}')
        t1.start()

    def update_damper(self, ch_push_value, channel, calling_function_name):
        """
        –ú–µ—Ç–æ–¥, –æ–±–Ω–æ–≤–ª—è—é—â–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏ –≤—ã–ø–æ–ª–Ω—è—é—â–∏–π —Ä–∞–∑–ª–∏—á–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
        –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        - self: —Å—Å—ã–ª–∫–∞ –Ω–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∞—Å—Å–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω —ç—Ç–æ—Ç –º–µ—Ç–æ–¥.
        - ch_push_value: –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞—Å–ª–æ–Ω–∫–æ–π.
        - channel: –Ω–æ–º–µ—Ä –∫–∞–Ω–∞–ª–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è.
        - calling_function_name: –∏–º—è –≤—ã–∑—ã–≤–∞—é—â–µ–π —Ñ—É–Ω–∫—Ü–∏–∏.
        –î–µ–π—Å—Ç–≤–∏—è:
        - –û–±–Ω–æ–≤–ª—è–µ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (—Ü–≤–µ—Ç –∫–Ω–æ–ø–æ–∫) –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
        –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:
        –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∑–∞—Å–ª–æ–Ω–∫–æ–π –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.
        """
        color_map = {
            'turnOnGreen': ('8cd9ad', self.green_button),
            'turnOnRed': ('df022a', self.red_button),
            'turnOffGreen': ('007C21', self.green_button),
            'turnOffRed': ('A61300', self.red_button)
        }
        color, button = color_map.get(calling_function_name, (None, None))
        pattern = r"background-color:\s*#([A-Fa-f0-9]{6})"
        if button:
            current_stylesheet = button.styleSheet()
            match = re.search(pattern, current_stylesheet)
            if match:
                new_stylesheet = current_stylesheet.replace(match.group(1), color)
                button.setStyleSheet(new_stylesheet)
        #    self.lab.setStyleSheet(
        #        'font:bold;border-radius: 10px;border: 1px solid black;'
        #        f'margin-bottom: 0;background-color: #{color};text-align: center;')
        if config['imitation']:
            return

        hardware_actions = {
            'daq_output_module': lambda: self._signal_changed(channel, ch_push_value, 'daq'),
            'opc': lambda: (self._opc_action(channel, ch_push_value), sleep(0.05)),
            'modbus': lambda: self._signal_changed(channel, ch_push_value, 'modbus'),
            'elemer': lambda: self._signal_changed(channel, ch_push_value, 'elemer'),
        }
        for attr, action in hardware_actions.items():
            if hasattr(self, attr):
                action()
                break

        if calling_function_name in ('turnOffRed', 'turnOffGreen'):
            self._update_shutter_display_color()
        sleep(0.1)

    def _signal_changed(self, channel, ch_push_value, type):
        if type == 'modbus':
            config['dampers_signals'][self.reg][channel] = int(ch_push_value)
        elif type == 'daq':
            config['dampers_signals'][self.reg][channel] = ch_push_value
        else:
            config['dampers_signals'][self.reg][0x3000 + channel * 4] = 16256 if int(ch_push_value) else 0

    def _opc_action(self, ch, ch_push):
        try:
            node = self.opc.get_node(f"ns=2;s={self.name}.DO{ch + 2:02d}Value")
            node.set_value(bool(ch_push))
        except Exception as e:
            print(f"[OPC UA] write error: {e}")

    def _elemer_action(self, ch_push, ch):
        """–ú–µ—Ç–æ–¥ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏–π —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º Elemer.

        –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        - self: —Å—Å—ã–ª–∫–∞ –Ω–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∞—Å—Å–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω —ç—Ç–æ—Ç –º–µ—Ç–æ–¥.
        - ch_push: –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º.
        - ch: –Ω–æ–º–µ—Ä –∫–∞–Ω–∞–ª–∞ –∏–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.

        –î–µ–π—Å—Ç–≤–∏—è:
        - –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è `push` –Ω–∞ –æ—Å–Ω–æ–≤–µ `ch_push` (–ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è 16256, –µ—Å–ª–∏ `ch_push` –∏—Å—Ç–∏–Ω–Ω–æ, –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ 0).
        - –ó–∞–ø–∏—Å—å –∑–Ω–∞—á–µ–Ω–∏—è `push` –≤ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ Elemer –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –Ω–æ–º–µ—Ä–æ–º –∫–∞–Ω–∞–ª–∞ `ch`.

        –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:
        –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏–π —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º Elemer, —Ç–∞–∫–∏–º–∏ –∫–∞–∫ –∑–∞–ø–∏—Å—å –∑–Ω–∞—á–µ–Ω–∏–π –≤ —É–∫–∞–∑–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.

        """
        push = 16256 if ch_push else 0
        self.elemer.write_single_register(0x3000 + ch * 4, push)

    def info(self):
        '''–ú–µ—Ç–æ–¥ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ–∫—É—â–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä–µ –∫–ª–∞—Å—Å–∞ –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ.

        –î–µ–π—Å—Ç–≤–∏—è:
        - –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–µ –æ–∫–Ω–æ (`AnotherWindow`).
        - –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç—ã –¥–ª—è –º–µ—Ç–æ–∫ –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ, –æ—Ç–æ–±—Ä–∞–∂–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä–µ –∫–ª–∞—Å—Å–∞ (–Ω–∞–∑–≤–∞–Ω–∏–µ, –Ω–æ–º–µ—Ä–∞ –∫–∞–Ω–∞–ª–æ–≤ –∏ –¥—Ä—É–≥–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã).
        - –°–≤—è–∑—ã–≤–∞–µ—Ç —Å–æ–±—ã—Ç–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è —Å–ª–∞–π–¥–µ—Ä–∞ (`slider`) —Å –º–µ—Ç–æ–¥–æ–º `scaletext`.
        - –ó–∞–¥–∞–µ—Ç —Ä–∞–∑–º–µ—Ä—ã –∏ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ (–º–µ—Ç–∫–∏, –∫–Ω–æ–ø–∫–∏) –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ.

        –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:
        –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ–∫—É—â–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä–µ –∫–ª–∞—Å—Å–∞ –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.

        '''
        self.w = InfoWidget()  # ,chr_open=0, chr_close=1, chdv_open=0, chdv_close=1,
        self.w.label1.setText(f'name {self.name}')
        self.w.label2.setText(
            f'chr_op {self.chr_open} ,chr_cl {self.chr_close} ')
        self.w.label3.setText(
            f'chdv_op {str(self.chdv_open)} ,chdv_cl {str(self.chdv_close)}')
        self.w.label4.setText(f'{self.pos()}')
        self.w.slider.valueChanged.connect(self.scaletext)
        self.wi = self.widget.width()
        self.he = self.widget.height()
        self.wi_lab = self.lab.width()
        self.he_lab = self.lab.height()
        self.wi_b1 = self.red_button.width()
        self.he_b1 = self.red_button.height()
        self.wi_b2 = self.green_button.width()
        self.he_b2 = self.green_button.height()
        self.w.show()

    def scaletext(self, value):
        try:
            value = int(value)
        except ValueError:
            value = 0

        value = max(-10, min(value, 50))  # —Ä–∞–∑—É–º–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω

        font_size = 10 + value
        btn_w = 50 + value * 2
        btn_h = 35 + value
        widget_w = 120 + value * 4
        widget_h = 60 + value * 2

        self.lab.setFont(QFont('Arial', font_size))
        self.lab.setFixedSize(widget_w - 20, 25 + value)

        self.red_button.setFixedSize(btn_w, btn_h)
        self.green_button.setFixedSize(btn_w, btn_h)

        self.widget.setFixedSize(widget_w, widget_h)

        if self.side == 'V':
            # –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è ‚Äî –¥—Ä—É–≥–æ–π —Ä–∞—Å—á—ë—Ç
            widget_w = 65 + value * 2
            widget_h = 110 + value * 3
            self.widget.setFixedSize(widget_w, widget_h)
            self.lab.setFixedSize(25 + value, 95 + value * 2)
            self.red_button.setFixedSize(25 + value, 50 + value)
            self.green_button.setFixedSize(25 + value, 50 + value)

    def __str__(self):
        return f"Name:{self.name}"


class ValveControlWidget(QWidget):
    all_impuls_mutex = threading.Lock()

    def __init__(self, pa, gradpa, side, side_auto):
        super().__init__()
        """
        –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–ª–∞—Å—Å–∞ ValveControlWidget.

        Args:
            dlgMain: –ì–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ —ç—Ç–æ –æ–±—ä–µ–∫—Ç –≥–ª–∞–≤–Ω–æ–≥–æ –æ–∫–Ω–∞ –≤–∞—à–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è).
        """
        self.side = side
        self.side_auto = side_auto  # –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏–∫–∏ (–ø–∞–Ω–µ–ª–∏)
        self.gradpa = gradpa
        self.pa = pa
        self.widget_automat = None
        self.create_automat_widget()

    def create_automat_widget(self):
        """
        –°–æ–∑–¥–∞–µ—Ç –≤–∏–¥–∂–µ—Ç –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞—Å–ª–æ–Ω–∫–æ–π, –µ—Å–ª–∏ –æ–Ω –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–Ω.
        """
        if self.widget_automat is None:
            self.widget_automat = True
            self.setGeometry(self.calculate_widget_position())
            self.setup_ui_elements()

    def calculate_widget_position(self):
        """
        –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏–∫—É –ø–æ self.side_auto —Å —Ç–æ–Ω–∫–æ–π –ø–æ–¥–≥–æ–Ω–∫–æ–π –æ—Ç –∑–∞—Å–ª–æ–Ω–∫–∏.
        """
        base_x = self.pa.x()
        base_y = self.pa.y()

        auto_w = 120
        auto_h = 180
        offset = 10

        match self.side_auto.lower():
            case 'left':
                x = base_x - auto_w - offset - 10  # –ª–µ–≤–µ–µ
                y = base_y
            case 'right':
                x = base_x + self.pa.width() + offset - 20  # —á—É—Ç—å –ª–µ–≤–µ–µ
                y = base_y - auto_h // 4
            case 'top':
                x = base_x
                y = base_y - auto_h - 60
            case 'bottom':
                x = base_x
                y = base_y + self.pa.height() + offset - auto_h // 2
            case _:
                x = base_x
                y = base_y + self.pa.height() + offset

        return QRect(x, y, auto_w, auto_h)

    def setup_ui_elements(self):
        """
        –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –≤–Ω—É—Ç—Ä–∏ –≤–∏–¥–∂–µ—Ç–∞.
        """
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        self.comboA = QComboBox()
        self.comboA.view().setMinimumWidth(100)
        self.comboA.addItems([f'{i}' for i in self.gradpa.dlg_ourch])

        self.ustA = QDoubleSpinBox()
        self.ustA.setSuffix(' —É—Å—Ç–∞–≤–∫–∞')
        self.ustA.setDecimals(4)
        self.ustA.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)

        # –î–æ–±–∞–≤—å—Ç–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–º –æ–±—Ä–∞–∑–æ–º
        self.dopskA = QDoubleSpinBox()
        self.dopskA.setSuffix(' –¥–æ–ø—É—Å–∫')
        self.dopskA.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.dopskA.setDecimals(4)
        self.dopskA.setValue(0.1)
        self.dopskA.setMinimum(0.01)

        self.k_delay = QDoubleSpinBox()
        self.k_delay.setSuffix(' k –∑–∞–¥–µ—Ä–∂–∫–∏')
        self.k_delay.setDecimals(2)
        self.k_delay.setValue(2.0)
        self.k_delay.setMinimum(0.0)
        self.k_delay.setMaximum(10.0)

        self.max_delay = QDoubleSpinBox()
        self.max_delay.setSuffix(' –º–∞–∫—Å –∑–∞–¥–µ—Ä–∂–∫–∞')
        self.max_delay.setDecimals(1)
        self.max_delay.setValue(5.0)
        self.max_delay.setMinimum(1.0)
        self.max_delay.setMaximum(60.0)

        self.timesleepaft = QDoubleSpinBox()
        self.timesleepaft.setSuffix(' –∑–∞–¥–µ—Ä–∂–∫–∞')
        self.timesleepaft.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.timesleepaft.setDecimals(4)
        self.timesleepaft.setMinimum(0.01)
        self.timesleepaft.setValue(2)

        self.limit = QDoubleSpinBox()
        self.limit.setSuffix(' –∞–≤–∞—Ä–∏–π–Ω–æ–µ')
        self.limit.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.limit.setDecimals(4)
        self.limit.setValue(12)

        self.kp = QDoubleSpinBox()
        self.kp.setSuffix('  Kp')
        self.kp.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.kp.setDecimals(4)
        self.kp.setValue(0.08)

        self.ki = QDoubleSpinBox()
        self.ki.setSuffix('  Ki')
        self.ki.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.ki.setDecimals(4)
        self.ki.setValue(0.005)

        self.kd = QDoubleSpinBox()
        self.kd.setSuffix('  Kd')
        self.kd.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.kd.setDecimals(4)
        self.kd.setValue(0.001)

        self.chkbA = QCheckBox()
        self.chkbA.stateChanged.connect(self.automatwork)

        # –î–æ–±–∞–≤—å—Ç–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –º–∞–∫–µ—Ç
        self.layout.addWidget(QLabel(f'{self.pa.name}'))
        self.layout.addWidget(self.comboA)
        self.layout.addWidget(self.ustA)

        self.chk_safe = QCheckBox("‚è± –ö–æ–Ω—Ç—Ä–æ–ª—å –æ—Ç–∫–ª–∏–∫–∞")
        self.chk_safe.setToolTip("–í–∫–ª—é—á–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É —Ä–µ–∞–∫—Ü–∏–∏ –ø–æ—Å–ª–µ –∏–º–ø—É–ª—å—Å–∞ (–¥–∞—Ç—á–∏–∫ / –∫–æ–Ω—Ü–µ–≤–∏–∫–∏)")

        self.layout.addWidget(self.chk_safe)
        self.layout.addWidget(self.k_delay)
        self.layout.addWidget(self.max_delay)
        self.layout.addWidget(self.dopskA)
        self.layout.addWidget(self.timesleepaft)
        self.layout.addWidget(self.limit)
        self.layout.addWidget(self.kp)
        self.layout.addWidget(self.ki)
        self.layout.addWidget(self.kd)
        self.layout.addWidget(self.chkbA)
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setStyleSheet("border: 1px solid black;")

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_dragging = True
            self.offset = event.pos()

    def mouseMoveEvent(self, event):
        if self.is_dragging:
            new_pos = event.globalPos() - self.offset
            self.move(new_pos)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_dragging = False
            self.offset = None

    def automatwork(self):
        # –ï—Å–ª–∏ —Ñ–ª–∞–∂–æ–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –∑–∞–ø—É—Å–∫–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º
        if self.chkbA.isChecked():
            self.condition = True
            self.tr_auto = threading.Thread(target=self.p_auto)
            self.tr_auto.start()
        # –ï—Å–ª–∏ —Ñ–ª–∞–∂–æ–∫ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º
        else:
            self.condition = False
            if hasattr(self, 'tr_auto') and self.tr_auto.is_alive():
                self.tr_auto.join()

    def p_auto(self):
        """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è."""
        try:
            self._initialize_auto_params()
            while self.condition:
                self._process_auto_control()
        except Exception as e:
            print(e, 'p_auto')
            sleep(1)

    def _update_pid(self, setpoint, feedback):
        '''
          –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è PID-—Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞.

          –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∂–µ–ª–∞–µ–º—É—é —É—Å—Ç–∞–≤–∫—É (setpoint) –∏ —Ç–µ–∫—É—â—É—é –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å (feedback) –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∏
          —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —É–ø—Ä–∞–≤–ª—è—é—â–∏–π —Å–∏–≥–Ω–∞–ª PID –¥–ª—è —Ä–µ–≥—É–ª–∏—Ä–æ–≤–∞–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã.

          –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
          setpoint (float): –ñ–µ–ª–∞–µ–º–∞—è —É—Å—Ç–∞–≤–∫–∞.
          feedback (float): –¢–µ–∫—É—â–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å.

          –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
          float: –£–ø—Ä–∞–≤–ª—è—é—â–∏–π —Å–∏–≥–Ω–∞–ª PID.

          '''
        # –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ –º–µ–∂–¥—É –∂–µ–ª–∞–µ–º–æ–π —É—Å—Ç–∞–≤–∫–æ–π –∏ —Ç–µ–∫—É—â–µ–π –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é.
        error = abs(setpoint - feedback)
        # –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞—Ü–∏–∏ (derivative) –ø—É—Ç–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—à–∏–±–∫–∏ —Å –º–æ–º–µ–Ω—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.
        derivative = error - self.last_error
        # –ù–∞–∫–∞–ø–ª–∏–≤–∞—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ (integral) –ø—É—Ç–µ–º —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –æ—à–∏–±–∫–∏ —Å —Ç–µ—á–µ–Ω–∏–µ–º –≤—Ä–µ–º–µ–Ω–∏.
        self.integral += error
        # –í—ã—á–∏—Å–ª–∏—Ç—å —É–ø—Ä–∞–≤–ª—è—é—â–∏–π —Å–∏–≥–Ω–∞–ª PID –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ P, I –∏ D –∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –æ—à–∏–±–∫–∏.
        output = (self.kp.value() * error) + (self.ki.value() * self.integral) + (self.kd.value() * derivative)
        # –û–±–Ω–æ–≤–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏.
        self.last_error = error
        # –í–µ—Ä–Ω—É—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–π —É–ø—Ä–∞–≤–ª—è—é—â–∏–π —Å–∏–≥–Ω–∞–ª, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–∏–º–µ–Ω–µ–Ω –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º–æ–π –∏ –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ –æ—à–∏–±–∫–∏.
        return output

    def _initialize_auto_params(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è."""
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–∞—Ç—á–∏–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –∫–æ–º–±–æ-–±–æ–∫—Å–µ
        self.sensor_for_auto = next(
            sensor for sensor in self.gradpa.dlg_ourch if sensor.name in self.comboA.currentText())
        self.index = self.comboA.findText(str(self.sensor_for_auto))

        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–π
        self.diapozon = np.round(
            np.arange(self.ustA.value() - self.dopskA.value(), self.ustA.value() + self.dopskA.value(), 0.001,
                      dtype=float), 3)

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—à–∏–±–æ–∫ –¥–ª—è PID-—Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞
        self.last_error = 0.0  # –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞
        self.integral = 0.0  # –ò–Ω—Ç–µ–≥—Ä–∞–ª –æ—à–∏–±–∫–∏

    def _process_auto_control(self):
        """–¶–∏–∫–ª –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è: –∏–º–ø—É–ª—å—Å ‚Üí –∞–Ω–∞–ª–∏–∑ ‚Üí –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –¥–µ–π—Å—Ç–≤–∏–µ–º."""
        self.sensor_data = float(
            f"{Damper.sensor_data.get((self.sensor_for_auto.reg, self.sensor_for_auto.ch), float('nan')):.3f}")
        self.impuls = round(max(0, self._update_pid(self.ustA.value(), self.sensor_data) or 0), 4) or 0

        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è
        on_action, off_action, value = (
                (self.sensor_data > self.limit.value() and ('turnOnRed', 'turnOffRed', self.timesleepaft.value())) or
                ((self.sensor_data < self.diapozon[0] or self.sensor_data < 0) and (
                    'turnOnGreen', 'turnOffGreen', self.impuls)) or
                (self.sensor_data > self.diapozon[-1] and ('turnOnRed', 'turnOffRed', self.impuls))
        )

        # –í–∫–ª—é—á–∞–µ–º —Å–∏–≥–Ω–∞–ª
        self.pa.onButtonPressed(on_action)
        with self.all_impuls_mutex:
            self.pa.__class__.all_impuls.update({self.pa.name: self.impuls})
        sleep(value)  # –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–º–ø—É–ª—å—Å–∞ (—É–¥–µ—Ä–∂–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞)

        # –í—ã–∫–ª—é—á–∞–µ–º —Å–∏–≥–Ω–∞–ª
        self.pa.onButtonPressed(off_action)
        with self.all_impuls_mutex:
            self.pa.__class__.all_impuls.update({self.pa.name: 0})

        # –ö–æ–Ω—Ç—Ä–æ–ª—å –æ—Ç–∫–ª–∏–∫–∞ –∏ –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∏–º–ø—É–ª—å—Å–æ–º
        if self.chk_safe.isChecked():
            expected = 'open' if 'Green' in on_action else 'close'
            success = self.wait_and_check(expected=expected)

            if not success:
                print(f"[AUTO][{self.pa.name}] ‚ùó –ù–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ {on_action}")

            # –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É —Ü–∏–∫–ª–∞–º–∏
            delta = abs(self.sensor_data - self.ustA.value())
            base = self.timesleepaft.value()
            k = self.k_delay.value()
            maxd = self.max_delay.value()
            delay = min(base + k * delta, maxd)

            if self.behavior == '—Å–∫–∞—á–æ–∫':
                print(f"[AUTO][{self.pa.name}] üí• –°–∫–∞—á–æ–∫ ‚Äî –ø–∞—É–∑–∞ {delay:.2f} —Å–µ–∫")
                sleep(delay)

            elif self.behavior == '–ø–µ—Ä–µ–ª—ë—Ç':
                delta_ust = self.ustA.value() - self.sensor_data
                if delta_ust > self.dopskA.value() * 3:
                    print(f"[AUTO][{self.pa.name}] ‚ùó –°–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–ª—ë—Ç ‚Äî —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ")
                    self.pa.onButtonPressed('turnOnRed')
                    sleep(1.5)
                    self.pa.onButtonPressed('turnOffRed')
                else:
                    print(f"[AUTO][{self.pa.name}] ‚Üò –ù–µ–∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–π –ø–µ—Ä–µ–ª—ë—Ç ‚Äî –ø–∞—É–∑–∞ {delay:.2f}")
                    sleep(delay)

            elif self.behavior == '–Ω–æ—Ä–º–∞':
                print(f"[AUTO][{self.pa.name}] ‚úÖ –ù–æ—Ä–º–∞ ‚Äî –ø–∞—É–∑–∞ {delay:.2f} —Å–µ–∫")
                sleep(delay)

            elif self.behavior == '–Ω–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏':
                print(f"[AUTO][{self.pa.name}] ‚ö† –ù–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏ ‚Äî –ø–∞—É–∑–∞ {base:.2f} —Å–µ–∫")
                sleep(base)
        else:
            # –ë–µ–∑ –∫–æ–Ω—Ç—Ä–æ–ª—è –æ—Ç–∫–ª–∏–∫–∞ ‚Äî –æ–±—ã—á–Ω–∞—è –ø–∞—É–∑–∞ –ø–æ—Å–ª–µ –∏–º–ø—É–ª—å—Å–∞
            sleep(self.timesleepaft.value())

    def wait_and_check(self, expected='open', step=0.2):
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∏–∑–º–µ–Ω–∏–ª–∞—Å—å –ª–∏ —Å–∏—Ç—É–∞—Ü–∏—è –ø–æ—Å–ª–µ –∏–º–ø—É–ª—å—Å–∞:
        - –ø–æ –∫–æ–Ω—Ü–µ–≤–∏–∫–∞–º (–µ—Å–ª–∏ –µ—Å—Ç—å)
        - –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é —Å–µ–Ω—Å–æ—Ä–∞ (–µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω)

        –¢–∞–∫–∂–µ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä –æ—Ç–∫–ª–∏–∫–∞:
        - '—Å–∫–∞—á–æ–∫' ‚Äî —Ä–µ–∑–∫–æ–µ –ø–æ–≤—ã—à–µ–Ω–∏–µ –¥–∞–≤–ª–µ–Ω–∏—è
        - '–ø–µ—Ä–µ–ª—ë—Ç' ‚Äî —Ä–µ–∑–∫–æ–µ –ø–æ–Ω–∏–∂–µ–Ω–∏–µ (–ø–µ—Ä–µ–∂–∞—Ç–∏–µ)
        - '–Ω–æ—Ä–º–∞' ‚Äî –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
        - '–Ω–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏' ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å

        :param expected: 'open' –∏–ª–∏ 'close'
        :return: True –µ—Å–ª–∏ –µ—Å—Ç—å –æ—Ç–∫–ª–∏–∫, False –µ—Å–ª–∏ –Ω–µ—Ç
        """

        timeout = self.timesleepaft.value()
        start_time = time.time()
        ok = False
        self.behavior = '–Ω–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏'

        try:
            sensor_value_before = float(Damper.sensor_data.get(
                (self.sensor_for_auto.reg, self.sensor_for_auto.ch), float('nan')))
            chr_expected = self.pa.chr_open if expected == 'open' else self.pa.chr_close

            for _ in range(int(timeout / step)):
                QCoreApplication.processEvents()
                time.sleep(step)

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –∫–æ–Ω—Ü–µ–≤–∏–∫—É
                if config['damper_data_queue'][self.pa.reg][chr_expected]:
                    self.behavior = '–Ω–æ—Ä–º–∞'
                    ok = True
                    break

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ —Å–µ–Ω—Å–æ—Ä—É
                sensor_value_now = float(Damper.sensor_data.get(
                    (self.sensor_for_auto.reg, self.sensor_for_auto.ch), float('nan')))
                if not math.isnan(sensor_value_before) and not math.isnan(sensor_value_now):
                    delta = sensor_value_now - sensor_value_before

                    if abs(delta) > 0.8:
                        self.behavior = '—Å–∫–∞—á–æ–∫'
                    elif delta < -0.5:
                        self.behavior = '–ø–µ—Ä–µ–ª—ë—Ç'
                    elif abs(delta) > 0.05:
                        self.behavior = '–Ω–æ—Ä–º–∞'
                    else:
                        self.behavior = '–Ω–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏'

                    ok = self.behavior in ('–Ω–æ—Ä–º–∞', '–ø–µ—Ä–µ–ª—ë—Ç')
                    break
        except Exception as e:
            print(f"[AUTO][{self.pa.name}] wait_check error: {e}")

        return ok


class InfoWidget(QWidget):
    # –≠—Ç–æ—Ç –∫–ª–∞—Å—Å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–∏–¥–∂–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω
    # –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ.
    def __init__(self):
        super().__init__()
        self.pa = self.sender().parent()
        self.setFont(QFont("Arial", 12))

        self.layoutAW = QVBoxLayout()
        self.label1 = QLabel()
        self.label2 = QLabel()
        self.label3 = QLabel()
        self.label4 = QLabel()
        self.slider = QSlider()
        self.slider.setOrientation(Qt.Horizontal)
        self.slider.setRange(-100, 500)

        self.chk = QCheckBox()
        self.chk.stateChanged.connect(self.toggle_other_element)
        self.chklbl = QLabel()
        self.chklbl.setText('—Å–ø—Ä—è—Ç–∞—Ç—å –∏–º—è')

        self.const = QLineEdit()
        #self.const.setText(str(self.pa.amendment))

        self.const.setValidator(QRegExpValidator(QRegExp(r'-?\d*\.?\d+')))
        self.const.textChanged.connect(lambda: self.on_text_changed(self.const.text()))

        self.layoutAW.addWidget(self.chk)
        self.layoutAW.addWidget(self.chklbl)
        self.layoutAW.addWidget(self.slider)
        self.layoutAW.addWidget(self.label1)
        self.layoutAW.addWidget(self.label2)
        self.layoutAW.addWidget(self.label3)
        self.layoutAW.addWidget(self.label4)
        self.layoutAW.addWidget(self.const)
        self.setLayout(self.layoutAW)
        self.chk.stateChanged.connect(self.toggle_other_element)

        self.timer = QTimer(self)
        self.timer.setSingleShot(True)  # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω—ã–π –∑–∞–ø—É—Å–∫
        self.timer.timeout.connect(self.process_text)

    def on_text_changed(self, text):
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞
        self.pa.update_sensor_amendment.emit(text)
        self.timer.stop()
        self.timer.start(2000)  # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –Ω–∞ 3 —Å–µ–∫—É–Ω–¥—ã

    def process_text(self):
        # –ú–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω –ø–æ –∏—Å—Ç–µ—á–µ–Ω–∏–∏ 3 —Å–µ–∫—É–Ω–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ —Ç–µ–∫—Å—Ç–µ
        text = self.const.text()
        if text == '':
            text = '0'
        self.const.setText(text)
        self.pa.amendment = float(text)

    def toggle_other_element(self, state):
        try:
            if state == Qt.Checked:
                self.pa.l1.setText(' ')
            else:
                self.pa.l1.setText(f'{self.pa.name}')
        except AttributeError:
            pass


class Sensor(MovableObject):
    '''
    –ö–ª–∞—Å—Å Sensor –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–∏–¥–∂–µ—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ–Ω—Å–æ—Ä–∞—Ö.

    –ê—Ç—Ä–∏–±—É—Ç—ã:
    - name: –ù–∞–∑–≤–∞–Ω–∏–µ —Å–µ–Ω—Å–æ—Ä–∞.
    - reg: –†–µ–≥–∏—Å—Ç—Ä (—Å —É—á–µ—Ç–æ–º —Å–º–µ—â–µ–Ω–∏—è –Ω–∞ 1).
    - ch: –ö–∞–Ω–∞–ª (—Å —É—á–µ—Ç–æ–º —Å–º–µ—â–µ–Ω–∏—è –Ω–∞ 1).
    - amendment: –ü–æ–ø—Ä–∞–≤–∫–∞.
    - bit_depth: –†–∞–∑—Ä—è–¥–Ω–æ—Å—Ç—å.
    - l1: QPushButton —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º —Å–µ–Ω—Å–æ—Ä–∞.
    - l2: QLabel —Å —Å–∏–º–≤–æ–ª–æ–º '‚ô£'.
    - clr: –¶–≤–µ—Ç —Å–µ–Ω—Å–æ—Ä–∞.
    - ip: IP-–∞–¥—Ä–µ—Å —Å–µ–Ω—Å–æ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞.
    - side_name: –ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω—ã, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–π —Å–µ–Ω—Å–æ—Ä –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è.
    - moveon: –§–ª–∞–≥ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Å–µ–Ω—Å–æ—Ä–∞.

    –ú–µ—Ç–æ–¥—ã:
    - bge(clr): –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—Ç–∏–ª—å —Ñ–æ–Ω–∞ QLabel –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–≤–µ—Ç–∞.
    - layoutside(side_name): –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –º–∞–∫–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã.
    - mousePressEvent(evt): –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Å–µ–Ω—Å–æ—Ä–∞.
    - mouseMoveEvent(evt): –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–µ–Ω—Å–æ—Ä–∞ –º—ã—à—å—é –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –µ–≥–æ –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é.
    - poschange(): –ò–∑–º–µ–Ω—è–µ—Ç –ø–æ–∑–∏—Ü–∏—é —Å–µ–Ω—Å–æ—Ä–∞ –∏ –ø–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –º–∞–∫–µ—Ç–µ.
    - info(): –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–µ–Ω—Å–æ—Ä–µ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –æ–∫–Ω–µ.
    - hidename(h): –°–∫—Ä—ã–≤–∞–µ—Ç –∏–ª–∏ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∏–º—è —Å–µ–Ω—Å–æ—Ä–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–Ω–∞—á–µ–Ω–∏—è h.
    - scaletext(value): –ò–∑–º–µ–Ω—è–µ—Ç —Ä–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ –∏ —Ä–∞–∑–º–µ—Ä—ã —Å–µ–Ω—Å–æ—Ä–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–Ω–∞—á–µ–Ω–∏—è value.
    - __str__(): –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ Sensor.

    '''
    update_sensor_bord = pyqtSignal(str)  # —Å–∏–≥–Ω–∞–ª: –∏–º—è —Å–µ–Ω—Å–æ—Ä–∞ –∏ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    update_sensor_amendment = pyqtSignal(str)
    def __init__(self, name='‚ô•', ch=1, clr='bl', side_name='l', bit_depth=2, reg=1, amendment=0.0, parent=None):
        super(Sensor, self).__init__(parent)
        self.name = name
        self.reg = config['adjust_index'](reg)
        self.ch = config['adjust_index'](ch)
        self.amendment = amendment
        self.bit_depth = bit_depth
        self.l1 = QPushButton(self.name)
        self.l1.setFont(QFont("Arial", 13))
        self.l1.setStyleSheet('border : 5;background: transparent;')
        self.l2 = QLabel('‚ô£')
        self.l2.setAlignment(Qt.AlignCenter)
        self.update_sensor_bord.connect(self.on_update_sensor_bord)
        self.clr = clr
        self.ip = list(config['IPS'])[self.reg]

        self.side_name = side_name
        self.layoutside(self.side_name)
        self.l2.setFont(QFont('Times', 18, weight=QFont.Bold))
        self.l2.setStyleSheet(self.bge(self.clr))

        self.l1.clicked.connect(self.info)
        self.moveon = False
        self.scaletext(config['sensor_size'])
        self.hidename(config['hidename'])
        self.l1.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.l2.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        #      layout.setContentsMargins(0, 0, 0, 0)
        #      layout.setSpacing(4)
        self.setToolTip(f"—Ä–µ–≥={self.reg}, –∫–∞–Ω–∞–ª={self.ch}")
        self.update_sensor_amendment.connect(self.amendment_eddit)

    @pyqtSlot(str)
    def amendment_eddit(self, amendment):
        self.amendment=float(amendment)
    @pyqtSlot(str)
    def on_update_sensor_bord(self, color):
        self.l2.setStyleSheet(color)

    def bge(self, clr):
        # –≤—ã–±–æ—Ä —Ü–≤–µ—Ç–∞
        clr = clr.lstrip('#')
        colors = {
            'si': '192,192,192',
            'wh': '255,255,255',
            'fu': '255,0,255',
            'pu': '238,130,238',
            're': '255,160,137',
            'ma': '128,0,0',
            'ye': '255,255,0',
            'ol': '128,128,0',
            'li': '0,255,0',
            'gr': '50,205,50',
            'aq': '0,255,255',
            'te': '0,128,128',
            'bl': '153,153,255',
            'na': '0,0,128'
        }

        if clr not in colors:
            return f'.QLabel{{background-color: #{clr};margin:1px;border:1px solid rgb(0,0,0);border-radius: 10px;}}'
        else:
            return f'.QLabel{{background-color: rgb({colors[clr]});margin:1px;border:1px solid rgb(0,0,0);border-radius: 10px;}}'

    def layoutside(self, side_name):
        # –≤—ã–±–æ—Ä —Å—Ç–æ—Ä–æ–Ω—ã
        side_layouts = {
            'left': (150, 20, QHBoxLayout, [self.l1, self.l2]),
            'top': (110, 50, QVBoxLayout, [self.l1, self.l2]),
            'right': (150, 20, QHBoxLayout, [self.l2, self.l1]),
            'bottom': (110, 50, QVBoxLayout, [self.l2, self.l1])
        }

        side_name = side_name.lower()

        if side_name in side_layouts:
            width, height, layout_type, widgets = side_layouts[side_name]
            layout = layout_type(self)
            for widget in widgets:
                layout.addWidget(widget)

    def info(self):
        self.w = InfoWidget()
        self.w.label1.setText(f'{self}')
        self.w.label4.setText(f'{self.pos()}')
        self.w.slider.valueChanged.connect(self.scaletext)
        self.w.chk.stateChanged.connect(self.hidename)
        self.w.show()

    def hidename(self, h):
        self.l1.hide() if h == 1 else self.l1.show()

    def scaletext(self, value):
        try:
            value = int(value)
        except ValueError:
            value = 0  # –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç

        value = max(-10, min(value, 500))  # –¥–∏–∞–ø–∞–∑–æ–Ω -10..50

        self.l2.setFont(QFont('Times', 14 + value, weight=QFont.Bold))
        self.l2.setFixedSize(100 + value * 5, 35 + value)
        self.setFixedSize(150 + value * 5, 70 + value * 2)

    def __str__(self):
        return f"{self.name}  ch {self.ch}  reg {self.reg}"


class Translate(QPushButton):
    """
        –ö–ª–∞—Å—Å Translate –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–∏–¥–∂–µ—Ç –∫–Ω–æ–ø–∫–∏, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–ø–æ–ª–Ω—è–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–µ—Ä–µ–∫–ª–∞–¥–∫–∏ –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏.
        """

    def __init__(self, z1, z2, damper_list, z1_sleep, z2_sleep, time_rearrangement, parent=None):
        super(Translate, self).__init__(parent)
        self.rearrangement_cond = True
        self.setGeometry(self.x(), self.y(), 150, 30)
        self.setFont(QFont("Fira Mono Bold", 13))
        self.name = f' {z1}‚Üê‚Üí{z2}'
        self.setText(f'{self.name}')
        self.setStyleSheet(
            "QPushButton {padding-top:7px;background-color: lightgreen;font: bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0}")
        self.clicked.connect(self.threading_rearrangement)
        self.z1 = next((i for i in damper_list if z1 in i.name), None)
        self.z2 = next((i for i in damper_list if z2 in i.name), None)
        self.z1_sleep = z1_sleep
        self.z2_sleep = z2_sleep
        self.time_rearrangement = time_rearrangement

    def threading_rearrangement(self):
        self.setEnabled(False)  # –û—Ç–∫–ª—é—á–∏—Ç–µ –∫–Ω–æ–ø–∫—É
        threading.Thread(target=self.rearrangement, args=[self.z1, self.z2]).start()

    def rearrangement(self, z1, z2):
        try:
            self.rearrange_elements(z1, z2)
        except Exception:
            warning_window('Check the limit switches')

    def rearrange_elements(self, active_element, inactive_element):
        """
                –£–ø—Ä–∞–≤–ª—è–µ—Ç –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–æ–π —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º —Å—Ç–∏–ª–µ–π –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º –æ–ø–µ—Ä–∞—Ü–∏–π –≤ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–æ—Ç–æ–∫–∞—Ö.
                """
        open_color, close_color = '#00FF00', '#FF0000'
        active_element.lab.setStyleSheet(f'background-color: {open_color if self.rearrangement_cond else close_color}')
        inactive_element.lab.setStyleSheet(
            f'background-color: {close_color if self.rearrangement_cond else open_color}')
        active_sleep, inactive_sleep = self.z1_sleep, self.z2_sleep
        button1, button2 = ('Green', 'Red') if self.rearrangement_cond else ('Red', 'Green')
        threading.Thread(target=self.execute, args=(active_element, active_sleep, button1)).start()
        threading.Thread(target=self.execute, args=(inactive_element, inactive_sleep, button2)).start()
        self.rearrangement_cond = not self.rearrangement_cond

    def execute(self, element, sleep_time, indicator_name):
        """
                –í—ã–ø–æ–ª–Ω—è–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ —ç–ª–µ–º–µ–Ω—Ç–æ–º, –≤–∫–ª—é—á–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫—É —Ü–≤–µ—Ç–æ–≤—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∑–∞–¥–µ—Ä–∂–∫–∏.
                """
        sleep(float(sleep_time))
        element.onButtonPressed(f'turnOn{indicator_name}')
        sleep(int(self.time_rearrangement))
        element.onButtonPressed(f'turnOff{indicator_name}')
        self.setEnabled(True)  # –í–∫–ª—é—á–∏—Ç–µ –∫–Ω–æ–ø–∫—É —Å–Ω–æ–≤–∞


class Formula(Sensor, QWidget):
    def __init__(self, name, mathematics, clr, side_name, bit_depth=1):
        super().__init__()
        self.name = name
        self.clr = clr
        self.l2.setStyleSheet(self.bge(self.clr))
        self.mathematics = mathematics
        self.bit_depth = bit_depth
        self.l1.setText(self.name)
        self.layoutside(side_name)

    def __str__(self):
        return f'{self.name},{self.mathematics}'


class Const(Sensor, QWidget):
    def __init__(self, name, const, clr, side_name, bit_depth=1):
        super().__init__()
        self.name = name
        self.const = const
        self.clr = clr
        self.bit_depth = bit_depth
        self.moveon = False

        self.l2 = QLineEdit(self)
        self.l2.setText(str(self.const))
        self.l2.setFont(QFont('Times', 14, weight=QFont.Bold))
        self.l2.setFixedSize(80, 25)

        self.l1.setText(self.name)
        self.layoutside(side_name)  # ‚Üê –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ!
        self.setStyleSheet(f"color: {self.clr}; background-color: transparent;")

        regex = QRegExp(r'-?\d*\.?\d+')
        validator = QRegExpValidator(regex)
        self.l2.setValidator(validator)
        self.l2.textChanged.connect(self.on_text_changed)

        # –¢–∞–π–º–µ—Ä –¥–ª—è –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
        self.timer = QTimer(self)
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.process_text)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Å–µ–±—è
        config.setdefault('constants', {})[self.name] = self

    def on_text_changed(self, text):
        self.timer.stop()
        self.timer.start(2000)

    def process_text(self):
        text = self.l2.text()
        if text in ['', '0', '0.']:
            text = '1'
        try:
            self.const = float(text)
            self._update_setting_file()

            # üîÅ –ê–≤—Ç–æ–ø–µ—Ä–µ—Ä–∞—Å—á—ë—Ç —Ñ–æ—Ä–º—É–ª
            parent = self.parent()
            if hasattr(parent, "formuls") and hasattr(parent, "calculate_formulas"):
                formulas = [f.name for f in parent.formuls]
                parent.calculate_formulas(formulas)

        except ValueError:
            self.l2.setText(str(self.const))  # –æ—Ç–∫–∞—Ç

    def _update_setting_file(self):
        try:
            path = config.get('setting_file', 'setting1.txt')
            with open(path, 'r', encoding='utf-8') as f:
                lines = f.readlines()

            with open(path, 'w', encoding='utf-8') as f:
                for line in lines:
                    if line.startswith('Const') and line.split()[1] == self.name:
                        parts = line.split()
                        parts[2] = str(self.const)
                        line = ' '.join(parts) + '\n'
                    f.write(line)
        except Exception as e:
            print(f"[Const Save Error] {e}")


class Furnace(QSlider):
    sensor_data = []

    """–ü–µ—á–∏"""

    def __init__(self, name='‚ô•', ch_ao=1, diapason=8.0, reg=1, x=0, y=0, parent=None):
        super(Furnace, self).__init__(parent)

        self.clicked_once = False
        self.last_warning_time_dp = 0.0
        self.last_warning_time_dt = True
        self.second = 1
        self.condition = False
        self.ch_ao = config['adjust_index'](ch_ao)
        self.reg = config['adjust_index'](reg)
        self.diapason = diapason

        self.ip = list(config['IPS'])[self.reg]
        self.client = ModbusClient(
            host=self.ip,
            port=502,
            unit_id=1,
            auto_open=True)

        handlers = {
            'daq': self.handle_daq,
            'opc': self.handle_opc,
            'modbus': lambda: setattr(self, 'modbus', True),
            'elemer': lambda: setattr(self, 'elemer', True)
        }

        handlers[config['IPS'].get(self.ip)]()
        self.name = name
        self.resize(30, int(parent.frameGeometry().height() / 4))
        self.lb = QLabel(self.parent())
        self.lb.setText('0.0')
        self.lb.setFont(QFont('Arial', 11))
        self.lb.move(int(x), int(y) + self.height())
        self.parent().layout().addWidget(self.lb)
        self.setSingleStep(10)
        self.setRange(0, int(self.diapason * 10))
        self.valueChanged.connect(lambda v: self.lb.setText(str(v / 1000)))

        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ü–ò–î-—Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞
        self.setpoint = 0.0  # –£—Å—Ç–∞–≤–∫–∞ –ü–ò–î-—Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞
        self.last_error = 0.0  # –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞
        self.integral = 0.0  # –ò–Ω—Ç–µ–≥—Ä–∞–ª –æ—à–∏–±–∫–∏
        self.output = 0.0  # –í—ã—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ

        self.container_hight = QWidget(self.parent())
        row_layout_0 = QVBoxLayout(self.container_hight)

        container_widget = QWidget()
        row_layout = QHBoxLayout(container_widget)
        self.button = QCheckBox()
        self.button.stateChanged.connect(self.toggle_pid)
        self.pid_enabled = False

        self.setpoint_value = QDoubleSpinBox()
        self.setpoint_value.setMaximum(999)
        self.setpoint_value.setDecimals(0)

        self.sensordt = QComboBox()
        self.sensordt.currentIndexChanged.connect(self.value_changed)
        self.first_mouse_clickdt = True
        self.sensordt.installEventFilter(self)

        self.sensordp = QComboBox()
        self.sensordp.currentIndexChanged.connect(self.value_changed)
        self.first_mouse_clickdp = True
        self.sensordp.installEventFilter(self)

        row_layout.setContentsMargins(0, 0, 0, 0)  # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ç—Å—Ç—É–ø—ã –≤ 0 –ø–∏–∫—Å–µ–ª–µ–π
        row_layout.addWidget(self.button, 1)  # –ø–µ—Ä–≤—ã–π –≤–∏–¥–∂–µ—Ç, 1/4 –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
        row_layout.addWidget(self.setpoint_value, 3)  # –≤—Ç–æ—Ä–æ–π –≤–∏–¥–∂–µ—Ç, 3/4 –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
        row_layout_0.addWidget(container_widget)
        row_layout_0.addWidget(self.sensordt)
        row_layout_0.addWidget(self.sensordp)
        self.kp = QDoubleSpinBox(self.parent())
        self.kp.setSuffix(' kp')
        row_layout_0.addWidget(self.kp)

        self.kp.setValue(20)
        self.kp.setDecimals(4)
        self.kp.setMinimum(-999)
        self.kp.setMaximum(999)

        self.ki = QDoubleSpinBox(self.parent())
        self.ki.setSuffix(' ki')
        self.ki.setMaximum(999)
        self.ki.setMinimum(-999)

        row_layout_0.addWidget(self.ki)

        self.ki.setDecimals(4)
        self.ki.setValue(0.45)

        self.kd = QDoubleSpinBox(self.parent())
        self.kd.setDecimals(4)
        self.kd.setMaximum(999)
        self.kd.setMinimum(-999)
        self.kd.setSuffix(' kd')
        row_layout_0.addWidget(self.kd)
        self.kd.setValue(200)

        self.T = QDoubleSpinBox(self.parent())
        self.T.setSuffix(' Ti')
        self.T.setDecimals(4)
        self.T.setMaximum(999)
        self.T.setValue(3)
        row_layout_0.addWidget(self.T)

        self.Max_mV = QDoubleSpinBox(self.parent())
        self.Max_mV.setDecimals(4)
        self.Max_mV.setMaximum(20)
        self.Max_mV.valueChanged.connect(lambda value: self.setRange(0, int(value * 1000)))
        row_layout_0.addWidget(self.Max_mV)
        self.container_hight.setGeometry(int(x) + self.width(), int(y), 85, 180)
        self.Max_mV.setValue(self.diapason)

        self.valueChanged.connect(self.onSliderChange)
        self.timerSlider = QTimer()
        self.timerSlider.setSingleShot(True)  # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–æ–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–µ
        self.timerSlider.timeout.connect(self.tz)

    def onSliderChange(self):
        self.timerSlider.start(1000)

    def handle_daq(self):
        try:
            self.daq = [key.split('/')[0] for key, value in config['daq_configuration'].items() if 'ao' in key][0]
        except Exception:
            pass

    def handle_opc(self):
        ip_part = ''.join([part.zfill(3) for part in self.ip.split('.', 2)[2].split('.')])
        self.modopc = config['daq_prefix'][0] + ip_part + config['daq_prefix'][1]

        self.opc = OpenOPC.client()

    def __str__(self):
        return f"{self.name}"

    def mousePressEvent(self, event):
        if not self.clicked_once:
            self.container_hight.show()
            self.clicked_once = True
        super().mousePressEvent(event)

    def eventFilter(self, obj, event):
        if obj == self.sensordt and event.type() == QEvent.MouseButtonPress and event.button() == 1:
            if self.first_mouse_clickdt:
                self.on_activated('DT')
                self.first_mouse_clickdt = False
            if self.first_mouse_clickdp:
                self.on_activated('DA')
                self.first_mouse_clickdp = False
            return True
        return super().eventFilter(obj, event)

    def on_activated(self, type):
        if type == 'DT':
            self.sensordt.addItems(
                [f'{sn.name}_{sn.ch}_{sn.reg}_{i}' for i, sn in enumerate(dlgMain.dlg_ourch) if type in sn.name])
        if type == 'DA':
            self.sensordp.addItems(
                [f'{sn.name}_{sn.ch}_{sn.reg}_{i}' for i, sn in enumerate(dlgMain.dlg_ourch) if type in sn.name])

    def value_changed(self, sender):
        try:
            if sender == 'DT':
                print(self.sensor_data)
                vl = self.sensordt.currentText().split('_')
                reg, ch = int(vl[2]), int(vl[3])
                datavl = self.sensor_data.get((reg, ch), float('nan'))
                return datavl
            if sender == 'DA':
                vl = self.sensordp.currentText().split('_')
                datavl = self.sensor_data[int(vl[2])][int(vl[3])]
                return datavl

        except IndexError:
            warning_window('–í—ã–±–µ—Ä–∏—Ç–∏ –¥–∞—Ç—á–∏–∫–∏ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è PID', False)

    def tz(self):
        if config['imitation']: return
        fr = threading.Thread(target=self.signal, args=[self.value()])
        fr.start()
        fr.join()

    def send_daq_signal(self, value):
        with nidaqmx.Task() as task:
            task.ao_channels.add_ao_current_chan(f"{self.daq}/ao{self.ch_ao}",
                                                 name_to_assign_to_channel="Analog_Output_Channel")

            task.write(value / 1000000, auto_start=True)

    def send_opc_signal(self, value):
        try:
            node = self.opc.get_node(f"ns=2;s={self.name}.AO{self.ch_ao + 1:02d}Value")
            node.set_value(float(value))
        except Exception as e:
            print(f"[OPC UA] AO write error: {e}")

    def send_modbus_signal(self, value):
        v = struct.unpack('>l', struct.pack('>f', value / 1000000))[0]
        x = [(v & 0xffff), (v >> 16)]
        sleep(0.1)
        self.client.write_multiple_registers(self.ch_ao * 2, x)
        # self.c.close()

    def send_elemer_signal(self, value):
        pass

    def signal(self, value):
        protocol_handlers = {
            'daq': lambda: self.send_daq_signal(value),
            'opc': lambda: self.send_opc_signal(value),
            'modbus': lambda: self.send_modbus_signal(value),
            'elemer': lambda: self.send_elemer_signal(value)
        }
        protocol_handlers[config['IPS'].get(self.ip)]()

    def update_pid(self):
        if self.value_changed('DA') < 0.1:
            current_time = time.time()
            if current_time - self.last_warning_time_dp > 60:  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
                warning_window('–ù–∏–∑–∫–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ PID', False)
                self.last_warning_time_dp = current_time  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
            self.setValue(0)
            self.toggle_pid()
            return

        frirst = self.value_changed('DT')
        if self.setpoint_value.value() <= int(frirst) and frirst - self.second >= 0:
            self.condition = True
        if frirst > self.setpoint_value.value() + 5 and self.condition:
            if self.last_warning_time_dt:  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
                self.last_warning_time_dt = False
                self.setValue(int(self.value() / 1.5))
            if frirst - self.second <= 0:
                self.condition = False
            self.second = frirst
            return
        self.last_warning_time_dt = True
        error = self.setpoint_value.value() - self.value_changed('DT')  # –†–∞–∑–Ω–æ—Å—Ç—å –º–µ–∂–¥—É —É—Å—Ç–∞–≤–∫–æ–π –∏ —Ç–µ–∫—É—â–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ–º
        self.integral += error  # –ò–Ω—Ç–µ–≥—Ä–∞–ª –æ—à–∏–±–∫–∏
        derivative = error - self.last_error  # –î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª –æ—à–∏–±–∫–∏
        self.output = self.kp.value() * error + self.ki.value() * self.integral + self.kd.value() * derivative
        self.last_error = error  # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –æ—à–∏–±–∫–∏
        self.setValue(int(self.output))

    def toggle_pid(self):
        self.pid_enabled = not self.pid_enabled  # –ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ü–ò–î-—Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞
        self.last_error = 0.0  # –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞
        self.integral = 0.0  # –ò–Ω—Ç–µ–≥—Ä–∞–ª –æ—à–∏–±–∫–∏
        self.output = 0.0  # –í—ã—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ

        if self.pid_enabled:
            self.timer = QTimer(self)  # –¢–∞–π–º–µ—Ä –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ü–ò–î-—Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞
            self.timer.timeout.connect(lambda: threading.Thread(target=self.update_pid()))
            self.timer.start(int(self.T.value()) * 1000)  # –ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ü–ò–î-—Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞ (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö)
        else:
            self.setValue(0)
            self.timer.stop()


class SquareWidget(QWidget):
    posChanged = pyqtSignal(tuple)
    color_changed = pyqtSignal(QColor)

    def __init__(self, pa, index=0, fill=False, w=400, h=100, check=False, x=120, y=120):
        super().__init__(parent=pa)
        self.alive = True  # –ø—Ä–∏–∑–Ω–∞–∫, —á—Ç–æ –≤–∏–¥–∂–µ—Ç –µ—â—ë –∂–∏–≤
        self.square_width = w  # –Ω–∞—á–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç–∞
        self.square_height = h  # –Ω–∞—á–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –∫–≤–∞–¥—Ä–∞—Ç–∞
        self.setFocusPolicy(Qt.StrongFocus)  # —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–∫—É—Å –Ω–∞ –≤–∏–¥–∂–µ—Ç
        self.dragging = False
        self.offset = QPoint()
        self.check = check
        self.index = index
        self.label = QLabel(self)
        self.label.setText(f'{self.pos().x(), self.pos().y()},{self.index + 1}')
        self.label.resize(200, 20)  # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –º–µ—Ç–∫–∏ (—à–∏—Ä–∏–Ω–∞, –≤—ã—Å–æ—Ç–∞)
        self.label.setFont(QFont('Arial', 15))
        self.label.move(self.width() // 4, self.height() // 2)
        self.label.hide()
        self.fill = fill
        self.x = (self.parent().width()) // 2
        self.y = (self.parent().height()) // 2
        self.setGeometry(self.x, self.y, 220, 50)
        self.move(50, self.parent().size().height() - 300)
        self.labl_vision = False
        self.color = 'yeallow'

    def labl_vision_def(self):
        self.label.show() if self.labl_vision else self.label.hide()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and self.check:
            self.dragging = True
            self.offset = event.pos()

    def mouseDoubleClickEvent(self, event):
        if self.check:
            self.fill = not self.fill

    def mouseMoveEvent(self, event):
        if self.dragging and self.check:
            self.move(self.pos() + event.pos() - self.offset)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.check:
            self.dragging = False

            if self.check:
                # self.label.setText(f'{self.pos().x(), self.pos().y()},{self.index + 1}')
                self.label.show()
                pos_tuple = (self.pos().x(), self.pos().y())
                self.posChanged.emit(pos_tuple)  # –í—ã–∑—ã–≤–∞–µ–º —Å–∏–≥–Ω–∞–ª —Å –ø–µ—Ä–µ–¥–∞—á–µ–π –∑–Ω–∞—á–µ–Ω–∏—è pos_tuple

    def keyPressEvent(self, event):
        step = 5
        if not self.check:
            return
        if event.key() == Qt.Key_Left:
            self.square_width = max(self.square_width - step, 1)
        elif event.key() == Qt.Key_Right:
            self.square_width += step
        elif event.key() == Qt.Key_Up:
            self.square_height += step
        elif event.key() == Qt.Key_Down:
            self.square_height = max(self.square_height - step, 1)
        else:
            return
        self.updateGeometry()

    def updateGeometry(self):
        parent_rect = self.parent().rect()
        new_width = min(self.square_width, parent_rect.width())
        new_height = min(self.square_height, parent_rect.height())
        self.setGeometry(
            self.pos().x(),
            self.pos().y(),
            new_width,
            new_height,
        )
        self.label.resize(
            new_width,
            new_height)

    def set_color(self, color):
        self.color = color
        self.color_changed.emit(QColor(color))  # —Å–∏–≥–Ω–∞–ª –¥–ª—è Set_point
        self.update()  # –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)  # —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
        pen = painter.pen()

        if not self.fill:
            painter.setBrush(Qt.NoBrush)  # –ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –∑–∞–ª–∏–≤–∫–∞
        else:
            painter.setBrush(Qt.black)
        if self.color == 'green':
            pen.setColor(QColor(0, 161, 31))
            pen.setWidth(10)  # —É–≤–µ–ª–∏—á–∏—Ç—å —Ç–æ–ª—â–∏–Ω—É —Ä–∞–º–∫–∏ –Ω–∞ 5
        elif self.color == 'red':
            pen.setColor(Qt.red)
            pen.setWidth(10)  # —É–≤–µ–ª–∏—á–∏—Ç—å —Ç–æ–ª—â–∏–Ω—É —Ä–∞–º–∫–∏ –Ω–∞ 5
        else:
            pen.setColor(QColor(244, 169, 0))
            pen.setWidth(10)  # —É–≤–µ–ª–∏—á–∏—Ç—å —Ç–æ–ª—â–∏–Ω—É —Ä–∞–º–∫–∏ –Ω–∞ 2
            pen.setStyle(Qt.DashLine)  # –¥–æ–±–∞–≤–∏—Ç—å –ø—É–Ω–∫—Ç–∏—Ä–Ω—ã–π —Å—Ç–∏–ª—å

        painter.setPen(pen)
        x = 0
        y = 0
        width = self.width()
        height = self.height()
        painter.drawRect(x, y, width, height)


class Set_point(QWidget):
    sensor_data = None
    name_formuls = []
    formuls = []

    def __init__(self, pa, index):
        super().__init__(parent=pa)
        self.alive = True
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.setWindowTitle("Sensor Configuration")
        self.setFont(QFont('Arial', 14))
        self.index = index
        layout = QGridLayout(self)
        layout.setVerticalSpacing(1)  # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ç—Å—Ç—É–ø –º–µ–∂–¥—É —Ä—è–¥–∞–º–∏ —Ä–∞–≤–Ω—ã–º 5 –ø–∏–∫—Å–µ–ª–µ–π
        self.sensorlist = pa.sensor_list
        self.formulslist = pa.formuls
        self.description_input = QLineEdit()
        self.description_input.setPlaceholderText("–û–ø–∏—Å–∞–Ω–∏–µ")
        self.description_input.setMinimumSize(85, 17)
        layout.addWidget(self.description_input, 0, 0, 1, 2)  # row 0, column 0

        self.sensor_input = QComboBox()
        self.sensor_input.addItems([i.name for i in self.sensorlist])
        self.sensor_input.addItems([i.name for i in self.formulslist])
        self.sensor_input.setPlaceholderText("–î–∞—Ç—á–∏–∫")
        layout.addWidget(self.sensor_input, 0, 2)  # row 0, column 1

        self.setpoint_input = QDoubleSpinBox()
        self.setpoint_input.setDecimals(3)
        self.setpoint_input.setSingleStep(0.1)
        self.setpoint_input.setMinimum(-999)
        self.setpoint_input.setMaximum(999)
        self.setpoint_input.setSuffix("–£")
        layout.addWidget(self.setpoint_input, 0, 3)  # row 0, column 3, span 1 row and 2 columns
        self.tolerance_input = QDoubleSpinBox()
        self.tolerance_input.setSingleStep(0.1)  # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —à–∞–≥ —Ä–∞–≤–Ω—ã–º 0.1

        self.tolerance_input.setSuffix("–î")
        self.tolerance_input.setDecimals(3)
        layout.addWidget(self.tolerance_input, 0, 4)  # row 0, column 4
        self.toggle_square = QCheckBox("–ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞–º–∫–∏")
        self.toggle_square.setChecked(False)
        self.toggle_square.stateChanged.connect(self.toggle_square_visibility)
        layout.addWidget(self.toggle_square, 0, 6)
        self.checkbox = QCheckBox('–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞–º–∫–∏')
        layout.addWidget(self.checkbox, 0, 5)  # row 0, column 5
        self.square_widget = SquareWidget(pa, index=self.index)  # –Ω–∞ dlgMain
        self.square_widget.color_changed.connect(self.update_border)
        self.square_widget.show()
        self.square_widget.mouseDoubleClickEvent = self.square_widget_double_click
        self.description_input.textChanged.connect(self.description_input_changed)
        self.setLayout(layout)
        self.checkbox.stateChanged.connect(self.checkbox_state_changed)
        self.move(10, self.parent().size().height() - 300)
        self.load_settings()  # Load the saved settings
        self.data_condition_changed()
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(2)

    # self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
    # self.setMinimumSize(0, 0)

    # for w in self.findChildren(QWidget):
    #     w.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
    #     w.setMinimumSize(0, 0)

    def toggle_square_visibility(self, state):
        if hasattr(self, "square_widget") and self.square_widget:
            self.square_widget.setVisible(state == Qt.Checked)

    def update_border(self, color=None):
        if color is None:
            color = QColor("gray")

        # –ø–æ–ª—É—á–∏—Ç—å —Ü–≤–µ—Ç —Ä–∞–º–∫–∏ –∏ –æ—Å–≤–µ—Ç–ª—ë–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é –¥–ª—è —Ñ–æ–Ω–∞
        border_color = color.name()
        background_color = color.lighter(160).name()  # 160% —Å–≤–µ—Ç–ª–µ–µ

        self.setStyleSheet(f"""
        
                border: 2px solid {border_color};
                border-radius: 6px;
                background-color: {background_color};
                padding: 6px;
           
        """)

    def scaletext(self, value):
        try:
            value = int(value)
        except ValueError:
            value = 0

        value = max(-30, min(value, 70))  # —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω

        font_size = max(6, 12 + value)  # –Ω–µ –¥–∞—ë–º —à—Ä–∏—Ñ—Ç—É —É–π—Ç–∏ –≤ 0
        font = QFont('Arial', font_size)

        for widget in self.findChildren(QWidget):
            widget.setFont(font)

        self.setMinimumHeight(40 + value * 2)
        self.setStyleSheet(f"font-size: {font_size}px;")  # –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π

    def description_input_changed(self):
        self.square_widget.label.setText(f'{self.description_input.text()}')

    def square_widget_double_click(self, event):
        self.hide() if self.isVisible() else self.show()

    def load_settings(self):
        try:
            settings = QSettings("Teplo", f"{config["IZDELIE"]}_SensorSettings_{self.index}")  # Use a unique identifier for each instance
            description = settings.value("description")
            sensor = settings.value("sensor")
            setpoint = settings.value("setpoint")
            tolerance = settings.value("tolerance")
            position = settings.value("square_widget_position", self.square_widget.pos())
            size = settings.value("size")  # Get the size as a QSize object

            self.description_input.setText(description)
            self.sensor_input.setCurrentText(sensor)
            self.setpoint_input.setValue(float(setpoint))
            self.tolerance_input.setValue(float(tolerance))
            self.move(position)
            self.square_widget.move(position)  # Move the square widget to the loaded position
            if size is not None:
                width, height = size.width(), size.height()
            else:
                default_size = QSize(220, 50)  # Set default size
                width, height = default_size.width(), default_size.height()
            self.square_widget.resize(width, height)
        except:
            pass

    def save_settings(self):
        settings = QSettings("Teplo", f"{config["IZDELIE"]}_SensorSettings_{self.index}")  # Use a unique identifier for each instance
        description = self.description_input.text()
        sensor = self.sensor_input.currentText()
        setpoint = self.setpoint_input.value()
        tolerance = self.tolerance_input.value()
        position = self.square_widget.pos()
        size = self.square_widget.size()

        settings.setValue("square_widget_position", position)
        settings.setValue("description", description)
        settings.setValue("sensor", sensor)
        settings.setValue("setpoint", setpoint)
        settings.setValue("tolerance", tolerance)
        settings.setValue("size", size)

    def checkbox_state_changed(self, state):
        setattr(self.square_widget, 'check', state)
        setattr(self.square_widget, 'labl_vision', state)
        self.square_widget.labl_vision_def()
        self.save_settings()

    def data_condition_changed(self):
        def check_condition():
            while True:
                # ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥ –≤—Å–µ–º–∏ –¥–µ–π—Å—Ç–≤–∏—è–º–∏
                if not getattr(self, 'alive', True):
                    return
                if not hasattr(self, "sensor_input") or not self.sensor_input:
                    return
                if not hasattr(self, "square_widget") or not self.square_widget or not getattr(self.square_widget,
                                                                                               'alive', True):
                    return
                try:
                    sensor_name = self.sensor_input.currentText()
                    sens = next((s for s in self.sensorlist if s.name == sensor_name), None)

                    if sens is None:
                        sens = next((f for f in self.formulslist if f.name == sensor_name), None)
                        index = self.formulslist.index(sens)
                        sens_data = Set_point.formuls[index]
                    else:
                        key = (sens.reg, sens.ch)
                        sens_data = Set_point.sensor_data.get(key, float('nan'))

                    setpoint_input = self.setpoint_input.value()
                    tolerance_input = self.tolerance_input.value()

                    lower = setpoint_input - tolerance_input
                    upper = setpoint_input + tolerance_input

                    if lower <= sens_data <= upper:
                        color = 'green'
                    elif sens_data > upper:
                        color = "red"
                    else:
                        color = "yellow"
                    self.square_widget.set_color(color)
                    sens.update_sensor_bord.emit(sens.l2.styleSheet()[:-1] + "border: 6px solid " + color + ";}")

                except Exception:
                    # –ó–¥–µ—Å—å —Ç–æ–∂–µ –Ω—É–∂–Ω–∞ –∑–∞—â–∏—Ç–∞, —á—Ç–æ–±—ã self.square_widget –Ω–µ —É–ø–∞–ª
                    if hasattr(self, "square_widget") and self.square_widget and getattr(self.square_widget, 'alive',
                                                                                         True):
                        self.square_widget.set_color(False)
                time.sleep(1)

        thread = threading.Thread(target=check_condition)
        thread.daemon = True
        thread.start()


class Timers(QMainWindow):
    sensor_data = None
    name_formuls = []
    formuls = []

    def __init__(self, start_hour=0, start_minute=0, start_second=0, start_msecond=0):
        super().__init__()
        self.setWindowTitle("–¢–∞–π–º–µ—Ä")
        self.setWindowFlags(Qt.Window)

        self.end = QLabel()
        self.start = QLabel()
        self.setFont(QFont('Arial', 18))
        self.last = False
        self.condition = True
        settings = QSettings('Teplo', f"{config["IZDELIE"]}_timers")
        self.cond = False
        layh = QHBoxLayout()
        self.timers = QComboBox()
        layh.addWidget(self.timers)
        self.timers_settings_build(settings)
        self.timer_numbers = QLineEdit()

        self.input_number_cycles = QSpinBox()
        self.input_number_cycles.setFont(QFont('Arial', 14))
        self.input_number_cycles.setMaximum(1000000)
        self.input_number_cycles.setSuffix('  —á–∏—Å–ª–æ —Ü–∏–∫–ª–æ–≤')
        layh.addWidget(self.input_number_cycles)

        self.add_timer = QPushButton("–î–æ–±–∞–≤–∏—Ç—å —Ç–∞–π–º–µ—Ä")
        self.exp_timer = QPushButton("–≠–∫—Å–ø–æ—Ä—Ç —Ç–∞–π–º–µ—Ä–æ–≤")
        self.add_timer.clicked.connect(lambda: self.add_timer_combobox(settings))
        self.exp_timer.clicked.connect(lambda: self.export_registry_directory(r'HKEY_CURRENT_USER\SOFTWARE\Teplo\m7m',
                                                                              fr'{config["IZDELIE"]}\{config["IZDELIE"]}.reg'))

        self.delete_timer = QPushButton("–£–¥–∞–ª–∏—Ç—å —Ç–∞–π–º–µ—Ä")
        self.delete_timer.clicked.connect(lambda: self.del_timer_combobox(settings))
        self.action_timers = QComboBox()
        max_width = max(self.action_timers.view().sizeHintForColumn(0), self.action_timers.width())
        self.action_timers.setMinimumWidth(max_width)

        self.start_time = QLabel()
        self.end_time = QLabel()
        self.timers_cb_b = QPushButton("–î–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ", self)
        self.htimebox = QHBoxLayout()
        self.time_input = QTimeEdit()
        self.time_input.setFont(QFont('Arial', 15))
        self.time_input.setDisplayFormat("HH:mm:ss.zzz")
        self.time_input.setTime(QTime(start_hour, start_minute, start_second, start_msecond))
        self.trlist = dlgMain.translate_list
        self.dmplist = dlgMain.dampers_list
        self.furanceslist = dlgMain.furnace_list
        self.sensorlist = dlgMain.sensor_list
        self.math = Timers.name_formuls
        self.layoutH = QHBoxLayout()

        self.action_cb_list = QComboBox()
        self.action_cb_list.addItem('–æ–∂–∏–¥–∞–Ω–∏–µ')
        self.action_cb_list.addItems([tr.name for tr in self.trlist])
        self.action_cb_list.addItems([dmp.name for dmp in self.dmplist])
        self.action_cb_list.addItems([str(fur) for fur in self.furanceslist])
        self.action_cb_list.addItems([sen.name for sen in self.sensorlist])
        self.action_cb_list.addItems([m for m in self.math])

        self.action_cb_list.currentIndexChanged.connect(self.reset_values)

        self.inptust = QDoubleSpinBox()
        self.inptust.setSuffix('  —É—Å—Ç')
        self.inptust.setFont(QFont('Arial', 15))

        self.inptdop = QDoubleSpinBox()
        self.inptdop.setSuffix('  –¥–æ–ø')

        self.inptdop.setFont(QFont('Arial', 15))

        self.inptdop.setMaximum(999)
        self.inptust.setMaximum(999)
        self.inptdop.setDecimals(4)
        self.inptust.setDecimals(4)
        self.name_sen = QLineEdit()
        self.name_sen.setPlaceholderText('–∏–Ω–ø—É—Ç')
        self.info_input = QLineEdit()
        self.info_input.setPlaceholderText('–∫–æ–º–µ–Ω—Ç–∞—Ä–∏–π')
        self.question_button = QPushButton()
        self.question_button.setText('?')
        self.question_button.setFont(QFont('Arial', 12))
        self.question_button.setToolTip(
            "–ü–æ–ª–µ '–∑–∞–¥–µ—Ä–∂–∫–∞' —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–æ–≤—Å–µ–º–∏ —Å–æ–±—ã—Ç–∏—è–º–∏\n–î–ª—è '–æ–±—ä–µ–∫—Ç–∞' '–æ–∂–∏–¥–∞–Ω–∏—è' —É–∫–∞–∑–∞—Ç—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ –ø–æ–ª–µ '–∑–∞–¥–µ—Ä–∂–∫–∏'\n–î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –¥–∞—Ç—á–∏–∫–∞ –≤—ã–±—Ä–∞—Ç—å '–æ–±—ä–µ–∫—Ç' –¥–∞—Ç—á–∏–∫(DA1)—É–∫–∞–∑–∞—Ç—å —É—Å—Ç–∞–≤–∫—É –∏ –¥–æ–ø—É—Å–∫ ,–∞ —Ç–∞–∫–∂–µ —Å–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ '–æ–∂–∏–¥–∞–Ω–∏–µ' –ø–µ—Ä–µ–¥ —Å–æ–±—ã—Ç–∏–µ–º –¥–∞—Ç—á–∏–∫–∞\n–î–ª—è —Ä–∞–±–æ—Ç—ã –∞–≤—Ç–æ–º–∞—Ç–∞ –∑–∞—Å–ª–æ–Ω–∫–∏ –≤—ã–±—Ä–∞—Ç—å '–æ–±—ä–µ–∫—Ç' –∑–∞—Å–ª–æ–Ω–∫—É(RU1) —É–∫–∞–∑–∞—Ç—å —É—Å—Ç–∞–≤–∫—É,–¥–æ–ø—É—Å–∫ –∏ –¥–∞—Ç—á–∏–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤–≤–µ—Å—Ç–∏ –≤ –ø–æ–ª–µ –∏–Ω–ø—É—Ç: DA1\n–î–ª—è —Ä–∞–±–æ—Ç—ã –∞–≤—Ç–æ–º–∞—Ç–∞ –ø–µ—á–∏ –≤—ã–±—Ä–∞—Ç—å '–æ–±—ä–µ–∫—Ç' –ø–µ—á—å(F1) –Ω–µ–æ—Ö–æ–¥–∏–º–∞ —É–∫–∞–∑–∞—Ç—å —É—Å—Ç–∞–≤–∫—É –∏ –¥–∞—Ç—á–∏–∫–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤–≤–µ—Å—Ç–∏ –≤ –ø–æ–ª–µ –∏–Ω–ø—É—Ç: DT1-DA1\n–î–ª—è –ø–æ–¥–∞—á–∏ —Å–∏–≥–Ω–∞–ª–∞ –Ω–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –ª–∏–±–æ –∑–∞–∫—Ä—ã—Ç–∏—è –≤—ã–±—Ä–∞—Ç—å '–æ–±—ä–µ–∫—Ç' –∑–∞—Å–ª–æ–Ω–∫—É(RU1) –≤ –ø–æ–ª–µ —É—Å—Ç–∞–≤–∫–∏ —É–∫–∞–∑–∞—Ç—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (10 —É—Å—Ç) –≤–≤–µ—Å—Ç–∏ –≤ –ø–æ–ª–µ –∏–Ω–ø—É—Ç : –æ—Ç–∫—Ä—ã—Ç—å/–∑–∞–∫—Ä—ã—Ç—å\n–î–ª—è –≤–ª–∫—é—á–µ–Ω–∏—è/–≤—ã–∫–ª—é—á–µ–Ω–∏—è –∞–≤—Ç–æ–º–∞—Ç–∞ –∑–∞—Å–ª–æ–Ω–∫–∏/–ø–µ—á–∏ –≤—ã–±—Ä–∞—Ç—å '–æ–±—ä–µ–∫—Ç' –¥–ª—è –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏(RU1/F1) –≤–≤–µ—Å—Ç–∏ –≤ –ø–æ–ª–µ –∏–Ω–ø—É—Ç: –≤–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å\n–î–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è —Ç–æ–ª—å–∫–æ 1 —Ä–∞–∑(–ø–µ—Ä–≤–æ–º –∫—Ä—É–≥–µ) –≤–≤–µ—Å—Ç–∏ –≤ –ø–æ–ª–µ –∏–Ω–ø—É—Ç –¥–æ–±–∞–≤–∏—Ç—å *: DA1* (–¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è: *) ")
        self.question_button.setToolTipDuration(30000)
        self.question_button.setStyleSheet('QToolTip { font: bold 18px Arial; color:black;}')
        self.lablobj = QLabel('–û–±—ä–µ–∫—Ç')
        self.layoutH.addWidget(self.lablobj, 1)
        self.layoutH.addWidget(self.action_cb_list, 1)
        self.layoutH.addWidget(self.inptust, 1)
        self.layoutH.addWidget(self.inptdop, 1)
        self.layoutH.addWidget(self.name_sen, 2)
        self.layoutH.addWidget(self.question_button)
        """    self.button = QCheckBox()
        self.button.stateChanged.connect(self.toggle_pid)
        self.pid_enabled = False

        self.setpoint_value = QDoubleSpinBox()"""
        self.timers_cb_del = QPushButton('–£–¥–∞–ª–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ')

        self.timers_start_timer = QPushButton('–°—Ç–∞—Ä—Ç_–õ–æ–≥–∏–∫–∏')
        self.timers_start_timer.setStyleSheet("""
            QPushButton {
                background-color: green;
                color: white; 
                font-family: Arial;
                font-size: 18px;
            }
            QPushButton:pressed {
                background-color: darkgreen;
            }
        """)

        self.timers_start_timer.clicked.connect(lambda: self.start_timer(settings))

        self.continuous_checkbox = QCheckBox('–ø–µ—Ä–≤—ã–π –∫—Ä—É–≥')
        self.continuous_checkbox.setFont(QFont('Arial', 14))
        self.last_cycle = QCheckBox('–∑–∞–≤–µ—Ä—à–∞—é—â–∏–π —Ü–∏–∫–ª')
        self.last_cycle.setFont(QFont('Arial', 14))
        self.last_cycle.stateChanged.connect(
            lambda state: setattr(self, 'last', True if state == Qt.Checked else False))
        self.reform_action_timers(settings)
        self.timer_stop = QPushButton('–°—Ç–æ–ø')
        self.timer_stop.setStyleSheet("""
            QPushButton {
                background-color: red;
                color: white;  /* –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –∫–Ω–æ–ø–∫–∏ */
                font-family: Arial;
                font-size: 18px;
            }
            QPushButton:pressed {
                background-color: darkred;
            }
        """)

        self.alarm_stop = QPushButton('–∞–≤–∞—Ä–∏–π–Ω—ã–π')
        self.alarm_stop.setStyleSheet("""
                    QPushButton {
                        background-color: red;
                        color: white;  /* –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –∫–Ω–æ–ø–∫–∏ */
                        font-family: Arial;
                        font-size: 18px;
                    }
                    QPushButton:pressed {
                        background-color: darkred;
                    }
                """)
        self.alarm_stop.clicked.connect(self.alarm_stop_def)
        self.lb_cycle = QLabel('–¶–∏–∫–ª–æ–≤: 0')
        self.timers.currentIndexChanged.connect(
            lambda: self.lb_cycle.setText(settings.value(f'cycle_{self.timers.currentText()}')))
        # –°–æ–∑–¥–∞—ë–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –≤–∏–¥–∂–µ—Ç –¥–ª—è QMainWindow
        central = QWidget()
        self.setCentralWidget(central)

        # Layout –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
        vbox = QVBoxLayout(central)

        vbox.addLayout(layh)

        hbox0 = QHBoxLayout()
        hbox0.addWidget(self.add_timer)
        hbox0.addWidget(self.exp_timer)
        hbox0.addWidget(self.delete_timer)
        vbox.addLayout(hbox0)

        self.htimebox.addWidget(self.time_input)
        self.htimebox.addWidget(QLabel('    –ó–∞–¥–µ—Ä–∂–∫–∞'))
        vbox.addLayout(self.htimebox)

        vbox.addLayout(self.layoutH)
        vbox.addWidget(self.info_input)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(self.timers_cb_b)
        hbox1.addWidget(self.timers_cb_del)
        vbox.addLayout(hbox1)

        hbox2 = QHBoxLayout()
        hbox2.addWidget(self.continuous_checkbox)
        hbox2.addWidget(self.last_cycle)
        vbox.addWidget(self.action_timers)
        vbox.addLayout(hbox2)

        self.reset_button = QPushButton('–°–±—Ä–æ—Å_—Ü–∏–∫–ª–æ–≤')
        self.reset_button.clicked.connect(lambda: self.reset_cycle(settings=settings))

        hbox3 = QHBoxLayout()
        hbox3.addWidget(self.timers_start_timer)
        hbox3.addWidget(self.reset_button)
        hbox3.addWidget(self.timer_stop)
        hbox3.addWidget(self.alarm_stop)
        vbox.addLayout(hbox3)

        self.info = QLabel()
        # vbox.addWidget(self.info)  # –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å

        hbox4 = QHBoxLayout()
        hbox4.addWidget(self.start_time)
        hbox4.addWidget(QLabel(' - '))
        hbox4.addWidget(self.end_time)
        hbox4.addWidget(self.lb_cycle, 2)
        vbox.addLayout(hbox4)

        hbox5 = QHBoxLayout()
        hbox5.addWidget(self.start)
        hbox5.addWidget(QLabel(' - '))
        hbox5.addWidget(self.end)
        vbox.addLayout(hbox5)

        # –û—Å—Ç–∞–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
        self.timers_cb_del.clicked.connect(lambda: self.del_action(settings=settings))
        self.timers_cb_b.clicked.connect(
            lambda: self.add_action_to_combo_box(settings=settings, count=self.action_timers.count()))
        self.iteration_count = 0
        self.setMouseTracking(True)
        self.dragging = False
        self.offset = None

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.dragging = True
            self.offset = event.pos()

    def mouseMoveEvent(self, event):
        if self.dragging:
            new_pos = self.mapToParent(event.pos() - self.offset)
            self.move(new_pos)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.dragging = False
            self.offset = None
            self.setCursor(Qt.ArrowCursor)  # ‚Üê –≤–µ—Ä–Ω—É—Ç—å –∫—É—Ä—Å–æ—Ä –æ–±—Ä–∞—Ç–Ω–æ

    def mouseDoubleClickEvent(self, event):
        self.hide()

    def export_registry_directory(self, key_path, output_file):
        subprocess.run(['reg', 'export', key_path, output_file, '/y'], check=True)

    def alarm_stop_def(self):
        self.timer_stop.click()
        self.iteration_count = 0
        self.timers.setCurrentIndex(self.timers.count() - 1)
        self.action_timers.setCurrentIndex(0)
        self.timers_start_timer.click()

    def reset_cycle(self, settings):
        cycle = settings.value(f'cycle_{self.timers.currentText()}')
        cycle = '0_' + cycle.split('_')[1]
        self.lb_cycle.setText(cycle)
        settings.setValue(f'cycle_{self.timers.currentText()}', cycle)

    def reset_values(self):
        self.inptust.setValue(0.0)
        self.inptdop.setValue(0.0)
        self.name_sen.setText('')
        self.info_input.setText('')
        self.time_input.setTime(QTime(0, 0, 0))

    def timers_settings_build(self, settings):
        self.timers.clear()
        self.timer_settings = [setting for setting in settings.allKeys() if
                               'timer' in setting.lower() and 'cycle_' not in setting.lower()]
        self.timers.addItems(self.timer_settings)
        self.timers.currentIndexChanged.connect(lambda: self.reform_action_timers(settings))

    #   self.input_number_cycles.setValue()

    def add_timer_combobox(self, settings):
        if self.timers.currentIndex() < self.timers.count() - 1 or len(self.timers.currentText()) > 7:
            name = self.timers.currentText()[:7]
            counter = 0
            while settings.contains(name):
                name = name[:7]
                name = f'{name}_{counter}'
                counter += 1
        else:
            try:
                name = f'timer_' + str(int(self.timers.currentText().split('_')[1]) + 1)
            except IndexError:
                name = 'timer_0'
        self.timers.insertItem(self.timers.currentIndex() + 1, name)
        settings.setValue(name, [])
        self.timers_settings_build(settings)
        if not settings.contains(f'cycle_{name}'):
            cycle = '0_' + str(self.input_number_cycles.value())
            settings.setValue(f'cycle_{name}', cycle)

    def del_timer_combobox(self, settings):
        name = self.timers.currentText()
        [settings.remove(key) for key in settings.allKeys() if name in key]
        self.timers.removeItem(self.timers.currentIndex())
        self.timers_settings_build(settings)

    def reform_action_timers(self, settings):
        self.action_timers.clear()
        action_timers = settings.value(self.timers.currentText())
        if action_timers is not None:
            self.action_timers.addItems(action_timers)

    def add_action_to_combo_box(self, settings, count):
        action_list = []
        if self.info_input.text() != '':
            timer_str = f't{count}_{self.time_input.text()}_{self.action_cb_list.currentText()}_{"" if self.inptust.value() == 0 else self.inptust.value()}_{"" if self.inptdop.value() == 0 else self.inptdop.value()}_{self.name_sen.text()}!{self.info_input.text()}'
        else:
            timer_str = f't{count}_{self.time_input.text()}_{self.action_cb_list.currentText()}_{"" if self.inptust.value() == 0 else self.inptust.value()}_{"" if self.inptdop.value() == 0 else self.inptdop.value()}_{self.name_sen.text()}'
        self.action_timers.insertItem(self.action_timers.currentIndex() + 1, timer_str)
        for index in range(self.action_timers.count()):
            action_list.append(self.action_timers.itemText(index))
        settings.setValue(self.timers.currentText(), action_list)

    def del_action(self, settings):
        action_list = []
        current_index = self.action_timers.currentIndex()
        self.action_timers.removeItem(current_index)
        for index in range(self.action_timers.count()):
            action_list.append(self.action_timers.itemText(index))
        settings.setValue(self.timers.currentText(), action_list)

    def hide_timer_settings(self):
        self.add_timer.hide()
        self.info_input.hide()
        self.exp_timer.hide()
        self.question_button.hide()
        self.lablobj.hide()
        self.delete_timer.hide()
        for i in range(self.htimebox.count()):
            widget = self.htimebox.itemAt(i).widget()
            if widget:
                widget.hide()
        self.action_cb_list.hide()
        #  self.action_timers.hide()
        self.timers_cb_b.hide()
        self.timers_cb_del.hide()
        self.inptust.hide()
        self.inptdop.hide()
        self.name_sen.hide()
        self.input_number_cycles.hide()
        self.continuous_checkbox.hide()
        self.timers.hide()
        self.reset_button.hide()

    def resize_setting_widget(self, width, height):

        setting_widget = self.parent().parent().parent().parent()
        if isinstance(setting_widget, Setting):
            setting_widget.resize(width, height)
            setting_widget.btnreboot.hide()

    def start_timer(self, settings):
        with threading.Lock():
            self.initialize_timer_info()
            cycle = self.get_cycle(settings)
            self.lb_cycle.setText(f'  {cycle}')

            current_time = QDateTime.currentDateTime()
            self.start_time.setText(current_time.toString("hh:mm:ss.z"))

            try:
                tname, ttime, tbutton, tust, tdop, tname_sen = self.action_timers.currentText().split('_')
            except ValueError:
                self.handle_timer_value_error()
                return

            total_seconds = self.calculate_total_seconds(ttime)

            self.end_time.setText(current_time.addMSecs(total_seconds).toString("hh:mm:ss.z"))

            self.setup_timer(tbutton, settings, tust, tdop, tname_sen, total_seconds)

    def initialize_timer_info(self):
        if not hasattr(self, 'first_loop'):
            self.start.setText(QDateTime.currentDateTime().toString("hh:mm:ss"))
            self.first_loop = True
            self.hide_timer_settings()

    def get_cycle(self, settings):
        return settings.value(f'cycle_{self.timers.currentText()}', '0_1')

    def handle_timer_value_error(self):
        self.timer_stop.click()
        self.timers.setCurrentIndex(0)
        self.action_timers.setCurrentIndex(0)

    def calculate_total_seconds(self, ttime):
        hours, minutes, seconds_with_fraction = map(float, ttime.split(':'))
        return int((hours * 3600 + minutes * 60 + seconds_with_fraction) * 1000)

    def setup_timer(self, tbutton, settings, tust, tdop, tname_sen, total_seconds):
        self.timer = QTimer()
        self.timer_stop.clicked.connect(lambda: self.timer_action_stop(settings))
        self.timer.setInterval(total_seconds)
        self.timer.timeout.connect(
            lambda: self.timer_action(tbutton, self.iteration_count, settings, tust, tdop, tname_sen))
        self.timer.start()

    def timer_action_stop(self, settings):
        self.end.setText(QDateTime.currentDateTime().toString("hh:mm:ss"))
        self.last = False
        self.last_cycle.setChecked(False)
        if self.continuous_checkbox.isChecked():
            self.first_loop = True
        self.continuous_checkbox.setChecked(False)
        #       self.resize_setting_widget(600,400)
        if hasattr(self, 'first_run'):
            del self.first_run
        self.timer.stop()
        self.start_time.setText('')
        self.end_time.setText('')
        self.info.setText('')
        try:
            if isinstance(self.parent().parent().parent().parent(), Setting):
                self.add_timer.show()
                self.exp_timer.show()
                self.delete_timer.show()
                for i in range(self.htimebox.count()):
                    widget = self.htimebox.itemAt(i).widget()
                    if widget:
                        widget.hide()
                self.action_cb_list.show()
                self.timers_cb_b.show()
                self.timers_cb_del.show()
                self.inptust.show()
                self.inptdop.show()
                self.name_sen.show()
                self.input_number_cycles.show()
                self.continuous_checkbox.show()
                self.timers.show()
                self.reset_button.show()
        except Exception:
            pass
        self.timers.setCurrentIndex(0)

    #   settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')

    def timer_action(self, button, iteration_count, settings, ust, dop, name_sens):
        with threading.Lock():
            if name_sens != '':
                try:
                    self.info.setText(name_sens.split('!')[1])
                except IndexError:
                    self.info.setText(name_sens)
            self.timer.stop()
            cycle_str = self.lb_cycle.text()
            cycle_parts = cycle_str.split('_')
            if int(cycle_parts[0]) != int(cycle_parts[1]):
                if self.first_loop or '*' not in name_sens:
                    tr_dict = {tr.name: tr for tr in self.trlist}
                    dmp_dict = {dm.name: dm for dm in self.dmplist}
                    furn_dict = {fr.name: fr for fr in self.furanceslist}
                    sens_dict = {sn.name: sn for sn in self.sensorlist}
                    math_dict = dict(zip(self.name_formuls, self.formuls))
                    objects = [tr_dict.get(button), dmp_dict.get(button), furn_dict.get(button), sens_dict.get(button),
                               math_dict.get(button)]
                    result = next((obj for obj in objects if obj is not None), None)
                    ust = float(ust) if ust != '' else None
                    dop = float(dop) if dop != '' else None
                    if result is not None:
                        case = {
                            Formula: lambda: self.process_math_case(result, ust, dop, name_sens),
                            Sensor: lambda: self.process_sens_case(result, ust, dop, name_sens),
                            Damper: lambda: self.process_dmpb_case(result, name_sens, ust, dop),
                            Translate: lambda: self.process_trb_case(result, name_sens),
                            Furnace: lambda: self.process_furn_case(result, name_sens, ust),
                        }
                        if type(result) in case:
                            case[type(result)]()
                self.action_timers.setCurrentIndex((self.action_timers.currentIndex() + 1) % self.action_timers.count())
                print(self.action_timers.currentText())
                if self.cond:
                    self.iteration_count -= 1
                elif iteration_count < len(self.action_timers) - 1:
                    self.iteration_count += 1
                else:
                    cycle_parts[0] = str(int(cycle_parts[0]) + 1)
                    result_str = '_'.join(cycle_parts)
                    self.lb_cycle.setText(result_str)
                    settings.setValue(f'cycle_{self.timers.currentText()}', result_str)
                    self.iteration_count = 0
                    self.first_loop = True if self.continuous_checkbox.isChecked() else False
                    self.continuous_checkbox.setChecked(False)
                    if self.last:
                        self.timers.setCurrentIndex(self.timers.count() - 1)
                        self.lb_cycle.setText('0_1')
            else:
                if self.timers.currentIndex() == 0:
                    settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')
                if self.timers.currentIndex() == self.timers.count() - 1:
                    settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')

                self.timers.setCurrentIndex((self.timers.currentIndex() + 1))
                self.first_loop = True
            self.cond = False
            self.start_timer(settings)

    def process_math_case(self, math, ust, dop, name_sens):
        index = self.formuls.index(math)
        math_data = Timers.formuls[index]
        if math_data < ust - dop or ust + dop < math_data:
            self.action_timers.setCurrentIndex(self.action_timers.currentIndex() - 2)
            self.cond = True

    def process_sens_case(self, sens, ust, dop, name_sens):
        sens_data = Set_point.sensor_data.get((sens.reg, sens.ch), float('nan'))
        if sens_data < ust - dop or ust + dop < sens_data:
            self.action_timers.setCurrentIndex(self.action_timers.currentIndex() - 2)
            self.cond = True

    def process_dmpb_case(self, dmpb, name_sens, ust, dop):
        print(dmpb)
        name_sens = name_sens.rstrip('*')
        if '–æ—Ç–∫—Ä' in name_sens.lower():
            dmpb.pressing('Open', ust)
        elif '–∑–∞–∫—Ä' in name_sens.lower():
            dmpb.pressing('Close', ust)
        elif '–≤—ã–∫–ª' in name_sens.lower():
            try:
                dmpb.chkbA.setChecked(False)
            except Exception:
                pass
        elif '–≤–∫–ª' in name_sens.lower():
            try:
                dmpb.chkbA.setChecked(True)
            except Exception:
                pass
        else:
            ust = 0 if ust is None else ust
            dop = 0 if dop is None else dop
            if not dmpb.chkb.isChecked():
                dmpb.chkb.setChecked(True)
            dmpb.valve_widget.comboA.setCurrentIndex(
                dmpb.valve_widget.comboA.findText(name_sens, flags=Qt.MatchContains))
            dmpb.valve_widget.ustA.setValue(ust)
            dmpb.valve_widget.dopskA.setValue(dop)
            dmpb.valve_widget.chkbA.setChecked(not dmpb.valve_widget.chkbA.isChecked())

    def process_trb_case(self, trb, name_sens):
        name_sens = name_sens.rstrip('*')

        if '—Å–±—Ä–æ—Å' in name_sens:
            trb.rearrangement_cond = False
        else:
            trb.click()

    def process_furn_case(self, furn, name_sens, ust):
        name_sens = name_sens.rstrip('*')

        if '–≤–∫–ª' in name_sens.lower():
            furn.button.setChecked(True)
        elif '–≤—ã–∫–ª' in name_sens.lower():
            furn.button.setChecked(False)
        else:
            furn.setpoint_value.setValue(ust)
            furn.on_activated('DT')
            furn.on_activated('DA')
            dt, da = name_sens.split('-')
            furn.sensordt.setCurrentIndex(furn.sensordt.findText(dt, flags=Qt.MatchContains))
            furn.sensordp.setCurrentIndex(furn.sensordp.findText(da, flags=Qt.MatchContains))
            furn.button.toggle()


class File_formatter:
    @classmethod
    def rw_lines(cls, suf: str, new_lines: list[str] = None):
        with open(config['setting'], suf) as file:
            match suf:
                case 'r':
                    return file.readlines()
                case 'w':
                    return file.writelines(new_lines)

    def extract_text_between_grids(self, start_grids_index, end_grids_index, sort_key_index):
        lines = self.rw_lines('r')

        grid_count = 0
        start_index = -1
        end_index = -1

        # Find start and end indices of the relevant section
        for i, line in enumerate(lines):
            if line.strip() == config['GRID']:
                grid_count += 1
                if grid_count == start_grids_index:
                    start_index = i + 1
                elif grid_count == end_grids_index:
                    end_index = i
                    break

        if start_index == -1 or end_index == -1:
            return  # Grids not found

        # Extract and sort the text between grids
        between_grids = [line for line in lines[start_index:end_index] if
                         line.strip() and line.strip() != config['GRID']]

        between_grids.sort(key=lambda x: int(x.split()[sort_key_index]))
        result = {}
        for line in between_grids:
            parts = line.strip().split()
            try:
                fifth_column = int(parts[sort_key_index])
                if fifth_column not in result:
                    result[fifth_column] = []
                result[fifth_column].append(line)
            except ValueError:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤ —á–∏—Å–ª–æ –≤ —Å—Ç—Ä–æ–∫–µ: {line}")

        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫ –≤–Ω—É—Ç—Ä–∏ –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –ø–æ –ø–µ—Ä–≤–æ–º—É —Å—Ç–æ–ª–±—Ü—É
        if start_grids_index == 2:
            between_grids = []
            for key, value in result.items():
                between_grids += sorted(value, key=lambda x: int(x.split()[1]))

        # Reconstruct the file
        new_lines = lines[:start_index - 1] + between_grids + lines[end_index:]
        new_lines.insert(start_index - 1, config['GRID'] + '\n')  # Re-insert the GRID line.
        self.rw_lines('w', new_lines)


class Setting(QWidget, File_formatter):
    CONFIRM = '–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å'
    _instance = None
    _initialized = False

    def __new__(cls, *args, **kwargs):

        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        self.cb_daq_mod_type = None
        if not self._initialized:
            super().__init__()
            self._initialized = True
            self.sensor_list = dlgMain.sensor_list
            self.dampers_list = dlgMain.dampers_list

            self.setMinimumSize(100, 100)
            self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

            self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
            self.setFont(QFont("Arial", 14))
            self.setWindowTitle('–ù–∞—Å—Ç—Ä–æ–π–∫–∏')
            self.setStyleSheet('''QPushButton {font-size: 14pt;background-color: #A3C1DA; border-radius: 8px;}
                              QPushButton:hover {background-color: #49B69F;}
                              QPushButton:pressed {background-color: #5549B6;}''')
            screen = QDesktopWidget().screenGeometry()
            width = screen.width()
            height = screen.height()
            self.checked_items = []

            self.central_widget = SquareWidget(dlgMain, check=True)
            self.central_widget.setGeometry(555, 555, 250, 50)
            self.central_widget.show()

            def handle_value_change(x, y):
                self.central_widget.move(int(x), int(y))

            window0 = QWidget()
            layout0 = QHBoxLayout(window0)
            timer1 = Timers()
            layout0.addWidget(timer1)

            self.btn_timer_open = QPushButton("–û—Ç–∫—Ä—ã—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º—ã")
            self.btn_timer_open.clicked.connect(self.open_timer_logic)
            layout0.addWidget(self.btn_timer_open)

            window = QWidget()
            layout1 = QGridLayout(window)

            self.cb_name = QComboBox(self)
            self.cb_name.setToolTip("–ò–º—è")
            self.cb_name.addItems(['DA', 'DD', 'dP', 'DT', 'G', '—Å–≤–æ—ë –∏–º—è'])
            self.cb_name.currentIndexChanged.connect(self.setname)
            self.cb_namenumber = QComboBox(self)
            self.cb_channel = QComboBox(self)
            self.cb_bit_depth = QComboBox(self)
            for i in range(1, 101):
                self.cb_namenumber.addItem(str(i))
                self.cb_channel.addItem(str(i))
                self.cb_bit_depth.addItem(str(i))
            self.cb_color = QComboBox(self)

            self.cb_color.addItems(config['COLORS'].keys())
            self.cb_color.addItem('–°–≤–æ–π —Ü–≤–µ—Ç')
            self.color_label = QLabel(self)
            self.color_label.setText('–¶–≤–µ—Ç')
            self.color_label.setGeometry(50, 100, 200, 50)
            self.color_label.setAutoFillBackground(True)
            self.color_label.setStyleSheet(f"background-color: #FF5733")
            self.cb_color.currentIndexChanged.connect(
                lambda: self.on_combo_box_change(config['COLORS'], self.cb_color, self.color_label))

            self.cb_name_side = QComboBox(self)
            self.cb_name_side.addItems(config['SIDE'].keys())
            self.cb_bit_depth.setCurrentIndex(2)

            self.cb_reg = QComboBox(self)
            for i in config['IPS']:
                self.cb_reg.addItem(i)

            self.cb_pos_x = QDoubleSpinBox(self)
            self.cb_pos_y = QDoubleSpinBox(self)
            self.cb_pos_x.setFont(QFont('Arial', 12))
            self.cb_pos_y.setFont(QFont('Arial', 12))

            self.cb_pos_x.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y.lineEdit().setAlignment(Qt.AlignCenter)
            self.deepxy(width, height, self.cb_pos_x, self.cb_pos_y)
            self.cb_pos_x.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x.value(), self.cb_pos_y.value()))
            self.cb_pos_y.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x.value(), self.cb_pos_y.value()))
            self.central_widget.posChanged.connect(self.handlePosChanged)

            layout1.addWidget(QLabel('–ò–º—è'), 0, 0)
            layouth1_1 = QHBoxLayout()
            layouth1_1.addWidget(self.cb_name)
            layouth1_1.addWidget(self.cb_namenumber)
            layout1.addLayout(layouth1_1, 0, 1)

            layout1.addWidget(QLabel('–ö–∞–Ω–∞–ª'), 1, 0)
            layout1.addWidget(self.cb_channel, 1, 1)
            layout1.addWidget(self.color_label)
            layout1.addWidget(self.cb_color)
            layout1.addWidget(QLabel('–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏–º–µ–Ω–∏'))
            layout1.addWidget(self.cb_name_side)
            layout1.addWidget(QLabel('–†–∞–∑—Ä—è–¥–Ω–æ—Å—Ç—å'))
            layout1.addWidget(self.cb_bit_depth)
            layout1.addWidget(QLabel('–†–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä'), 5, 0)
            layout1.addWidget(self.cb_reg, 5, 1)
            layout1.addWidget(QLabel('–ü–æ–∑–∏—Ü–∏—è –ø–æ X –∏ Y'))
            layouth1_2 = QHBoxLayout()
            layouth1_2.addWidget(self.cb_pos_x)
            layouth1_2.addWidget(self.cb_pos_y)
            layout1.addLayout(layouth1_2, 6, 1)

            confirm1 = QPushButton("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å")
            layout1.addWidget(confirm1, 7, 0, 2, 0)
            confirm1.clicked.connect(lambda: self.create_item('sensor'))

            window2 = QWidget()
            layout2 = QVBoxLayout()
            window2.setLayout(layout2)

            delete = QPushButton('–£–¥–∞–ª–∏—Ç—å')
            delete.clicked.connect(self.deletesensor)
            hide = QPushButton('–°–∫—Ä—ã—Ç—å/–û—Ç–±—Ä–∞–∑–∏—Ç—å')
            hide.clicked.connect(self.hidewidget)
            layout2_1 = QHBoxLayout()

            layout2_1.addWidget(hide)
            layout2_1.addWidget(delete)
            layout2.addLayout(layout2_1)

            widget_2 = QWidget()
            layout = QVBoxLayout()
            self.scroll_area = QScrollArea()
            self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
            self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.scroll_area.setWidgetResizable(True)
            self.scroll_content = QWidget(self.scroll_area)
            self.scrollLayout = QVBoxLayout(self.scroll_content)

            self.scrollLayout.setContentsMargins(0, 0, 0, 0)
            self.scrollLayout.setSpacing(0)
            self.content_add()
            layout.addWidget(self.scroll_area)
            widget_2.setLayout(layout)
            widget_2.setFont(QFont('Arial', 12))
            layout2.addWidget(widget_2)

            window3 = QWidget()
            layout3 = QVBoxLayout()
            window3.setLayout(layout3)
            self.input3 = QLineEdit()
            self.input3.setText('69.5*sqrt(342.15*DA1*dP1*10000)/(273+DT1)')
            self.input3.setPlaceholderText('–§–æ—Ä–º—É–ª–∞')
            self.input3_1 = QLineEdit()
            self.input3_1.setPlaceholderText('–∏–º—è')
            self.cb_bit_depth_math = QComboBox()
            for i in range(0, 10):
                self.cb_bit_depth_math.addItem(str(i))
            self.cb_bit_depth_math.setCurrentIndex(2)
            self.cb_color_math = QComboBox()
            self.cb_color_math.addItems(config['COLORS'].keys())
            self.cb_color_math.addItem("C–≤–æ–π —Ü–≤–µ—Ç")

            self.color_label_math = QLabel(self)
            self.color_label_math.setText('–¶–≤–µ—Ç')
            self.color_label_math.setGeometry(50, 100, 200, 50)
            self.color_label_math.setAutoFillBackground(True)
            self.color_label_math.setStyleSheet(f"background-color: #FF5733")
            self.cb_color_math.currentIndexChanged.connect(
                lambda: self.on_combo_box_change(config['COLORS'], self.cb_color_math, self.color_label_math))

            self.cb_name_side_math = QComboBox()
            self.cb_name_side_math.addItems(config['SIDE'].keys())
            self.cb_pos_x_math = QDoubleSpinBox()
            self.cb_pos_y_math = QDoubleSpinBox()
            self.cb_pos_x_math.setMaximum(1920)
            self.cb_pos_y_math.setMaximum(1080)
            self.cb_pos_x_math.setFont(QFont("Arial", 12))
            self.cb_pos_y_math.setFont(QFont("Arial", 12))
            self.cb_pos_x_math.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_math.value(), self.cb_pos_y_math.value()))
            self.cb_pos_y_math.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_math.value(), self.cb_pos_y_math.value()))
            self.cb_pos_x_math.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_math.lineEdit().setAlignment(Qt.AlignCenter)

            self.deepxy(width, height, self.cb_pos_x_math, self.cb_pos_y_math)

            layout3_h1 = QHBoxLayout()
            layout3_h1.addWidget(QLabel('–†–∞–∑—Ä—è–¥–Ω–æ—Å—Ç—å'))
            layout3_h1.addWidget(self.cb_bit_depth_math)
            layout3_h2 = QHBoxLayout()
            layout3_h2.addWidget(QLabel('–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏–º–µ–Ω–∏'))
            layout3_h2.addWidget(self.cb_name_side_math)
            layout3_h3 = QHBoxLayout()
            layout3_h3.addWidget(self.color_label_math)
            layout3_h3.addWidget(self.cb_color_math)

            layout3_h4 = QHBoxLayout()
            layout3_h4.addWidget(QLabel('–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –ø–æ X –∏ Y'))
            layout3_h4.addWidget(self.cb_pos_x_math)
            layout3_h4.addWidget(self.cb_pos_y_math)

            layout3.addWidget(self.input3)
            layout3.addWidget(self.input3_1)
            layout3.addLayout(layout3_h1)
            layout3.addLayout(layout3_h2)
            layout3.addLayout(layout3_h3)
            layout3.addLayout(layout3_h4)

            confirm3 = QPushButton("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å")
            layout3.addWidget(confirm3)
            confirm3.clicked.connect(self.addformula)

            #  window4_0 = QWidget(self)
            #  layout4_0 = QVBoxLayout()
            #  window4_0.setLayout(layout4_0)
            #  self.cb_daq = QComboBox()
            #  system = nidaqmx.system.System.local()
            #  devices = system.devices
            #  self.cb_daq.addItems([f'{daq}/{devices[daq].tcpip_ethernet_ip}' for daq in devices.device_names if 'Mod' not in daq])
            #  for index in range(self.cb_daq.count()):
            #      cb_daq = self.cb_daq.itemText(index).split('/')[1]
            #      if cb_daq in config['IPS']:
            #          self.cb_daq.setCurrentIndex(index)
            #          break
            #
            #  self.cb_daq_mod_type = QComboBox()
            #  self.cd_daq_cur(devices)
            #  self.cb_daq.currentIndexChanged.connect(lambda: self.cd_daq_cur(devices))
            #  self.scroll = QScrollArea()  # –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ QScrollArea
            #  self.scroll.setWidgetResizable(True)  # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –≤–∏–¥–∂–µ—Ç–∞ –≤–Ω—É—Ç—Ä–∏ QScrollArea
            #  self.update_scroll_content()  # –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
            #  self.cb_daq_mod_type.currentIndexChanged.connect(self.update_scroll_content)  # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞ –∫ —Å–ª–æ—Ç—É
            #  device_modules = devices[self.cb_daq_mod_type.currentText().split('/')[0]]
            ##   self.cb_daq_mod_type.clear()
            #
            #  self.input4_0_ch = QSpinBox()
            #  self.input4_0_ch.setMinimum(1)
            #  self.input4_0_ch.setMaximum(
            #      len([channel.name for channel in device_modules.ai_physical_chans]) if hasattr(device_modules,
            #                                                                                     'ai_physical_chans') else 32)
            #  self.cb_daq_mod_range_min = QDoubleSpinBox()
            #  self.cb_daq_mod_range_min.setMaximum(999)
            #  self.cb_daq_mod_range_min.setMinimum(-999)
            #  self.cb_daq_mod_range_min.setDecimals(4)
            #  self.cb_daq_mod_range_max = QDoubleSpinBox()
            #  self.cb_daq_mod_range_max.setMaximum(999)
            #  self.cb_daq_mod_range_max.setMinimum(-999)
            #  self.cb_daq_mod_range_min.setDecimals(4)
            #
            #  layout4_0_h = QHBoxLayout()
            #  layout4_0_h.addWidget(QLabel('ch'))
            #  layout4_0_h.addWidget(self.input4_0_ch)
            #  layout4_0_h.addWidget(QLabel('min'))
            #  layout4_0_h.addWidget(self.cb_daq_mod_range_min)
            #  layout4_0_h.addWidget(QLabel('max'))
            #  layout4_0_h.addWidget(self.cb_daq_mod_range_max)
            #
            #  layout4_0.addWidget(self.cb_daq)
            #  layout4_0.addWidget(self.cb_daq_mod_type)
            #  layout4_0.addLayout(layout4_0_h)
            #  self.btn4_0 = QPushButton('add')
            #  self.btn4_0.clicked.connect(self.get_ch_range)
            #  layout4_0.addWidget(QLabel('ch: min, max'))
            #  layout4_0.addWidget(self.scroll)
            #  layout4_0.addWidget(self.btn4_0)

            window4 = QWidget()
            layout4 = QVBoxLayout()
            window4.setLayout(layout4)
            self.input4 = QLineEdit()
            self.input4.setPlaceholderText('192.168.201.1')
            validator = QRegExpValidator(QRegExp("[0-9\\.]*"))
            self.input4.setValidator(validator)
            self.cb_add_type = QComboBox()
            self.cb_add_type.addItems(['modbus', 'opc', 'elemer', 'daq'])

            self.cb_ip = QComboBox()
            self.cb_ip.addItems(config['IPS'])

            btn4sed = QPushButton('–û—Ç–ø—Ä–∞–≤–∏—Ç—å ip')
            btn4sed.clicked.connect(self.send_ip)
            btn4del = QPushButton('—É–¥–∞–ª–∏—Ç—å ip')
            btn4del.clicked.connect(lambda: self.delip(self.cb_ip.currentText()))

            layout4_h = QHBoxLayout()
            layout4_h.addWidget(QLabel('ip –∞–¥—Ä–µ—Å'))
            layout4_h.addWidget(self.input4)
            layout4_h.addWidget(QLabel('—Ç–∏–ø'))
            layout4_h.addWidget(self.cb_add_type)
            layout4.addLayout(layout4_h)

            layout4.addWidget(btn4sed)
            layout4.addWidget(self.cb_ip)
            layout4.addWidget(btn4del)

            window5 = QWidget()
            layout5 = QGridLayout()
            window5.setLayout(layout5)
            self.cb_name_ru = QComboBox()
            self.cb_name_ru.addItems(['RU', 'ZU'])
            self.cb_orientate = QComboBox()
            self.cb_orientate.addItems(config['ORIENTATION'].keys())
            self.cb_name_runumber = QComboBox()
            self.cb_chr_open = QComboBox()
            self.cb_chr_close = QComboBox()
            self.cb_chdv_open = QComboBox()
            self.cb_chdv_close = QComboBox()
            self.cb_reg_ru = QComboBox()

            self.cb_pos_x_ru = QDoubleSpinBox()
            self.cb_pos_y_ru = QDoubleSpinBox()
            self.cb_pos_x_ru.setFont(QFont('Arial', 12))
            self.cb_pos_y_ru.setFont(QFont('Arial', 12))
            self.cb_pos_x_ru.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_ru.value(), self.cb_pos_y_ru.value()))
            self.cb_pos_y_ru.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_ru.value(), self.cb_pos_y_ru.value()))
            self.cb_pos_x_ru.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_ru.lineEdit().setAlignment(Qt.AlignCenter)

            for i in range(1, 101):
                self.cb_name_runumber.addItem(str(i))
                self.cb_chr_open.addItem(str(i))
                self.cb_chr_close.addItem(str(i))
                self.cb_chdv_open.addItem(str(i))
                self.cb_chdv_close.addItem(str(i))

            self.deepxy(width, height, self.cb_pos_x_ru, self.cb_pos_y_ru)

            self.cb_reg_ru.addItems({k: i + 1 for i, k in enumerate(config['IPS'])})

            self.cb_chr_close.setCurrentIndex(1)
            self.cb_chdv_close.setCurrentIndex(1)

            layout5.addWidget(QLabel("–ò–º—è"), 0, 0)
            layout5_1 = QHBoxLayout()
            layout5_1.addWidget(self.cb_name_ru)
            layout5_1.addWidget(self.cb_name_runumber)
            layout5.addLayout(layout5_1, 0, 1)

            self.oritntation = QLabel("–û—Ä–∏–µ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ")
            layout5.addWidget(self.oritntation, 1, 0)
            layout5.addWidget(self.cb_orientate, 1, 1)

            self.chr_open = (QLabel("–ö–∞–Ω–∞–ª –æ—Ç–∫—Ä"))
            layout5.addWidget(self.chr_open, 2, 0)
            layout5.addWidget(self.cb_chr_open)

            self.chr_close = (QLabel("–ö–∞–Ω–∞–ª –∑–∞–∫—Ä"))
            layout5.addWidget(self.chr_close, 3, 0)
            layout5.addWidget(self.cb_chr_close)

            self.chdv_open = (QLabel("–ö–æ–Ω—Ü–µ–≤–∏–∫ –æ—Ç–∫—Ä"))
            layout5.addWidget(self.chdv_open, 4, 0)
            layout5.addWidget(self.cb_chdv_open)

            self.chdv_close = (QLabel("–ö–æ–Ω—Ü–µ–≤–∏–∫ –∑–∞–∫—Ä"))
            layout5.addWidget(self.chdv_close, 5, 0)
            layout5.addWidget(self.cb_chdv_close)

            layout5.addWidget(QLabel("–†–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä"), 6, 0)

            layout5.addWidget(self.cb_reg_ru)

            layout5.addWidget(QLabel("–ü–æ–ª–æ–∂–µ–Ω–∏–µ –ø–æ X –∏ Y"), 7, 0)
            layout5_2 = QHBoxLayout()

            layout5_2.addWidget(self.cb_pos_x_ru)
            layout5_2.addWidget(self.cb_pos_y_ru)
            layout5.addLayout(layout5_2, 7, 1)
            self.cb_name_ru.currentIndexChanged.connect(self.Furn)

            confirm5 = QPushButton(self.CONFIRM)
            confirm5.clicked.connect(lambda: self.create_item('RU'))
            layout5.addWidget(confirm5, 9, 0, 2, 0)

            window7 = QWidget()
            layout7 = QGridLayout()
            window7.setLayout(layout7)
            self.r1 = QComboBox()
            self.r2 = QComboBox()
            self.r1_sleep = QDoubleSpinBox()
            self.r2_sleep = QDoubleSpinBox()
            self.r1_sleep.setFont(QFont('Arial', 16))
            self.r2_sleep.setFont(QFont('Arial', 16))
            self.r1_sleep.setSuffix('   –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø–µ—Ä–≤–æ–π –∑–∞—Å–ª–æ–Ω–∫–∏')
            self.r2_sleep.setSuffix('   –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –≤—Ç–æ—Ä–æ–π –∑–∞—Å–ª–æ–Ω–∫–∏')

            self.time_rearrangement = QDoubleSpinBox()
            self.time_rearrangement.setFont(QFont('Arial', 16))
            self.time_rearrangement.setSuffix('   –≤—Ä–µ–º—è –ø–µ—Ä–µ–∫–ª–∞–¥–∫–∏')

            confirm7 = QPushButton(self.CONFIRM)
            self.r1.addItems([i.name for i in self.dampers_list])
            self.r2.addItems([i.name for i in self.dampers_list])
            layout7.addWidget(self.r1)
            layout7.addWidget(self.r1_sleep)
            layout7.addWidget(self.r2)
            layout7.addWidget(self.r2_sleep)
            layout7.addWidget(self.time_rearrangement)

            self.cb_pos_x_rerange = QDoubleSpinBox()
            self.cb_pos_y_rerange = QDoubleSpinBox()
            self.cb_pos_x_rerange.setMaximum(1920)
            self.cb_pos_y_rerange.setMaximum(1080)
            self.cb_pos_x_rerange.setFont(QFont('Arial', 16))
            self.cb_pos_y_rerange.setFont(QFont('Arial', 16))

            self.cb_pos_x_rerange.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_rerange.value(), self.cb_pos_y_rerange.value()))
            self.cb_pos_y_rerange.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_rerange.value(), self.cb_pos_y_rerange.value()))
            self.cb_pos_x_rerange.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_rerange.lineEdit().setAlignment(Qt.AlignCenter)

            layout7_h1 = QHBoxLayout()
            layout7_h1.addWidget(QLabel('–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –ø–æ X –∏ Y'))
            layout7_h1.addWidget(self.cb_pos_x_rerange)
            layout7_h1.addWidget(self.cb_pos_y_rerange)
            layout7.addLayout(layout7_h1, 5, 0)
            layout7.addWidget(confirm7)
            confirm7.clicked.connect(lambda: self.create_item('Rer'))

            window8 = QWidget()
            layout8 = QGridLayout()
            window8.setLayout(layout8)
            # Furn F1 1 1.6 1
            self.number = QSpinBox()
            self.number.setSuffix(' –ù–æ–º–µ—Ä')
            self.number.setMinimum(1)
            self.number.setFont(QFont('Arial', 16))

            self.ch_furn = QSpinBox()
            self.ch_furn.setMinimum(1)
            self.ch_furn.setSuffix('    –ö–∞–Ω–∞–ª')
            self.ch_furn.setFont(QFont('Arial', 16))

            self.max = QDoubleSpinBox()
            self.max.setSuffix('    –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ç–æ–∫')
            self.max.setFont(QFont('Arial', 16))
            self.max.setMinimum(.5)

            self.reg_furn = QSpinBox()
            self.reg_furn.setMinimum(1)
            self.reg_furn.setSuffix('   –†–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä')
            self.reg_furn.setFont(QFont('Arial', 16))
            self.cb_pos_x_furn = QDoubleSpinBox()
            self.cb_pos_y_furn = QDoubleSpinBox()
            self.cb_pos_x_furn.setMaximum(1920)
            self.cb_pos_y_furn.setMaximum(1080)
            self.cb_pos_x_furn.setFont(QFont('Arial', 16))
            self.cb_pos_y_furn.setFont(QFont('Arial', 16))

            self.cb_pos_x_furn.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_furn.value(), self.cb_pos_y_furn.value()))
            self.cb_pos_y_furn.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_furn.value(), self.cb_pos_y_furn.value()))
            self.cb_pos_x_furn.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_furn.lineEdit().setAlignment(Qt.AlignCenter)

            layout8_h1 = QHBoxLayout()
            layout8_h1.addWidget(QLabel('–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –ø–æ X –∏ Y'))
            layout8_h1.addWidget(self.cb_pos_x_furn)
            layout8_h1.addWidget(self.cb_pos_y_furn)

            confirm8 = QPushButton(self.CONFIRM)
            confirm8.clicked.connect(lambda: self.create_item('Furn'))
            layout8.addWidget(self.number)
            layout8.addWidget(self.ch_furn)
            layout8.addWidget(self.max)
            layout8.addWidget(self.reg_furn)
            layout8.addLayout(layout8_h1, 4, 0)
            layout8.addWidget(confirm8, 5, 0)

            window6 = QWidget()
            try:
                port_names = QComboBox()
                for port, names in config["ports"].items():
                    port_names.addItem(port)
                    port_names.addItems(names)
            except:
                pass
            button6_1 = QPushButton('–ì—Ä–∞—Ñ–∏–∫–∏')
            button6_1.clicked.connect(GraphWindow.create_new_graph_window)
            button6_set = QPushButton('–£—Å—Ç–∞–≤–∫–∏')
            button6_set.clicked.connect(self.show_setpoint_window)

            button6_2 = QPushButton('–≠–∫—Å–ø–æ—Ä—Ç –£—Å—Ç–∞–≤–æ–∫ (—Ä–∞–º–æ–∫)')

            def export_registry():
                subprocess.run(['reg', 'export', r'HKEY_CURRENT_USER\SOFTWARE\MyApp',
                                fr'{config["IZDELIE"]}\{config["IZDELIE"]}_ust.reg', '/y'], check=True)

            button6_2.clicked.connect(export_registry)

            layout6 = QVBoxLayout()
            layout6.addWidget(button6_1)
            layout6.addWidget(button6_set)
            layout6.addWidget(button6_2)
            window6.setLayout(layout6)

            hbox6_3 = QHBoxLayout()
            self.ustbtn = QPushButton('–ò–∑–º–µ–Ω–∏—Ç—å')
            line_edit = QSpinBox()
            line_edit.setAlignment(Qt.AlignCenter)
            line_edit.setFont(QFont('Arial', 14))
            label6_3 = QLabel("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Å—Ç–∞–≤–æ–∫:")
            self.ustbtn.clicked.connect(lambda: self.on_ustbtn_click(str(line_edit.value())))
            hbox6_3.addWidget(label6_3)
            hbox6_3.addWidget(line_edit)
            hbox6_3.addWidget(self.ustbtn)
            layout6.addLayout(hbox6_3)

            # –†–∞–∑–º–µ—Ä —Å–µ–Ω—Å–æ—Ä–æ–≤ ‚Äî —Å–ª–∞–π–¥–µ—Ä
            self.cb_size = QSlider(Qt.Horizontal)
            self.cb_size.setMinimum(-10)
            self.cb_size.setMaximum(100)
            self.cb_size.setValue(config.get('sensor_size', 5))
            self.cb_size.setTickInterval(1)
            self.cb_size.setTickPosition(QSlider.TicksBelow)

            self.cb_size.valueChanged.connect(
                lambda val: (
                    self.update_setting_file('sensor_size', str(val)),
                    self.refresh_sensor_size(val)
                )
            )

            hbox6_2 = QHBoxLayout()
            hbox6_2.addWidget(QLabel("–†–∞–∑–º–µ—Ä —Å–µ–Ω—Å–æ—Ä–æ–≤:"))
            hbox6_2.addWidget(self.cb_size)
            layout6.addLayout(hbox6_2)

            self.cb_damper_size = QSlider(Qt.Horizontal)
            self.cb_damper_size.setMinimum(-35)
            self.cb_damper_size.setMaximum(35)
            self.cb_damper_size.setValue(config.get('damper_size', 2))
            self.cb_damper_size.setTickInterval(1)
            self.cb_damper_size.setTickPosition(QSlider.TicksBelow)

            self.cb_damper_size.valueChanged.connect(
                lambda val: (
                    self.update_setting_file('damper_size', str(val)),
                    self.refresh_damper_size(val)
                )
            )

            self.ckhidename_b = QPushButton('–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–º–µ–Ω–∏')
            self.ckhidename_b.clicked.connect(lambda: (
                self.setting('hidename'),
                self.refresh_sensor_names_visibility()
            ))

            hbox6_2 = QHBoxLayout()
            layout6.addLayout(hbox6_2)

            hbox6_4 = QHBoxLayout()
            hbox6_4.addWidget(QLabel("–†–∞–∑–º–µ—Ä –∑–∞—Å–ª–æ–Ω–æ–∫:"))
            hbox6_4.addWidget(self.cb_damper_size)
            layout6.addLayout(hbox6_4)

            try:
                layout6.addWidget(port_names)
            except:
                pass
            layout6.addWidget(self.ckhidename_b)

            layout = QVBoxLayout()
            layout.addWidget(QWidget())

            self.tabs = QTabWidget()
            self.tabs.setFont(QFont('Arial', 14))
            self.tabs.setStyleSheet("QTabWidget::pane { border-top: 2px solid #C2C7CB; }"
                                    "QTabBar::tab { height: 30px;  border-top-left-radius: 10px; border-top-right-radius: 10px;margin-right:15px; }"
                                    "QTabBar::tab:hover {background-color: #49B69F;}"
                                    "QTabBar::tab:selected { background-color: #A3C1DA;color:white ; border-top-left-radius: 10px; border-top-right-radius: 10px;}"
                                    "QLabel {font-size: 14pt;}"
                                    "QComboBox {font-size: 14pt;}"
                                    "QLineEdit {font-size: 14pt;}"
                                    """QPushButton {font-size: 14pt;background-color: #A3C1DA; border-radius: 8px;}
                                       QPushButton:hover {background-color: #49B69F;}
                                       QPushButton:pressed {background-color: #5549B6;}

                                       """)
            self.tabs.addTab(window0, "–¢–∞–π–º–µ—Ä")
            self.tabs.addTab(window, "–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–∞—Ç—á–∏–∫–∞")
            self.tabs.addTab(window2, "–°–∫—Ä—ã—Ç—å/–£–¥–∞–ª–µ–Ω–∏–µ")
            self.tabs.addTab(window3, "–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞")
            # self.tabs.addTab(window4_0, "DAQ_modules")
            self.tabs.addTab(window4, "–î–æ–±–∞–≤–ª–µ–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ IP")
            self.tabs.addTab(window5, "–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞—Å–ª–æ–∫–∏")
            self.tabs.addTab(window8, "–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–µ—á–∏")
            self.tabs.addTab(window7, "–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–∫–ª–∞–¥–∫–∏")
            self.tabs.addTab(window6, "–ù–∞—Å—Ç—Ä–æ–π–∫–∞")
            self.tabs.currentChanged.connect(self.on_tab_changed)
            layout = QVBoxLayout()
            layout.addWidget(self.tabs)
            self.btnreboot = QPushButton('–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞')
            self.btnreboot.clicked.connect(self.reboots)
            layout.addWidget(self.btnreboot)
            custom_font = QFont()
            custom_font.setWeight(18)

            self.setLayout(layout)

    def refresh_sensor_names_visibility(self):
        """
        –û–±–Ω–æ–≤–ª—è–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–º—ë–Ω —É –≤—Å–µ—Ö —Å–µ–Ω—Å–æ—Ä–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ config['hidename'].
        """
        hide = int(config.get('hidename', 0)) == 1

        if hasattr(dlgMain, 'sensor_list'):
            for sensor in dlgMain.sensor_list:
                sensor.hidename(hide)

        if hasattr(dlgMain, 'formuls'):
            for formula in dlgMain.formuls:
                formula.hidename(hide)

        if hasattr(dlgMain, 'const'):
            for const in dlgMain.const:
                const.hidename(hide)

    def refresh_damper_size(self, new_value: int):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –º–∞—Å—à—Ç–∞–± –≤—Å–µ—Ö –∑–∞—Å–ª–æ–Ω–æ–∫"""
        for damper in dlgMain.dampers_list:
            damper.scaletext(new_value)

    def update_setting_file(self, key: str, value: str):
        path = config['setting']
        with open(path, 'r') as f:
            lines = f.readlines()

        found = False
        with open(path, 'w') as f:
            for line in lines:
                if line.strip().startswith(f"{key}"):
                    f.write(f"{key} = {value}\n")
                    found = True
                else:
                    f.write(line)
            if not found:
                f.write(f"{key} = {value}\n")

    def refresh_sensor_size(self, new_value: int):
        """
        –û–±–Ω–æ–≤–ª—è–µ—Ç –º–∞—Å—à—Ç–∞–± –≤—Å–µ—Ö —Å–µ–Ω—Å–æ—Ä–æ–≤, —Ñ–æ—Ä–º—É–ª –∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç.
        """
        config['sensor_size'] = new_value

        if hasattr(dlgMain, 'sensor_list'):
            for sensor in dlgMain.sensor_list:
                if hasattr(sensor, 'scaletext'):
                    sensor.scaletext(new_value)

        if hasattr(dlgMain, 'formuls'):
            for formula in dlgMain.formuls:
                if hasattr(formula, 'scaletext'):
                    formula.scaletext(new_value)

        if hasattr(dlgMain, 'const'):
            for const in dlgMain.const:
                if hasattr(const, 'scaletext'):
                    const.scaletext(new_value)

    def show_setpoint_window(self):
        if not hasattr(dlgMain, 'set_window') or dlgMain.set_window is None or not dlgMain.set_window.isVisible():
            dlgMain.set_window = SetPointWindow(dlgMain)
            dlgMain.set_window.setWindowModality(Qt.NonModal)
            dlgMain.set_window.setAttribute(Qt.WA_DeleteOnClose, False)

        dlgMain.set_window.show()
        dlgMain.set_window.raise_()
        dlgMain.set_window.activateWindow()

    def on_ustbtn_click(self, new_value):
        try:
            with open(config['setting'], 'r') as file:
                lines = file.readlines()
            with open(config['setting'], 'w') as file:
                for line in lines:
                    if line.startswith("pack"):
                        file.write('pack =' + new_value + '\n')
                    else:
                        file.write(line)
        except Exception as e:
            print("Error while updating setting:", e)

    def open_timer_logic(self):
        if not hasattr(dlgMain, 'algoritms') or dlgMain.algoritms is None or not dlgMain.algoritms.isVisible():
            dlgMain.algoritms = Timers()
            dlgMain.algoritms.setGeometry(400, 800, 400, 200)
            dlgMain.algoritms.hide_timer_settings()
            dlgMain.algoritms.show()
        else:
            dlgMain.algoritms.raise_()
            dlgMain.algoritms.activateWindow()

    def closeEvent(self, event):
        self.central_widget.hide()
        event.accept()

    def handlePosChanged(self, pos_tuple):
        x, y = pos_tuple
        self.cb_pos_x.setValue(x)
        self.cb_pos_x_ru.setValue(x)
        self.cb_pos_x_math.setValue(x)
        self.cb_pos_x_furn.setValue(x)
        self.cb_pos_x_rerange.setValue(x)
        self.cb_pos_y.setValue(y)
        self.cb_pos_y_ru.setValue(y)
        self.cb_pos_y_math.setValue(y)
        self.cb_pos_y_furn.setValue(y)
        self.cb_pos_y_rerange.setValue(y)

    def content_add(self):
        while self.scrollLayout.count():
            item = self.scrollLayout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        self.f = self.get_name()
        for line in self.f:
            if line.count('#') >= 2 or line == '\n':
                continue
            checkbox = QCheckBox(line)
            if '#' in line:
                checkbox.setStyleSheet('background-color:  #CCCCCC')
            else:
                checkbox.setStyleSheet('background-color: white')
            self.scrollLayout.addWidget(checkbox)
        self.scroll_area.setWidget(self.scroll_content)

    def update_scroll_content(self):

        scroll_content_channls = QWidget()
        scroll_layout = QVBoxLayout(scroll_content_channls)  # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –º–∞–∫–µ—Ç–∞
        selected_daq = self.cb_daq_mod_type.currentText().split('/')[0].replace('-',
                                                                                '_')  # –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ combobox
        if selected_daq in globals():
            daq_dict = globals()[selected_daq]
            for key, value in daq_dict.items():
                label = QLabel(f"{str(key)} : {str(value)}", self)
                scroll_layout.addWidget(label)

        self.scroll.setWidget(scroll_content_channls)

    def get_ch_range(self):
        try:
            infile_name = self.cb_daq_mod_type.currentText().split('/')[0].replace('-', '_')
            ch_num = int(self.input4_0_ch.value())
            min_ch = self.cb_daq_mod_range_min.value()
            max_ch = self.cb_daq_mod_range_max.value()
        except ValueError as e:
            warning_window('–î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã \n–ø—Ä–æ–≤–µ—Ä—å—Ç–µ ch min max', False)
            return
        globals()[infile_name].update({ch_num: (min_ch, max_ch)})
        dict_range = globals()[infile_name]
        self.redact(infile_name, dict_range)
        self.update_scroll_content()

    def redact(self, infile_name, dict_range):
        with open(config['setting'], 'r') as file:
            lines = file.readlines()

        flag = False
        with open(config['setting'], 'w') as f:
            for line in lines:
                if infile_name in line:
                    f.write(f'{infile_name} = {dict_range}\n')
                    flag = True
                else:
                    f.write(line)
            if not flag:
                lines.insert(7, infile_name)

    def cd_daq_cur(self, devices):
        selected_device = self.cb_daq.currentText().split('/')[0]
        device_modules = devices[selected_device]
        self.cb_daq_mod_type.clear()
        name_models = {module.name: module.product_type for module in device_modules.chassis_module_devices}
        self.cb_daq_mod_type.addItems(self.detect_module_type(name_models))
        for index in range(self.cb_daq_mod_type.count()):
            cb_daq = self.cb_daq_mod_type.itemText(index)
            if 'ai' in cb_daq:
                self.cb_daq_mod_type.setCurrentIndex(index)
                break

    def detect_module_type(self, name_models):
        names = []

        MODULELIST = {'9208': 'ai', '9403': 'do', '9425': 'di', '9265': 'ao', '9213': 'tc',
                      '9214': 'tc', '9217': 'rtd', '9222': 'vi'}
        for name, module in name_models.items():
            for mod, value in MODULELIST.items():
                if mod in module:
                    names.append(name + '/' + module + '/' + value)
        return names

    def on_tab_changed(self, current_tab_index):
        tab_widget_name = self.tabs.tabText(current_tab_index)
        self.btnreboot.show() if tab_widget_name != "–¢–∞–π–º–µ—Ä" else self.btnreboot.hide()

    def on_combo_box_change(self, colors, cbox, cblabel):
        if cbox.currentText() in colors:
            cblabel.setStyleSheet(f"background-color: #{colors[cbox.currentText()]}")

        elif cbox.currentText() == '–°–≤–æ–π —Ü–≤–µ—Ç':
            color = QColorDialog.getColor()
            if color.isValid():
                cblabel.setStyleSheet(f"background-color: {color.name()}")
                cbox.addItem(color.name())
                cbox.setCurrentIndex(cbox.count() - 1)

    def set_sensor_size(self, f):
        value = self.cb_size.currentText()
        f.write(f"sensor_size = {value}\n")

    def toggle_hidename(self, line, f):
        value = '1' if '0' in line else '0'
        f.write(f"hidename = {value}\n")

    def setting(self, too):
        with open(config['setting'], 'r') as file:
            lines = file.readlines()

        with open(config['setting'], 'w') as f:
            for line in lines:
                if too == 'sensor_size' and 'sensor_size' in line:
                    self.set_sensor_size(f)
                elif too == 'hidename' and 'hidename' in line:
                    self.toggle_hidename(line, f)
                else:
                    f.write(line)

    def setname(self):
        if '—Å–≤–æ—ë –∏–º—è' in self.cb_name.currentText():
            text, okpressed = QInputDialog.getText(self, "–ò–º—è", "–ò–º—è –¥–∞—Ç—á–∏–∫–∞", QLineEdit.Normal, "")
            if okpressed and text != '':
                self.cb_name.addItem(text)
                self.cb_name.setCurrentIndex(self.cb_name.count() - 1)

    def Furn(self):
        if 'Furn' in self.cb_name_ru.currentText():
            self.cb_orientate.hide()
            self.cb_chr_open.hide()
            self.cb_chr_close.hide()
            self.cb_chdv_open.hide()

            self.oritntation.hide()
            self.chr_close.hide()
            self.chr_open.hide()
            self.chdv_open.hide()

            self.cb_chdv_close.clear()
            self.cb_chdv_close.addItems([str(i) for i in range(1, 100, 2)])
            self.chdv_close.setText('–ö–∞–Ω–∞–ª –ø–µ—á–∏')
        else:
            self.cb_orientate.show()
            self.cb_chr_open.show()
            self.cb_chr_close.show()
            self.cb_chdv_open.show()

            self.oritntation.show()
            self.chr_close.show()
            self.chr_open.show()
            self.chdv_open.show()

            self.cb_chdv_close.clear()
            self.cb_chdv_close.addItems([str(i) for i in range(1, 100)])
            self.cb_chdv_close.setCurrentIndex(1)

            self.chdv_close.setText("–ö–æ–Ω—Ü–µ–≤–∏–∫ –∑–∞–∫—Ä")

    def deepxy(self, width, height, xpos, ypos):
        xpos.setRange(-width, width)
        xpos.setValue(int(width / 2))
        ypos.setRange(-height, height)
        ypos.setValue(int(height / 2))

    def hidewidget(self):
        with open(config['setting'], 'r') as file:
            data = file.readlines()
        for index_item in range(self.scrollLayout.count()):
            widget = self.scrollLayout.itemAt(index_item).widget()
            if isinstance(widget, QCheckBox) and widget.isChecked():
                self.checked_items.append(widget.text())
        data = ['#' + line if line in self.checked_items and '#' not in line else line[
                                                                                  1:] if line in self.checked_items and '#' in line else line
                for line in data]
        with open(config['setting'], 'w') as file:
            file.writelines(data)
        self.checked_items.clear()
        self.content_add()

    def deletesensor(self):
        with open(config['setting'], "r") as f:
            lines = f.readlines()

        self.checked_items.clear()
        names_to_remove = []

        # 1. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ –∏—Ö –∏–º–µ–Ω–∞
        for i in range(self.scrollLayout.count()):
            widget = self.scrollLayout.itemAt(i).widget()
            if isinstance(widget, QCheckBox) and widget.isChecked():
                line = widget.text()
                self.checked_items.append(line)
                name = line.strip().split()[0]
                names_to_remove.append(name)

        # 2. –£–¥–∞–ª—è–µ–º —Å—Ç—Ä–æ–∫–∏ –∏–∑ setting1.txt
        with open(config['setting'], 'w') as f:
            for line in lines:
                stripped = line.strip()

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏, –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Ç.–¥.
                if not stripped or stripped.startswith(
                        '#') or '##' in stripped or '###' in stripped or '###############################################################################' in stripped:
                    f.write(line)
                    continue

                # –ë–µ—Ä—ë–º –∏–º—è –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ–≤–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä DA3, RU4, Furn –∏ —Ç.–¥.)
                parts = stripped.split()
                name = parts[0] if parts else ''

                # –ï—Å–ª–∏ –∏–º—è –Ω–µ –æ—Ç–º–µ—á–µ–Ω–æ ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É
                if name not in names_to_remove:
                    f.write(line)

        # 3. –£–¥–∞–ª—è–µ–º –∏–∑ GUI
        for name in names_to_remove:
            dlgMain.remove_sensor(name)

        # 4. –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        self.checked_items.clear()
        self.content_add()

    def addformula(self):
        variables = set(re.findall(r'[a-zA-Z]\w*', self.input3.text()))  # –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–∑ —Ñ–æ—Ä–º—É–ª—ã
        missing_variables = [var for var in variables if
                             var != 'sqrt' and var not in [i.name for i in self.sensor_list]]

        if missing_variables:
            warning_window(f'–°–ª–µ–¥—É—é—â–∏–µ {missing_variables} –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ –±–∞–∑–µ –∏–ª–∏ —Å–∫—Ä—ã—Ç—ã (–Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å #)',
                           False)
            return

        clr = config['COLORS'].get(self.cb_color_math.currentText(), self.cb_color_math.currentText().lstrip('#'))
        side = config['SIDE'].get(self.cb_name_side.currentText(), 'transparent')

        with open(config['setting'], 'r') as f:
            lines = f.readlines()
            counter = 1
            if self.input3_1.text() == '':
                while any('math' in line for line in lines):
                    counter += 1
                self.input3_1.setText(f'math{counter}')
            for line in lines:
                if self.input3_1.text() in line:
                    warning_window(f'{lines.index(line)} {self.input3_1.text()} —É–∂–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö', False)
                    return
        with open(config['setting'], 'a') as file:
            file.write(
                f'Math {self.input3_1.text()} {self.input3.text()} {clr} {side} {self.cb_bit_depth_math.currentText()} ({int(self.cb_pos_x_math.value())} {int(self.cb_pos_y_math.value())})')

    def send_ip(self):
        with open(config['setting'], 'r') as file:
            data = file.readlines()
        with open(config['setting'], 'w') as file:
            for line in data:
                if config['IPS'] == '{' in line:
                    if self.input4.text() not in config['IPS']:
                        line = line.replace('}', f',\'{self.input4.text()}\':\'{self.cb_add_type.currentText()}\'}}')

                file.write(line)

    def delip(self, ip_to_delete):
        with open(config['setting'], 'r') as f:
            lines = f.readlines()

        with open(config['setting'], 'w') as f:
            for line in lines:
                if config['IPS'] in line and '##' not in line:
                    del config['IPS'][ip_to_delete]
                    line = f'{config["IPS"]} = {str(config["IPS"])}\n'
                f.write(line)

    def create_item(self, objct):
        # –°–æ–∑–¥–∞–Ω–∏–µ –∞–π—Ç–∏–º–∞`
        side = config['SIDE'].get(self.cb_name_side.currentText(), 'transparent')
        p = {k: i + 1 for i, k in enumerate(config['IPS'])}
        ip = p.get(self.cb_reg.currentText())
        clr = config['COLORS'].get(self.cb_color.currentText(), self.cb_color.currentText().lstrip('#'))
        with open(config['setting'], 'r') as f:
            lines = f.readlines()
            for line in lines:
                try:
                    words = line.split(' ')
                    if objct == 'sensor' and self.cb_name.currentText() + self.cb_namenumber.currentText() in line or \
                            self.cb_channel.currentText() == words[1] and objct == 'sensor' and str(
                        self.cb_reg.currentIndex() + 1) in words[
                        5]:
                        warning_window(
                            f"–°—Ç—Ä–æ–∫–∞ {lines.index(line) + 1} {self.cb_name.currentText() + self.cb_namenumber.currentText() + ' ' + self.cb_channel.currentText() + ' ' + str(self.cb_reg.currentIndex() + 1)} sensor —É–∂–µ  –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.",
                            False)
                        return

                    if (objct == 'RU' and words[
                        0] == self.cb_name_ru.currentText() + self.cb_name_runumber.currentText() or \
                            objct == 'RU' and self.cb_chr_open.currentText() == words[2] and str(
                                self.cb_reg_ru.currentIndex() + 1) in words[6] or \
                            objct == 'RU' and self.cb_chr_close.currentText() == words[3] and str(
                                self.cb_reg_ru.currentIndex() + 1) in words[6] or \
                            objct == 'RU' and self.cb_chdv_open.currentText() == words[4] and str(
                                self.cb_reg_ru.currentIndex() + 1) in words[6] or \
                            objct == 'RU' and self.cb_chdv_close.currentText() == words[5] and str(
                                self.cb_reg_ru.currentIndex() + 1) in words[6]):
                        warning_window(
                            f"–°—Ç—Ä–æ–∫–∞ {lines.index(line)} {self.cb_name_ru.currentText() + self.cb_name_runumber.currentText()} RU —É–∂–µ  –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.",
                            False)
                        return
                    if objct == 'Furn' and f'F{str(self.number.value())}' == words[1] or \
                            objct == 'Furn' and 'Furn' in line and str(self.ch_furn.value()) == words[2] and str(
                        self.reg_furn.value()) == words[4]:
                        print(line)
                        warning_window(
                            f"–°—Ç—Ä–æ–∫–∞ {lines.index(line) + 1} {f'F{str(self.number.value())} '} {str(self.ch_furn.value())} {str(self.max.value())} {str(self.reg_furn.value())}  Furn —É–∂–µ  –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.",
                            False)
                        return
                except Exception:
                    pass
        with open(config['setting'], 'w') as f:
            count = 0
            for i, line in enumerate(lines):
                f.write(line)
                if config['GRID'] in line:
                    count += 1
                if count == 2 and objct == 'sensor':
                    count += 1
                    f.write(
                        f'{self.cb_name.currentText() + self.cb_namenumber.currentText()} {self.cb_channel.currentText()} {clr} {side} {self.cb_bit_depth.currentText()} {ip} 0.0 ({int(self.cb_pos_x.value())} {int(self.cb_pos_y.value())})\n')
                    name = self.cb_name.currentText() + self.cb_namenumber.currentText()
                    ch = int(self.cb_channel.currentText())
                    clr = config['COLORS'].get(self.cb_color.currentText(), self.cb_color.currentText().lstrip('#'))
                    side = config['SIDE'].get(self.cb_name_side.currentText(), 'left')
                    bit_depth = int(self.cb_bit_depth.currentText())
                    reg = self.cb_reg.currentIndex() + 1  # –∏–Ω–¥–µ–∫—Å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 0, –∞ —É —Ç–µ–±—è –≤ —Ñ–∞–π–ª–µ —Å 1
                    amendment = 0.0  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                    x = int(self.cb_pos_x.value())
                    y = int(self.cb_pos_y.value())
                    sensor_key = (reg - 1, ch - 1)
                    if sensor_key not in dlgMain.sensor_by_key:
                        dlgMain.add_sensor(name, ch, clr, side, bit_depth, reg, amendment, (x, y))

                    sensor = dlgMain.sensor_by_key.get(sensor_key)
                    if sensor:

                        if sensor not in dlgMain.sensor_list:
                            dlgMain.sensor_list.append(sensor)
                        if sensor not in dlgMain.ourch:
                            dlgMain.ourch.append(sensor)
                        dlgMain.ourch_split.setdefault(sensor.reg, []).append(sensor)
                        dlgMain.sensor_by_name[sensor.name] = sensor
                        dlgMain.do_things()  # ‚Üê 1. –≤—ã–∑—ã–≤–∞–µ–º —Å—Ä–∞–∑—É –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
                    #      self.content_add()

                    else:
                        print(f"[ERROR] sensor not found after add: {sensor_key}")

                    start_grids_index = 2
                    end_grids_index = 3
                    sort_key_index = 5
                if count == 4 and objct == 'RU':
                    count += 1
                    f.write(
                        f'{self.cb_name_ru.currentText() + self.cb_name_runumber.currentText()} {config["ORIENTATION"].get(self.cb_orientate.currentText())} {self.cb_chr_open.currentText()} {self.cb_chr_close.currentText()} {self.cb_chdv_open.currentText()} {self.cb_chdv_close.currentText()} {self.cb_reg_ru.currentIndex() + 1} ({int(self.cb_pos_x.value())} {int(self.cb_pos_y.value())})\n')
                    start_grids_index = 4
                    end_grids_index = 5
                    sort_key_index = 6
                if count == 6 and objct == 'Furn':
                    count += 1
                    f.write(
                        f'Furn F{str(self.number.value())} {str(self.ch_furn.value())} {str(self.max.value())} {str(self.reg_furn.value())} ({str(int(self.cb_pos_x_furn.value()))} {str(int(self.cb_pos_y_furn.value()))})\n')
                    start_grids_index = 6
                    end_grids_index = 7
                    sort_key_index = 4
                if count == 8 and objct == 'Rer':
                    count += 1
                    f.write(
                        f'{self.r1.currentText()}~{self.r2.currentText()} {str(self.r1_sleep.value())} {str(self.r2_sleep.value())} {str(int(self.time_rearrangement.value()))} ({str(int(self.cb_pos_x_rerange.value()))} {str(int(self.cb_pos_y_rerange.value()))})\n')
        if objct != 'Rer':
            self.extract_text_between_grids(start_grids_index, end_grids_index, sort_key_index)

    def get_name(self):
        count = 0
        with open(config['setting'], 'r') as f:
            for i, line in enumerate(f):
                if config['GRID'] in line:
                    count += 1
                if count == 2:
                    lines = [line for line in f if '##' not in line or line == '\n']
                    break
        return lines

    def reboots(self):
        pass
        ## dlgMain.reboots()
        # for widget in dlgMain.topLevelWidgets():
        #    if isinstance(widget, QMainWindow):
        #        widget.close()
        ## –û–±—ä—è–≤–ª–µ–Ω–∏–µ, —á—Ç–æ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
        # dlgMain.close()
        # dlgMain = MainShem()
        # dlgMain.run_app()


class GraphWindow(QMainWindow):
    data_for_graph = {}  # –û–±—â–∏–µ –¥–∞–Ω–Ω—ã–µ –¥–∞—Ç—á–∏–∫–∞ –¥–ª—è –≤—Å–µ—Ö —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤
    name_formuls = []
    formuls = []
    print(data_for_graph)

    def __init__(self):

        super().__init__()
        self.all_impuls = Damper.all_impuls
        self.sensor_data = dlgMain.sensor_list
        self.setWindowTitle('–ì—Ä–∞—Ñ–∏–∫_0')
        self.menu = self.menuBar().addMenu('–í—ã–±–æ—Ä –¥–∞—Ç—á–∏–∫–æ–≤')
        menu2 = self.menuBar().addMenu('–ù–æ–≤–æ–µ –æ–∫–Ω–æ(F2)')
        self.actions = {}
        action_reverse = QAction("–û–±—Ä–∞—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ F3", self)
        action_reverse.triggered.connect(self.revers_checks)
        self.menu.addAction(action_reverse)

        action_clear_all = QAction("–°–Ω—è—Ç—å –≤—Å–µ F4", self)
        action_clear_all.triggered.connect(self.clear_all_checks)
        self.menu.addAction(action_clear_all)

        for item in self.sensor_data + self.name_formuls:
            action = QAction(str(item), self)
            action.setCheckable(True)
            action.setChecked(True)
            action.triggered.connect(lambda checked, sensor=item: self.toggle_sensor(checked, sensor))
            self.menu.addAction(action)
            self.actions[item] = action

        create_action = QAction('–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –æ–∫–Ω–æ', self)
        create_action.triggered.connect(self.create_new_graph_window)
        menu2.addAction(create_action)
        menu3 = self.menuBar().addMenu('–°–∫—Ä—ã—Ç—å —Ä–∞–º–∫–∏(F1)')
        create_action_hide = QAction('–°–∫—Ä—ã—Ç—å', self)
        create_action_hide.triggered.connect(self.toggle_visibility)
        menu3.addAction(create_action_hide)

        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –≥—Ä–∞—Ñ–∏–∫–∞
        self.graphwidget = pg.PlotWidget(self)
        self.setCentralWidget(self.graphwidget)

        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≥—Ä–∞—Ñ–∏–∫–∞
        self.graphwidget.showGrid(x=True, y=True)
        self.graphwidget.setBackground('#1A1A1A')

        axis = pg.DateAxisItem(orientation='bottom')
        axis.setTickFont(QFont('Arial', 11))
        self.line = pg.PlotCurveItem(pen="g")
        self.graphwidget.addItem(self.line)
        self.graphwidget.setAxisItems({"bottom": axis})
        self.graphwidget.setLabel('bottom',
                                  f'<span style="font-size: 14px;">{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</span>')

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
        self.data = {}
        for sensor in self.sensor_data + self.name_formuls:
            self.data[sensor] = {'x': [], 'y': []}
        legend = pg.LegendItem()
        legend.setParentItem(self.graphwidget.graphicsItem())
        # –°–æ–∑–¥–∞–µ–º –∫—Ä–∏–≤—ã–µ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–∞—Ç—á–∏–∫–∞
        self.curves = {}
        self.list_name = []
        # –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–∞—Ç—á–∏–∫–∞
        self.text_items = {}
        for sensor in self.sensor_data:
            self.curves[sensor] = self.graphwidget.plot(self.data[sensor]['x'], self.data[sensor]['y'],
                                                        pen=pg.mkPen(color=pg.intColor(self.sensor_data.index(sensor)),
                                                                     width=2))
            self.text_items[sensor] = TextItem('', anchor=(0.5, 0))
            self.text_items[sensor].setFont(QFont('Arial', 11))
            self.graphwidget.addItem(self.text_items[sensor])
            self.list_name.append(sensor.name)

        for name in self.name_formuls:
            self.curves[name] = self.graphwidget.plot(self.data[name]['x'], self.data[name]['y'], pen=pg.mkPen(
                color=pg.intColor((self.name_formuls.index(name) + 10) * (-1)),
                width=2))
            self.text_items[name] = TextItem('', anchor=(0.5, 0))
            self.text_items[name].setFont(QFont('Arial', 11))

            self.graphwidget.addItem(self.text_items[name])
            self.list_name.append(name)
        self.graphwidget.setLabel('left',
                                  f'<span style="font-size: 14px;">      {" ".join(str(item) for item in self.list_name)}</span>')
        # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_graph)
        self.timer.start(config['graph_step'])  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
        shortcuts = [
            (Qt.Key_F1, self.toggle_visibility),
            (Qt.Key_F2, self.create_new_graph_window),
            (Qt.Key_F3, self.revers_checks),
            (Qt.Key_F4, self.clear_all_checks),
        ]
        for key, function in shortcuts:
            shortcut = QShortcut(QKeySequence(key), self)
            shortcut.activated.connect(function)
        self.resize_to_quarter_screen()
        keyboard.add_hotkey('PrtScn', self.print_screen)
        self.graphwidget.getAxis('left').setStyle(tickFont=QFont('Arial', 12))

    def clear_all_checks(self):
        for sensor, action in self.actions.items():
            if action.isChecked():
                action.setChecked(False)
                self.toggle_sensor(False, sensor)

    def revers_checks(self):
        for sensor, action in self.actions.items():
            action.setChecked(not action.isChecked())
            self.toggle_sensor(action.isChecked(), sensor)

    def print_screen(self):
        os.makedirs(os.path.dirname(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/'), exist_ok=True)
        self.grab().save(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/' + time.strftime(config['format_time'],
                                                                                              time.localtime()) + '_' + self.windowTitle() + ".jpg")

    def resize_to_quarter_screen(self):
        desktop = QApplication.desktop()
        screen_rect = desktop.screenGeometry()
        width = screen_rect.width() // 2
        height = screen_rect.height() // 2
        self.setGeometry(screen_rect.x(), screen_rect.y(), width, height)

    def toggle_visibility(self):
        # –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–ª–∞–≥–∞ Qt.FramelessWindowHint
        is_frameless = not (self.windowFlags() & Qt.FramelessWindowHint)

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–ª–∏ —É–±–∏—Ä–∞–µ–º —Ñ–ª–∞–≥–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–Ω–∞—á–µ–Ω–∏—è is_frameless
        self.setWindowFlag(Qt.FramelessWindowHint, is_frameless)
        self.setWindowFlag(Qt.WindowStaysOnTopHint, is_frameless)

        # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∏–ª–∏ —Å–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–Ω–∞—á–µ–Ω–∏—è is_frameless
        self.menuBar().setVisible(not is_frameless)

        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ
        self.show()

    def create_new_graph_window(self):
        window_name = "–ì—Ä–∞—Ñ–∏–∫"
        window_number = 1
        while True:
            var_name = f"{window_name}_{window_number}"
            if var_name not in globals():
                break
            window_number += 1
        graph_window = GraphWindow()
        graph_window.setWindowTitle(var_name)
        globals()[var_name] = graph_window
        graph_window_thread = threading.Thread(target=graph_window.show())
        graph_window_thread.start()

    def toggle_sensor(self, checked, sensor):
        # –ò–∑–º–µ–Ω–µ–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –¥–∞—Ç—á–∏–∫–∞ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ
        sensor_name = sensor.name if hasattr(sensor, 'name') else sensor
        self.curves[sensor].setVisible(checked)
        self.text_items[sensor].setVisible(checked)
        (self.list_name.remove if not checked else self.list_name.append)(sensor_name)
        self.graphwidget.setLabel('left', '    '.join(map(str, self.list_name)))

    def update_graph(self):
        max_points = config['graph_point']
        current_time = time.time()
        current_time_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.graphwidget.getAxis('bottom').setLabel(
            f'<span style="font-size: 14px;">{current_time_str}</span>')

        def update_data(sensor, new_value):
            self.data[sensor]['x'].append(current_time)
            self.data[sensor]['y'].append(new_value)

            if len(self.data[sensor]['x']) > max_points:
                self.data[sensor]['x'] = self.data[sensor]['x'][-max_points:]
                self.data[sensor]['y'] = self.data[sensor]['y'][-max_points:]

            x_vals = self.data[sensor]['x']
            y_vals = [val if val is not None else np.nan for val in self.data[sensor]['y']]
            self.curves[sensor].setData(x_vals, y_vals)
            last_value = self.data[sensor]['y'][-1]
            sensor_name = getattr(sensor, 'name', str(sensor))
            self.text_items[sensor].setText(f'{last_value:.3f}  {sensor_name}')
            self.text_items[sensor].setPos(self.data[sensor]['x'][-1], last_value)

        def setup_impuls_data(sensor_name):
            action = QAction(str(sensor_name), self)
            action.setChecked(True)
            action.setCheckable(True)
            action.triggered.connect(lambda checked, sensor=sensor_name: self.toggle_sensor(checked, sensor))
            self.menu.addAction(action)
            self.actions[sensor_name] = action
            self.data[sensor_name] = {'x': [], 'y': []}
            self.curves[sensor_name] = self.graphwidget.plot(
                self.data[sensor_name]['x'],
                self.data[sensor_name]['y'],
                pen=pg.mkPen(color=pg.intColor(random.randint(0, 255 * 255 * 255)), width=2)
            )
            self.text_items[sensor_name] = TextItem('', anchor=(0.5, 0))
            self.text_items[sensor_name].setFont(QFont('Arial', 11))
            self.graphwidget.addItem(self.text_items[sensor_name])
            self.list_name.append(sensor_name)

        if GraphWindow.data_for_graph:
            flat_datas = [item for sublist in GraphWindow.data_for_graph for item in sublist]
        else:
            flat_datas = []
        for sensor in self.sensor_data:
            value = GraphWindow.data_for_graph.get((sensor.reg, sensor.ch), None)
            if value is None:
                continue
            try:
                new_value = float(f"{value:.3f}")
                update_data(sensor, new_value)
            except Exception:
                pass
        for i, (name, formuls) in enumerate(zip(self.name_formuls, self.formuls)):
            new_value = float(f"{GraphWindow.formuls[i]:.3f}")
            update_data(name, new_value)
        for n, imp in self.all_impuls.items():
            new_value = float(imp)
            if n not in self.data:
                setup_impuls_data(n)
            update_data(n, new_value)


class SetPointWindow(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.resizing = False
        self.setMouseTracking(True)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)
        self.setWindowTitle("–£—Å—Ç–∞–≤–∫–∏")
        #  self.setMinimumSize(400, 200)
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(4, 4, 4, 4)
        self.main_layout.setSpacing(2)

        # üî≤ –∫–∞—Å—Ç–æ–º–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
        self.title_bar = QWidget()
        self.title_layout = QHBoxLayout(self.title_bar)
        self.title_layout.setContentsMargins(0, 0, 0, 0)

        self.title_label = QLabel("–£—Å—Ç–∞–≤–∫–∏")
        self.title_label.setFont(QFont("Arial", 12))

        btn_toggle = QPushButton("‚öô")
        btn_toggle.setFixedSize(25, 25)
        btn_toggle.clicked.connect(lambda: self.toggle_control_panel(not self.zoom_slider.isVisible()))

        btn_min = QPushButton("‚àí")
        btn_min.setFixedSize(25, 25)
        btn_min.clicked.connect(self.showMinimized)

        btn_close = QPushButton("√ó")
        btn_close.setFixedSize(25, 25)
        btn_close.clicked.connect(self.close)

        self.title_layout.addWidget(self.title_label)
        self.title_layout.addStretch()
        self.title_layout.addWidget(btn_toggle)
        self.title_layout.addWidget(btn_min)
        self.title_layout.addWidget(btn_close)
        self.main_layout.addWidget(self.title_bar)

        # üîÅ –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —É—Å—Ç–∞–≤–æ–∫
        self.container = QWidget()
        self.container.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)

        self.container_layout = QVBoxLayout(self.container)
        self.container_layout.setContentsMargins(2, 2, 2, 2)
        self.container_layout.setSpacing(2)
        self.container_layout.setSizeConstraint(QLayout.SetMinimumSize)

        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setWidget(self.container)
        self.scroll.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        #  self.scroll.setMinimumHeight(150)
        self.main_layout.addWidget(self.scroll)

        self.set_points = []
        self.index_counter = 0

        for i in range(config['pack']):
            self.add_set_point()

        # üîß –ú–∞—Å—à—Ç–∞–±
        self.zoom_slider = QSlider(Qt.Horizontal)
        self.zoom_slider.setRange(-30, 70)
        self.zoom_slider.setValue(0)
        self.zoom_slider.setTickInterval(5)
        self.zoom_slider.setTickPosition(QSlider.TicksBelow)
        self.zoom_slider.valueChanged.connect(self.update_setpoint_scale)
        self.main_layout.addWidget(self.zoom_slider)

        # ‚ûï‚ûñ
        self.btn_add = QPushButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å —É—Å—Ç–∞–≤–∫—É")
        self.btn_del = QPushButton("‚ûñ –£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é")
        self.btn_add.clicked.connect(self.add_set_point)
        self.btn_del.clicked.connect(self.remove_set_point)
        self.btn_add.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        self.btn_del.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        self.main_layout.addWidget(self.btn_add)
        self.main_layout.addWidget(self.btn_del)

    def mousePressEvent(self, event):
        margin = 6
        if event.button() == Qt.LeftButton:
            if self.is_near_bottom_right(event.pos(), margin):
                self.resizing = True
                self.drag_position = event.globalPos()
                self.original_size = self.size()
            else:
                self.moving = True
                self.drag_position = event.globalPos() - self.frameGeometry().topLeft()

    def mouseMoveEvent(self, event):
        if self.resizing:
            delta = event.globalPos() - self.drag_position
            new_width = max(self.minimumWidth(), self.original_size.width() + delta.x())
            new_height = max(self.minimumHeight(), self.original_size.height() + delta.y())
            self.resize(new_width, new_height)
        elif getattr(self, 'moving', False) and event.buttons() == Qt.LeftButton:
            self.move(event.globalPos() - self.drag_position)
        else:
            if self.is_near_bottom_right(event.pos(), 6):
                if self.cursor().shape() != Qt.SizeFDiagCursor:
                    self.setCursor(Qt.SizeFDiagCursor)
            else:
                if self.cursor().shape() != Qt.ArrowCursor:
                    self.setCursor(Qt.ArrowCursor)

    def mouseReleaseEvent(self, event):
        self.resizing = False
        self.moving = False

    def is_near_bottom_right(self, pos, margin):
        return (
                abs(pos.x() - self.width()) <= margin and
                abs(pos.y() - self.height()) <= margin
        )

    def toggle_control_panel(self, visible: bool):
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–ª–∏ —Å–∫—Ä—ã–≤–∞–µ—Ç –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        for widget in [self.zoom_slider, self.btn_add, self.btn_del]:
            widget.setVisible(visible)

    def update_setpoint_scale(self, value):
        for sp in self.set_points:
            if hasattr(sp, "setFont"):  # –≤–¥—Ä—É–≥ –±—ã–ª —É–¥–∞–ª—ë–Ω
                sp.scaletext(value)

    def scaletext(self, value):
        try:
            value = int(value)
        except ValueError:
            value = 0

        value = max(-10, min(value, 50))
        font_size = 10 + value
        font = QFont('Arial', font_size)
        for w in self.findChildren(QWidget):
            w.setFont(font)

    #  self.setMinimumHeight(50 + value * 2)

    def add_set_point(self):
        sp = Set_point(self.parent(), self.index_counter)
        self.container_layout.addWidget(sp)
        self.set_points.append(sp)
        self.index_counter += 1

    def remove_set_point(self):
        if not self.set_points:
            return

        sp = self.set_points.pop()

        sp.alive = False  # üß† —Å–∏–≥–Ω–∞–ª –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤: –æ–±—ä–µ–∫—Ç —É–Ω–∏—á—Ç–æ–∂–∞–µ—Ç—Å—è

        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º square_widget
        if hasattr(sp, "square_widget"):
            sp.square_widget.alive = False
            sp.square_widget.setParent(None)
            sp.square_widget.deleteLater()

        # –£–¥–∞–ª—è–µ–º —Å–∞–º –≤–∏–¥–∂–µ—Ç —É—Å—Ç–∞–≤–∫–∏
        sp.setParent(None)
        sp.deleteLater()

        self.index_counter -= 1


class MainShem(QMainWindow, File_formatter):
    update_sensor_value = pyqtSignal(str, float)  # —Å–∏–≥–Ω–∞–ª: –∏–º—è —Å–µ–Ω—Å–æ—Ä–∞ –∏ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ

    def __init__(self, parent=None):
        super(MainShem, self).__init__(parent)
        self.update_sensor_value.connect(self.on_update_sensor_value)
        self.timestart_lock = threading.Lock()
        self.do_things()  # ‚Üê 1. –≤—ã–∑—ã–≤–∞–µ–º —Å—Ä–∞–∑—É –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
        self.showFullScreen()
        self.first = True
        self.labelimg = QLabel(self)
        self.pixmap = QPixmap(config['IMG'])
        self.labelimg.setPixmap(self.pixmap)
        self.labelimg.setScaledContents(True)
        self.labelimg.setPixmap(self.pixmap.scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
        self.opacity_effect = QGraphicsOpacityEffect()
        self.labelimg.setGraphicsEffect(self.opacity_effect)
        self.labelimg.setGeometry(25, 25, int(self.width() - 50), int(self.height() - 50))
        self.labelimg.show()

        self.ourch = self.read_file(config['setting'])
        self.sensor_by_name = {s.name: s for s in self.ourch}

        self.ourch_split = defaultdict(list)
        for sensor in self.ourch:
            self.ourch_split[sensor.reg].append(sensor)
            sensor.scaletext(config['sensor_size'])
        self.sensor_by_key = {}
        for sensor in self.ourch:
            self.sensor_by_key[(sensor.reg, sensor.ch)] = sensor

        self.timermup = QTimer()
        self.formuls_math = [fd.mathematics.replace('sqrt', 'cmath.sqrt') for fd in self.formuls]
        self.formuls_math = [fd.mathematics.replace('log', 'cmath.log') for fd in self.formuls]
        self.timermup.timeout.connect(lambda: self.update_label(self.formuls_math))
        self.timermup.start(100)

        self.texttime = QWidget(self)
        w = config.get("textbox_w", 500)
        h = config.get("textbox_h", 180)
        self.texttime.setFixedSize(w, h)

        self.layout = QHBoxLayout()

        stl = "border: 2px solid black;border-radius: 10px;background-color:rgb(213,199,182)"
        self.Time = QLabel()
        self.Time.setGeometry(0, 0, 150, 100)
        self.Time.setFont(QFont('Arial', 30))
        self.Time.setStyleSheet(stl)
        self.layout.addWidget(self.Time)

        self.button = QPushButton('+')
        self.button.clicked.connect(self.Sensoradd)

        self.button.setStyleSheet(stl)
        self.button.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        self.layout.addWidget(self.button)

        self.input = QTextEdit(self)
        self.input.setFont(QFont('Arial', 24))
        self.input.setStyleSheet(stl)
        self.layout.addWidget(self.input)

        self.input.textChanged.connect(self.text_changed)
        self.timerfile = QTimer(self)
        self.timerfile.setSingleShot(True)
        self.timerfile.timeout.connect(self.input.clearFocus)

        self.texttime.setLayout(self.layout)
        self.texttime.show()
        self.old_pos = None

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.showTime)
        self.timer.start()

        self.checkBox = QCheckBox()
        self.checkBox.stateChanged.connect(self.on_checkbox_changed)
        self.layout.addWidget(self.checkBox)

        self.timerfile = QTimer()
        self.timerfile.timeout.connect(self.do_things)
        self.timerfile.start(3600000)

        top_right_point = QApplication.desktop().availableGeometry().topRight()

        self.reboot = QPushButton(self)
        self.reboot.setGeometry(555, 555, 25, 25)
        self.reboot.move(top_right_point / 1.0525)
        self.reboot.clicked.connect(self.rebo)
        self.reboot.setText('‚Üª')
        self.reboot.setFont(QFont('Arial', 16))
        self.reboot.show()

        self.exit = QPushButton(self)
        self.exit.setGeometry(555, 555, 25, 25)
        self.exit.move(top_right_point / 1.015)
        self.exit.clicked.connect(self.close_event)
        self.exit.setText('X')
        self.exit.setFont(QFont('Arial', 14))
        self.exit.show()

        self.full = QPushButton(self)
        self.full.setGeometry(555, 555, 25, 25)
        self.full.move(top_right_point / 1.0275)
        self.full.clicked.connect(self.full_roll)
        self.full.setFont(QFont('Arial', 16))
        self.full.setText('‚ùí')
        self.full.show()

        self.roll = QPushButton(self)
        self.roll.setGeometry(555, 555, 25, 25)
        self.roll.move(top_right_point / 1.04)
        self.roll.clicked.connect(self.showMinimized)
        self.roll.setText('_')
        self.roll.show()
        keyboard.add_hotkey('PrtScn', self.print_screen)
        self.out = []

        self.set_window = SetPointWindow(self)
        self.set_window.setWindowModality(Qt.NonModal)  # ‚Üê —ç—Ç–æ –≤–∞–∂–Ω–æ
        self.set_window.show()
        main_geom = self.geometry()
        set_geom = self.set_window.frameGeometry()

        x = main_geom.x() + (main_geom.width() - set_geom.width()) // 2
        y = main_geom.y() + main_geom.height() - set_geom.height() - 10  # –æ—Ç—Å—Ç—É–ø 10px –æ—Ç –Ω–∏–∑–∞

        self.set_window.move(x, y)
        QTimer.singleShot(1000, self.setup_network)

        self.damper_timer = QTimer(self)
        self.damper_timer.timeout.connect(self.update_all_dampers)
        self.damper_timer.start(200)

    #  for w in self.findChildren(QWidget):
    #      rect = w.geometry()
    #      if "QWidget" in str(type(w)) and rect.width() > 100 and rect.y() > 700:
    #          print(f"[FOUND] QWidget at {rect} ‚Üí", w)
    #          w.setStyleSheet("background: rgba(255, 0, 0, 40); border: 2px dashed red;")
    #          import traceback
    #          print("[CREATED SQUARE]", traceback.format_stack())

    #  for child in self.findChildren(QWidget):
    #      if hasattr(child, 'name'):
    #          continue  # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–æ—Ä–º–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã (sensor, damper...)

    #      g = child.geometry()
    #      label = QLabel(f"{type(child).__name__} @ {g.x()},{g.y()} {g.width()}x{g.height()}", child)
    #      label.setStyleSheet("color: red; background: rgba(255,255,255,200); font-size: 10px;")
    #      label.move(5, 5)
    #      label.show()

    #      child.setStyleSheet("background: rgba(0, 0, 255, 20); border: 1px dashed blue;")

    def update_all_dampers(self):
        for damper in self.dampers_list:
            damper.update_lab_color()

    def setup_network(self):
        try:
            self.sendol = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sendol.connect((config["ip"], config["port"]))
            print("[setup_network] Connected")
        except Exception as e:
            print(f"[setup_network ERROR] {e}")
            self.sendol = None

    def text_changed(self):
        self.timerfile.start(36000)

    def add_sensor(self, name, ch, clr, side, bit_depth, reg, amendment, pos):
        sensor = Sensor(name, ch, clr, side, bit_depth, reg, amendment, self)
        sensor.move(*pos)
        sensor.show()
        self.ourch.append(sensor)

        # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        self.sensor_by_name[name] = sensor
        self.sensor_by_key[(sensor.reg, sensor.ch)] = sensor
        self.ourch_split[sensor.reg].append(sensor)

    def rebo(self, event):
        reply = QMessageBox.question(self, 'Message',
                                     "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å?", QMessageBox.Yes |
                                     QMessageBox.No, QMessageBox.No)
        self.reboots() if reply == QMessageBox.Yes else event.ignore()

    def close_event(self, event):
        reply = QMessageBox.question(self, 'Message',
                                     "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–π—Ç–∏?", QMessageBox.Yes |
                                     QMessageBox.No, QMessageBox.No)
        os._exit(1) if reply == QMessageBox.Yes else event.ignore()

    def remove_sensor(self, name: str):
        sensor = self.sensor_by_name.get(name)
        if not sensor:
            print(f"[–£–¥–∞–ª–µ–Ω–∏–µ] –î–∞—Ç—á–∏–∫ {name} –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return

        key = (sensor.reg, sensor.ch)

        # –£–¥–∞–ª—è–µ–º –≤–∏–¥–∂–µ—Ç
        sensor.hide()
        sensor.setParent(None)

        # –£–¥–∞–ª—è–µ–º –∏–∑ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö —Å–ø–∏—Å–∫–æ–≤
        self.ourch.remove(sensor)
        self.sensor_by_key.pop(key, None)
        self.ourch_split[sensor.reg].remove(sensor)
        self.sensor_by_name.pop(name, None)

        print(f"[–£–¥–∞–ª–µ–Ω–∏–µ] –î–∞—Ç—á–∏–∫ {name} —É–¥–∞–ª—ë–Ω –∏–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞")

    def full_roll(self):
        if self.isFullScreen():
            self.showNormal()
            self.showMaximized()
        else:
            self.showFullScreen()

    def do_things(self):
        with self.timestart_lock:
            self.timestart = time.strftime(config['format_time'], time.localtime())

    def on_checkbox_changed(self, value):
        for item in [self.ourch, self.dampers_list, self.formuls, self.const, self.lamps]:
            for i in range(len(item)):
                item[i].moveon = Qt.CheckState(value) == Qt.CheckState.Checked
        if Qt.CheckState(value) == Qt.CheckState.Unchecked:
            for item in [self.ourch, self.dampers_list]:
                for i in range(len(item)):
                    item[i].moveon = False
        #    self.close()
        #   QProcess.startDetached(sys.executable, sys.argv)

    def redakt(self, text):
        with fileinput.FileInput(config['setting'], inplace=True,
                                 backup='.bak') as f:
            for line in f:
                if text[:text.find(' ')] + ' ' in line:
                    def find_2nd(string, substring):
                        return string.find(
                            substring, string.find(substring) + 8)

                    if '+' in text:
                        print(line[:find_2nd(line, ' ')] +
                              ' ' +
                              text[text.find('+') +
                                   1:] +
                              line[line.find(' ('):], end='')
                    elif '-' in text:
                        print(line[:find_2nd(line, ' ')] +
                              ' ' +
                              text[text.find('-'):] +
                              line[line.find(' ('):], end='')
                else:
                    print(line, end='')
            self.close()
            QProcess.startDetached(sys.executable, sys.argv)

    def Sensoradd(self):
        s = Setting()
        s.central_widget.show()
        s.show()

    def showTime(self):
        self.Time.setText(QDateTime.currentDateTime().toString('d/M/yy\nhh:mm:ss'))

    def tofile(self, data_by_key, fd):
        """
        –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–µ–∫—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è —Å–µ–Ω—Å–æ—Ä–æ–≤ –∏ —Ñ–æ—Ä–º—É–ª –≤ CSV-–æ—Ç—á—ë—Ç.
        """

        report_path = config["IZDELIE"] + f'/report_{config["IZDELIE"]}/'
        os.makedirs(report_path, exist_ok=True)
        file_path = os.path.join(report_path, f'{self.timestart}.txt')

        try:
            ordered_sensors = sorted(self.sensor_list, key=lambda s: (s.reg, s.ch))
            sensor_names = [f'{s.name.lstrip("#")}_{s.ch + 1}_{s.reg + 1}' for s in ordered_sensors]
            sensor_values = [data_by_key.get((s.reg, s.ch), float('nan')) for s in ordered_sensors]

            self.df = pd.DataFrame([sensor_values], columns=sensor_names)
            self.df.insert(0, 'Time', datetime.now().strftime('%H:%M:%S.%f')[:-3])
            self.df.insert(0, 'Data', datetime.now().strftime('%d/%m/%y'))

            # –î–æ–±–∞–≤–ª—è–µ–º —Ñ–æ—Ä–º—É–ª—ã
            for i, formula in enumerate(self.formuls):
                try:
                    value = float(fd[i])
                    formatted = f"{value:.{formula.bit_depth}f}"
                except (ValueError, TypeError, IndexError):
                    formatted = "nan"
                self.df[formula.name] = formatted

            numeric_columns = self.df.select_dtypes(include=[np.number]).columns
            self.df[numeric_columns] = self.df[numeric_columns].astype('float32')

            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            write_header = not os.path.isfile(file_path)

            self.df.to_csv(
                file_path,
                mode='a',
                sep=';',
                index=False,
                header=write_header,
                float_format='%.4f',
                decimal=','
            )

        except Exception as e:
            print(f"[report] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –æ—Ç—á—ë—Ç–∞: {e}")
            self.do_things()

    def update_label(self, copy_formuls):
        QTimer.singleShot(0, lambda: self._process_update(copy_formuls.copy()))

    # self.calculate_formulas([f.mathematics.replace('sqrt', 'cmath.sqrt') for f in self.formuls])

    def _process_update(self, formuls):
        try:
            raw_data = self._fetch_data()
            data_by_key = {}
            for reg_index, data_group in enumerate(raw_data):
                sensors = self.ourch_split.get(reg_index, [])
                for sensor, value in zip(sensors, data_group):
                    data_by_key[(sensor.reg, sensor.ch)] = value

            self._distribute_data(data_by_key)
            fd = self._update_ui_and_formulas(data_by_key, formuls)
            self._finalize_output(data_by_key, fd)

        except Exception as e:
            print(f"[update_label error] {e}")
            warning_window(str(e))

    def _fetch_data(self):
        if config['imitation']:
            return [[box.value() for box in self.spin_boxes]]
        else:
            return fetch_live_data()

    def _distribute_data(self, data):
        GraphWindow.data_for_graph = \
            Timers.sensor_data = \
            Set_point.sensor_data = \
            Damper.sensor_data = \
            Furnace.sensor_data = data

    def _update_ui_and_formulas(self, data, formuls):
        self.update_sensor_data(data, formuls)
        fd = self.calculate_formulas()
        return fd

    def _finalize_output(self, data, fd):
        if not config['imitation']:
            self.tofile(data, fd)
            ServerSocket.data = data

    # end_time = time.time()
    # execution_time = end_time - start_time
    # print(f"update_lable: {execution_time} —Å–µ–∫—É–Ω–¥")
    @pyqtSlot(str, float)
    def on_update_sensor_value(self, sensor_name):
        sensor = self.sensor_by_name.get(sensor_name)
        if sensor:
            value = self.sensor_data.get((sensor.reg, sensor.ch), float('nan'))
            sensor.l2.setText(f"{value + sensor.amendment:.{sensor.bit_depth}f}")


    def update_sensor_data(self, data_by_key, formuls):
        """
        –û–±–Ω–æ–≤–ª—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è —Å–µ–Ω—Å–æ—Ä–æ–≤ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ñ–æ—Ä–º—É–ª.

        :param data_by_key: Dict[(reg, ch)] = value
        :param formuls: —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫ —Ñ–æ—Ä–º—É–ª
        """
        updated_vars = {}

        self.sensor_data = data_by_key
        for sensor in self.ourch:
            key = (sensor.reg, sensor.ch)
            value = data_by_key.get(key, float('nan'))
            updated_vars[sensor.name] = value
            self.update_sensor_value.emit(sensor.name, value)

        # –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        GraphWindow.data_for_graph = data_by_key
        Timers.sensor_data = data_by_key
        Set_point.sensor_data = data_by_key
        Damper.sensor_data = data_by_key
        Furnace.sensor_data = data_by_key

        # –û–±–Ω–æ–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ —Ñ–æ—Ä–º—É–ª–∞—Ö (–±–µ–∑ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø–æ–∫–∞)
        from re import compile as re_compile
        rx = re_compile(r'\b[a-zA-Z_]\w*\b')
        for i in range(len(formuls)):
            formuls[i] = rx.sub(lambda m: str(updated_vars.get(m.group(), 'nan')), formuls[i])

    def calculate_formulas(self, _=None):
        try:
            variable_map = self._build_variable_map()

            def prepare_expression(expr: str):
                # 1. —Å–Ω–∞—á–∞–ª–∞ –∑–∞–º–µ–Ω–∏–º math-—Ñ—É–Ω–∫—Ü–∏–∏
                math_funcs = [
                    'sqrt', 'log', 'exp',
                    'sin', 'cos', 'tan',
                    'asin', 'acos', 'atan',
                    'sinh', 'cosh', 'tanh'
                ]
                for func in math_funcs:
                    expr = re.sub(rf'\b{func}\s*\(', f'cmath.{func}(', expr)

                # 2. –∑–∞—Ç–µ–º ‚Äî –ø–æ–¥—Å—Ç–∞–≤–∏–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (–≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏)
                for key, val in variable_map.items():
                    if val is None:
                        val = float('nan')
                    pattern = re.compile(r'\b{}\b'.format(re.escape(key)))
                    expr = pattern.sub(str(val), expr)

                return expr

            aeval = Interpreter(usersyms={
                "cmath": __import__('cmath'),
                "math": __import__('math')
            }, minimal=True)

            length = len(self.formuls)
            GraphWindow.formuls = [float('nan')] * length
            Timers.formuls = [float('nan')] * length
            Set_point.formuls = [float('nan')] * length

            results = []
            for i, f in enumerate(self.formuls):
                expression = prepare_expression(f.mathematics)
                try:
                    result = aeval(expression)
                    if isinstance(result, complex):
                        if result.imag == 0:
                            result = result.real
                        else:
                            raise ValueError(f"Complex result with imaginary part: {result}")

                    if (
                            result is None or
                            not isinstance(result, (int, float)) or
                            math.isnan(result) or
                            math.isinf(result)
                    ):
                        raise ValueError("Bad result")

                    rounded = round(float(result), f.bit_depth)

                except Exception as e:
                    print(f"[FORMULA] {f.name}: {f.mathematics} = {result}")
                    print(f"[FORMULA ERROR] {f.name}: {e}")
                    rounded = float('nan')
                    with open('formula_errors.log', 'a') as log:
                        log.write(f"[{datetime.now()}] {f.name}: {expression} :: {e}\n")

                f.l2.setText(f"{rounded}")
                GraphWindow.formuls[i] = rounded
                Timers.formuls[i] = rounded
                Set_point.formuls[i] = rounded
                variable_map[f.name] = rounded
                results.append(rounded)

            return results

        except Exception as e:
            print('[calculate_formulas]', e)
            warning_window(f'–û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º—É–ª–∞—Ö: {e}', False)

    def _build_variable_map(self):
        variables = {}
        for sensor in self.ourch:
            value = Damper.sensor_data.get((sensor.reg, sensor.ch), float('nan'))
            variables[sensor.name] = value
        for const in self.const:
            variables[const.name] = const.const
        return variables

    def _prepare_expression(self, formula: str, variable_map: dict):
        # –ó–∞–º–µ–Ω—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è, –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è .replace()
        pattern = re.compile(r'\b[a-zA-Z_]\w*\b')
        return pattern.sub(lambda match: str(variable_map.get(match.group(), 'nan')), formula)

    def _evaluate_expression(self, expr: str):
        """
        –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–∞—Å—á–µ—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é asteval.
        –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç math-—Ñ—É–Ω–∫—Ü–∏–∏ –∏ cmath.

        :param expr: —Å—Ç—Ä–æ–∫–∞ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
        :return: —á–∏—Å–ª–æ–≤–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç (float)
        """
        aeval = Interpreter(usersyms={"cmath": __import__('cmath'), "math": __import__('math')}, minimal=True)
        result = aeval(expr)
        if aeval.error:
            raise ValueError(f"[FORMULA ERROR] {aeval.error[0].get_error()}")
        return float(result)

    def create_damper(self, setting_row):
        """
        –°–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç –∑–∞—Å–ª–æ–Ω–∫–∏ –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ –∑–∞—Å–ª–æ–Ω–æ–∫.

        Args:
            setting_row (list): –°–ø–∏—Å–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞—Å–ª–æ–Ω–∫–∏.
            move (list): –°–ø–∏—Å–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è.

        Returns:
            None
        """
        # –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —Å–ø–∏—Å–∫–æ–≤
        name, pos, chdo1, chdo2, chdi1, chdi2, pos_auto, reg, pos_x, pos_y = setting_row
        print(name, pos, chdo1, chdo2, chdi1, chdi2, pos_auto, reg, pos_x, pos_y)
        DAMPER_WIDTH = 150
        DAMPER_WIDTH_V = 65
        DAMPER_HEIGHT = 70
        DAMPER_HEIGHT_V = 110
        damper = Damper(name, pos, int(chdo1), int(chdo2), int(chdi1), int(chdi2), pos_auto, int(reg), self)
        self.dampers_list.append(damper)

        if pos == 'V':
            damper_height = DAMPER_HEIGHT_V
            damper_width = DAMPER_WIDTH_V
        else:
            damper_height = DAMPER_HEIGHT
            damper_width = DAMPER_WIDTH
        damper_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": damper_width,
            "height": damper_height
        }
        if '#' in name:
            return
        self.show_element(damper, damper_data)

    def create_translate(self, row_translate):
        """
        –°–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç –ø–µ—Ä–µ–∫–ª–∞–¥–∫–∏ –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ –ø–µ—Ä–µ–∫–ª–∞–¥–æ–∫.

        Args:
            row_translate (list[str]): –°–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–µ—Ä–µ–∫–ª–∞–¥–∫–∏.

        Returns:
            None

        """
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–ª–æ–≤
        dampers, damper1_sleep, damper2_sleep, time, x, y = row_translate
        damper1, damper2 = dampers.split('~')
        translate = Translate(damper1, damper2, self.dampers_list, damper1_sleep, damper2_sleep, time, self)
        self.translate_list.append(translate)
        if '#' in row_translate:
            return
        translate.move(int(x), int(y))
        translate.show()

    def create_furnace(self, row_furnace):
        """
           –°–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç –ø–µ—á–∏ –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ –ø–µ—á–µ–π.

           Args:
               row_furnace (list[str]): –°—Ç—Ä–æ–∫–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–µ—á–∏.

           Returns:
               None
           """
        furn, name, ch_ae, diapason, reg, x, y = row_furnace
        furnace = Furnace(name, int(ch_ae), float(diapason), int(reg), x, y, self)  # Furn F2 3 20 1
        self.furnace_list.append(furnace)
        if '#Furn' in row_furnace:
            return
        furnace.move(int(x), int(y))
        furnace.show()

    def create_const(self, math_config):
        """
        –°–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ñ–æ—Ä–º—É–ª—ã –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º—É–ª.

        Args:
            math_config (list): –°–ø–∏—Å–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ñ–æ—Ä–º—É–ª—ã.

        Returns:
            None
        """
        MATH_WIDTH = 120
        MATH_HEIGHT = 60

        # –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —Å–ø–∏—Å–∫–∞ math_config
        const_type, name, const, color, side_name, unit, pos_x, pos_y, *extra_params = math_config

        # –°–æ–∑–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ñ–æ—Ä–º—É–ª—ã
        math_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": MATH_WIDTH,
            "height": MATH_HEIGHT
        }

        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç —Ñ–æ—Ä–º—É–ª—ã
        math_const = Const(name, const, color, side_name, int(unit))

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π —ç–ª–µ–º–µ–Ω—Ç
        math_const.setParent(self)

        # –î–æ–±–∞–≤–ª—è–µ–º —Ñ–æ—Ä–º—É–ª—É –≤ —Å–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º—É–ª
        self.const.append(math_const)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–∏–º–≤–æ–ª '#' –≤ –∏–º–µ–Ω–∏, –∏ –µ—Å–ª–∏ –µ—Å—Ç—å, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        if '#' in name:
            return

        # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ñ–æ—Ä–º—É–ª—É
        self.show_element(math_const, math_data)

    def create_math(self, math_config):
        """
        –°–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ñ–æ—Ä–º—É–ª—ã –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º—É–ª.

        Args:
            math_config (list): –°–ø–∏—Å–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ñ–æ—Ä–º—É–ª—ã.

        Returns:
            None
        """
        MATH_WIDTH = 120
        MATH_HEIGHT = 60

        # –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —Å–ø–∏—Å–∫–∞ math_config
        math_type, name, formula, color, side_name, unit, pos_x, pos_y, *extra_params = math_config

        # –°–æ–∑–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ñ–æ—Ä–º—É–ª—ã
        math_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": MATH_WIDTH,
            "height": MATH_HEIGHT
        }

        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç —Ñ–æ—Ä–º—É–ª—ã
        math_formula = Formula(name, formula, color, side_name, int(unit))

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π —ç–ª–µ–º–µ–Ω—Ç
        math_formula.setParent(self)

        # –î–æ–±–∞–≤–ª—è–µ–º —Ñ–æ—Ä–º—É–ª—É –≤ —Å–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º—É–ª
        self.formuls.append(math_formula)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–∏–º–≤–æ–ª '#' –≤ –∏–º–µ–Ω–∏, –∏ –µ—Å–ª–∏ –µ—Å—Ç—å, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        if '#' in name:
            return

        # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ñ–æ—Ä–º—É–ª—É
        self.show_element(math_formula, math_data)

    def create_sensor(self, row_config):
        """
        –°–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç —Å–µ–Ω—Å–æ—Ä–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ —Å–µ–Ω—Å–æ—Ä–æ–≤.

        Args:
            row_config (list[str]): –°—Ç—Ä–æ–∫–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ–Ω—Å–æ—Ä–∞.

        Returns:
            None
        """
        SENSOR_WIDTH = 120
        SENSOR_HEIGHT = 60
        name, channel, color, side_name, unit, reg, fix, pos_x, pos_y, *extra_params = row_config
        sensor_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": SENSOR_WIDTH,
            "height": SENSOR_HEIGHT
        }
        sensor = Sensor(name, int(channel), color, side_name, int(unit), int(reg), float(fix), self)
        self.sensor_list.append(sensor)
        if '#' in name:
            return
        self.show_element(sensor, sensor_data)

    def show_element(self, element, element_data):
        """
        –û–±—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–∞–∑–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.

        Args:
            element: –û–±—ä–µ–∫—Ç —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∑–∞—Å–ª–æ–Ω–∫–∞, —Å–µ–Ω—Å–æ—Ä, –∏ —Ç.–¥.).
            element_data: –î–∞–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç–∞, —Ç–∞–∫–∏–µ –∫–∞–∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ —Ä–∞–∑–º–µ—Ä.

        Returns:
            None
        """
        # –õ–æ–≥–∏–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞
        element.setGeometry(element_data["x"], element_data["y"], element_data["width"], element_data["height"])
        element.show()

    def read_file(self, setting_row):
        """
        –ß—Ç–µ–Ω–∏–µ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.

        Args:
            setting_row (str): –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.

        Returns:
            list: –°–ø–∏—Å–æ–∫ —Å–µ–Ω—Å–æ—Ä–æ–≤, —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ñ–∞–π–ª–∞.
        """
        config['setting_file'] = setting_row
        # –°–ª–æ–≤–∞—Ä—å, —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è—é—â–∏–π –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏
        KEYWORDS_MAP = {
            "zu": self.create_damper,
            "ru": self.create_damper,
            "ruru": self.create_translate,
            "furn": self.create_furnace,
            "math": self.create_math,
            'const': self.create_const
        }

        # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –ø—Ä–æ–ø—É—â–µ–Ω—ã –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞
        SKIP_KEYWORDS = ['##', '=']
        self.extract_text_between_grids(2, 3, 5)
        try:
            self.sensor_list = []  # –°–ø–∏—Å–æ–∫ —Å–µ–Ω—Å–æ—Ä–æ–≤
            self.dampers_list = []  # –°–ø–∏—Å–æ–∫ –∑–∞—Å–ª–æ–Ω–æ–∫
            self.translate_list = []  # –°–ø–∏—Å–æ–∫ –ø–µ—Ä–µ–∫–ª–∞–¥–æ–∫
            self.furnace_list = []  # –°–ø–∏—Å–æ–∫ –ø–µ—á–µ–π
            self.formuls = []  # –°–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º—É–ª
            self.const = []
            self.lamps = []

            for row_config in self.rw_lines('r'):
                if row_config.strip() == "" or any(x in row_config for x in SKIP_KEYWORDS):
                    continue
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç—Ä–æ–∫—É –∫–∞–∫ –µ—Å—Ç—å
                original_row = row_config.strip()

                # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ—Ç–¥–µ–ª—å–Ω–æ
                pos_match = re.search(r'\((\d+)\s+(\d+)\)', original_row)
                coords = (int(pos_match[1]), int(pos_match[2])) if pos_match else (0, 0)

                # –£–±–∏—Ä–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏, –æ—Å—Ç–∞–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º (–≤–∫–ª—é—á–∞—è —Å–∫–æ–±–∫–∏ –≤ —Ñ–æ—Ä–º—É–ª–∞—Ö!)
                row_wo_coords = re.sub(r'\(\d+\s+\d+\)', '', original_row).strip()
                row_config = row_wo_coords.split()
                row_config.extend(map(str, coords))  # –¥–æ–±–∞–≤–∏–º x –∏ y –∫–∞–∫ –¥–≤–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–∞

                keyword = re.match(r'[a-zA-Z]+', row_config[0])
                keyword = keyword.group(0).lower() if keyword else ''
                if keyword == 'lamp':
                    try:
                        name = row_config[1]
                        reg = int(row_config[2])
                        ch = int(row_config[3])
                        x = int(row_config[-2])
                        y = int(row_config[-1])

                        lamp = IndicatorLamp(name, reg, ch, parent=self)
                        lamp.name = name
                        lamp.move(x, y)
                        lamp.show()
                        lamp.raise_()
                        self.lamps.append(lamp)
                    except Exception as e:
                        print(f"[LAMP ERROR] {row_config}: {e}")
                    continue

                try:
                    # row_config[-3] ‚Äî —ç—Ç–æ –ø–æ–∑–∏—Ü–∏—è 'reg' –ø–µ—Ä–µ–¥ x y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
                    if keyword in ['ru', 'dd', 'da']:  # ‚Üê —Ç–æ–ª—å–∫–æ –¥–ª—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤
                        if len(row_config) >= 3 and row_config[-3].isdigit():
                            reg = int(row_config[-3]) - 1
                            if reg < 0 or reg >= len(config.get("IPS", {})):
                                print(f"[SKIP] –ü—Ä–æ–ø—É—Å–∫ —Å—Ç—Ä–æ–∫–∏ —Å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º reg={reg + 1}: {' '.join(row_config)}")
                                continue

                except Exception as e:
                    print(f"[reg-check error] {row_config}: {e}")
                    continue
                KEYWORDS_MAP[keyword](row_config) if keyword in KEYWORDS_MAP else self.create_sensor(row_config)
            GraphWindow.name_formuls = [i.name for i in self.formuls]
            Timers.name_formuls = [i.name for i in self.formuls]
            self.const_names = [obj.name for obj in self.const]
            return self.sensor_list
        except Exception as error:
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –≤—ã–≤–æ–¥ –æ—à–∏–±–∫–∏, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫
            warning_window(f'{row_config}\n {error} –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä')

    def print_screen(self):
        """
        –°–æ–∑–¥–∞–Ω–∏–µ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –æ–∫–Ω–∞.

        Returns:
            None
        """
        # –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤, –µ—Å–ª–∏ –µ—ë –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        os.makedirs(os.path.dirname(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/'), exist_ok=True)

        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ .jpg —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –∏–º–µ–Ω–µ–º
        self.grab().save(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/' + time.strftime(config['format_time'],
                                                                                              time.localtime()) + ".jpg")

    def reboots(self):
        """
        –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.

        –ó–∞–∫—Ä—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ –æ–∫–Ω–æ (–µ—Å–ª–∏ –æ–Ω–æ —è–≤–ª—è–µ—Ç—Å—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–º GraphWindow) –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç
        –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–Ω–æ–≤–æ.

        Returns:
            None
        """
        # –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—É—â–µ–µ –æ–∫–Ω–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–º GraphWindow
        global dlgMain

        for widget in dlgMain.app.topLevelWidgets():
            widget.close()
        # –û–±—ä—è–≤–ª–µ–Ω–∏–µ, —á—Ç–æ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
        dlgMain.stop_event = threading.Event()  # Create an event object
        dlgMain.stop_event.set()  # Set the flag to signal stop
        dlgMain.t1.join()  # Wait for the thread to finish
        dlgMain.close()
        os.execl(sys.executable, os.path.abspath(__file__), *sys.argv)

    def get_dlg_main_ourch(self):
        return (self.ourch, self.dampers_list)

    def closeEvent(self, event):
        print("[DEBUG] closeEvent triggered")
        import os
        os._exit(0)

    def run_app(self):
        try:
            self.app = QApplication(sys.argv)
            self.show()
            self.dlg_ourch, self.dlg_dampers_list = self.get_dlg_main_ourch()
            self.t1 = threading.Thread(target=process_data_channel, args=(self.dlg_ourch, self.dlg_dampers_list))
            self.t1.start()
            # s1 = ServerSocket()
            # s1.start()
            graph_window_0 = GraphWindow()
            graph_window_0.show()
            self.algoritms = None
            """
            algoritms = Timers(parent=self)
            screen_resolution = QApplication.desktop().screenGeometry().size()
            screen_height = screen_resolution.height()
            algoritms.setGeometry(400, screen_height - 250, 400, 200)
            algoritms.hide_timer_settings()
            algoritms.show()
            """
            sleep(2)
            [damper._update_shutter_display_color() for damper in self.dlg_dampers_list]
            sys.exit(self.app.exec_())

        except Exception as e:
            print(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è: {e}')
            warning_window(e)


if __name__ == '__main__':
    import sys
    from PyQt5.QtWidgets import QApplication

    dlgMain = MainShem()
    #  sleep(1)
    dlgMain.run_app()

# -*- coding: utf-8 -*-
# import OpenOPC
# pyinstaller --onefile --windowed  main9metran.py --copy-metadata nidaqmx

# Встроенные библиотеки
import ast
import asyncio
import faulthandler
import fileinput
import io
import itertools
import math
import os
import queue
import random
import re
import socket
import struct
import subprocess
import sys
import threading
import time
import warnings
from datetime import datetime
from functools import partial
from time import sleep
from collections import defaultdict

# Третьесторонние библиотеки
import keyboard
import numpy as np
import pandas as pd
from asteval import Interpreter
from nidaqmx.constants import AcquisitionType
import nidaqmx
import nidaqmx.system
from ping3 import ping
from pyModbusTCP.client import ModbusClient
from pymodbus.client.mixin import ModbusClientMixin

# PyQt5
from PyQt5.QtCore import (
    Qt, QDateTime, QTimer, QPoint, QProcess, QRegExp, QFile, QSettings,
    pyqtSignal, QTime, QEvent, QSize, QRect, QCoreApplication, pyqtSlot
)
from PyQt5.QtGui import (
    QFont, QRegExpValidator, QPixmap, QKeySequence, QPainter, QColor, QBrush
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QLabel, QPushButton, QCheckBox, QComboBox, QDoubleSpinBox, QSpinBox, QTimeEdit, QLineEdit,
    QFileDialog, QScrollArea, QTextEdit, QInputDialog, QColorDialog,
    QSizePolicy, QDesktopWidget, QSlider, QAction, QShortcut,
    QAbstractSpinBox, QGraphicsOpacityEffect, QMessageBox, QLayout
)
import pyqtgraph as pg
from pymodbus.constants import Endian
from pymodbus.payload import BinaryPayloadDecoder
from pyqtgraph import TextItem

## Включение faulthandler
# faulthandler.enable()

# (опционально) безопасность stderr
if sys.stderr is None:
    sys.stderr = io.StringIO()


def measure_time(func):
    """
    Декоратор для измерения времени выполнения функции.
    Параметры:
    - func (function): Функция, время выполнения которой необходимо измерить.
    Возвращает:
    - function: Обернутая функция, которая выводит время выполнения и возвращает результат выполнения исходной функции.
    """

    def wrapper(*args, **kwargs):
        """
        Обертка вокруг исходной функции для измерения времени выполнения.
        Параметры:
        - *args: Позиционные аргументы для исходной функции.
        - **kwargs: Именованные аргументы для исходной функции.
        Возвращает:
        - Результат выполнения исходной функции.
        """
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции {func.__name__}:", execution_time)
        return result

    return wrapper


warnings.simplefilter(action='ignore', category=FutureWarning)


class ServerSocket(threading.Thread):
    """
    Класс для создания асинхронного сервера на основе сокетов в отдельном потоке.
    Сервер слушает входящие соединения и отправляет клиентам данные из атрибута data.
    """
    data = []

    def __init__(self, host='', port=8888):
        """
        Инициализация сервера.

        :param host: IP-адрес для прослушивания. По умолчанию слушает все доступные интерфейсы.
        :param port: Порт для прослушивания. По умолчанию 8888.
        """
        super().__init__()
        self.host = host
        self.port = port

    async def handle_client(self, reader, writer):
        """
        Асинхронная функция для обработки подключенного клиента.

        :param reader: объект для чтения данных от клиента.
        :param writer: объект для отправки данных клиенту.
        """
        writer.get_extra_info('peername')
        message = ';'.join([str(item) for item in ServerSocket.data])
        writer.write(message.encode('utf-8'))
        await writer.drain()
        writer.close()
        await writer.wait_closed()

    async def run_server(self):
        """
        Асинхронная функция для запуска сервера.
        """
        server = await asyncio.start_server(self.handle_client, self.host, self.port)
        async with server:
            await server.serve_forever()

    def run(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self.run_server())


class WarningWindow(QMessageBox):
    """
    Класс для создания окна предупреждения с возможностью завершения программы.
    """

    def __init__(self, sometext='', out=True):
        """
                Инициализация окна предупреждения.

                Параметры:
                - sometext (str): Текст, который будет отображаться в окне предупреждения.
                - out (bool): Если True, программа будет завершена при нажатии на кнопку "Ok". Если False, окно просто закроется.
        """
        super().__init__()

        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        self.setWindowTitle("Error")
        self.setText(str(sometext))
        self.setIcon(QMessageBox.Warning)
        self.setFont(QFont("Arial", 23))
        self.setStandardButtons(QMessageBox.Ok)

        if out:
            self.button(QMessageBox.Ok).clicked.connect(QApplication.quit)
        else:
            self.button(QMessageBox.Ok).clicked.connect(self.close)

        self.show()


def warning_window(sometext, out=True):
    """
       Функция для создания и отображения окна предупреждения.

       Параметры:
       - sometext (str): Текст, который будет отображаться в окне предупреждения.
       - out (bool, опционально): Если True, программа будет завершена при нажатии на кнопку "Ok".
                                 Если False, окно просто закроется. По умолчанию True.

       Пример использования:
       warning_window("Произошла ошибка!", out=False)
       """
    WarningWindow(sometext=sometext, out=out).exec_()


WORK_DIR = ''  # Рабочая директория, где хранятся или будут сохраняться файлы и данные
global Imitation
Imitation = False


class IpConfigDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Добавить IP")
        self.setLayout(QVBoxLayout())

        self.combo = QComboBox()
        self.combo.addItems(['modbus', 'opc', 'daq', 'elemer'])

        self.line_edit = QLineEdit("192.168.")
        self.line_edit.setPlaceholderText("Введите IP-адрес")

        self.button_box = QPushButton("OK")
        self.button_box.clicked.connect(self.accept)

        self.layout().addWidget(QLabel("Тип соединения:"))
        self.layout().addWidget(self.combo)
        self.layout().addWidget(QLabel("IP-адрес:"))
        self.layout().addWidget(self.line_edit)
        self.layout().addWidget(self.button_box)

    def get_result(self):
        return self.line_edit.text(), self.combo.currentText()


class Window(QWidget):
    """Окно для выбора схемы из списка доступных схем."""
    my_signal = pyqtSignal(str)  # Сигнал для передачи выбранной схемы
    qsettings = QSettings('Teplo', "m11m")  # Настройки приложения
    program_directory = os.path.dirname(os.path.abspath(sys.argv[0]))  # Директория программы

    def __init__(self):
        super().__init__()

        self.setWindowFlags(Qt.FramelessWindowHint)
        self.horizont = QHBoxLayout(self)
        self.setGeometry(500, 500, 550, 100)

        self.combo_box = QComboBox()
        self.combo_box.setGeometry(50, 50, 250, 30)
        self._populate_combobox_with_schemes(self.program_directory)

        last_index = Window.qsettings.value('last_index', 0)
        self.combo_box.setCurrentIndex(last_index)

        self.btn1 = QPushButton('ок')
        self.btn2 = QPushButton('+')
        self.btn3 = QPushButton('вых')
        self._setup_buttons()

        self.checkbox_config = QCheckBox()
        self.checkbox_config.stateChanged.connect(self.imitation)
        self.horizont.addWidget(self.checkbox_config)

        self.countdown_label = QLabel("Автовыбор через: 10 сек")
        self.horizont.addWidget(self.countdown_label)

        self._setup_timer()

        self.setFont(QFont('Arial', 14))
        self.flag = False

    def _populate_combobox_with_schemes(self, program_directory):
        for folder_name in os.listdir(program_directory):
            folder_path = os.path.join(program_directory, folder_name)
            if os.path.isdir(folder_path) and folder_name != "__pycache__":
                self.combo_box.addItem(folder_name)

    def _setup_buttons(self):
        self.horizont.addWidget(self.combo_box, 4)
        self.horizont.addWidget(self.btn1)
        self.horizont.addWidget(self.btn2)
        self.horizont.addWidget(self.btn3)
        self.btn1.clicked.connect(self.return_selected_scheme)
        self.btn2.clicked.connect(self.add_new_scheme)
        self.btn3.clicked.connect(lambda: os._exit(0))

    def _setup_timer(self):
        self.timer = QTimer(self)
        self.timer.setSingleShot(True)
        self.timer.setInterval(10000)

        self.remaining_time = 10
        self.update_timer = QTimer(self)
        self.update_timer.setInterval(1000)
        self.update_timer.timeout.connect(self._update_countdown)

        self.timer.timeout.connect(self.return_selected_scheme)
        self.timer.start()
        self.update_timer.start()

        self.combo_box.currentTextChanged.connect(self._cancel_timer)

    def _update_countdown(self):
        self.remaining_time -= 1
        if self.remaining_time <= 0:
            self.countdown_label.setText("Автовыбор...")
            self.update_timer.stop()
        else:
            self.countdown_label.setText(f"Автовыбор через: {self.remaining_time} сек")

    def _cancel_timer(self):
        self.timer.stop()
        self.update_timer.stop()
        self.countdown_label.hide()

    def imitation(self):
        global Imitation
        Imitation = True

    def return_selected_scheme(self):
        Window.qsettings.setValue('last_index', self.combo_box.currentIndex())
        self.close()
        self.my_signal.emit(self.combo_box.currentText())

    def add_new_scheme(self):
        self.timer.stop()
        self.update_timer.stop()

        folder_name = self._get_folder_name()
        if not folder_name:
            return

        new_folder_path = self._create_new_folder(folder_name, self.program_directory)
        if not new_folder_path:
            return

        self._set_image_for_scheme(new_folder_path)
        self._set_settings_for_scheme(new_folder_path)

        self.my_signal.emit(os.path.join(self.program_directory, folder_name))
        self.reformat_combobox(os.path.join(new_folder_path, "setting1.txt"), folder_name)

    def _get_folder_name(self):
        folder_name, ok_pressed = QInputDialog.getText(self, 'Название', 'Введите название')
        if ok_pressed and folder_name and self.combo_box.findText(folder_name) == -1:
            self.combo_box.addItem(folder_name)
            self.combo_box.setCurrentIndex(self.combo_box.count() - 1)
            return folder_name
        return None

    def _create_new_folder(self, folder_name, settings_directory):
        new_folder_path = os.path.join(settings_directory, folder_name)
        if not os.path.exists(new_folder_path):
            os.makedirs(new_folder_path)
            return new_folder_path
        return None

    def _set_image_for_scheme(self, new_folder_path):
        selected_image = QFileDialog.getOpenFileName(self, "Выберите изображение", new_folder_path,
                                                     "Images (*.png *.xpm *.jpg *.bmp)")[0]
        target_file_path = os.path.join(new_folder_path, "BG.png")
        if selected_image:
            QFile.copy(selected_image, target_file_path)
        else:
            open(target_file_path, 'a').close()

    def _set_settings_for_scheme(self, new_folder_path):
        selected_txt = QFileDialog.getOpenFileName(self, "Выберите настройки", new_folder_path,
                                                   "Текстовые файлы (*.txt)")[0]
        if selected_txt:
            target_file_path = os.path.join(new_folder_path, os.path.basename(selected_txt))
            QFile.copy(selected_txt, target_file_path)
        else:
            default_file_path = "setting1_default.txt"
            new_file_name = "setting1.txt"
            target_file_path = os.path.join(new_folder_path, new_file_name)
            QFile.copy(default_file_path, target_file_path)
            QFile(target_file_path).rename(os.path.join(new_folder_path, new_file_name))

    def reformat_combobox(self, target_file_path, folder_name):
        def update_config_ips(lines):
            updated_lines = []
            for line in lines:
                if "IZDELIE" in line:
                    line = f'{"IZDELIE"}= "{folder_name}"\n'
                if 'IPS' in line and "##" not in line:
                    num_ips = QInputDialog.getInt(self, 'Input Dialog', 'Число ip:', 1)[0]
                    ips = 'IPS = {'
                    for _ in range(num_ips):
                        ips += get_ip_config()
                    ips += '}\n'
                    line = ips
                updated_lines.append(line)
            return updated_lines

        def get_ip_config():
            dialog = IpConfigDialog()
            if dialog.exec_() == QDialog.Accepted:
                ip, proto = dialog.get_result()
                return f'"{ip}":"{proto}",'
            return ''

        with open(target_file_path, 'r') as f:
            lines = f.readlines()

        updated_lines = update_config_ips(lines)

        with open(target_file_path, 'w') as f:
            f.writelines(updated_lines)

        items = [self.combo_box.itemText(i) for i in range(self.combo_box.count())]
        sorted_items = sorted(items)
        self.combo_box.clear()
        self.combo_box.addItems(sorted_items)
        self.combo_box.setCurrentText(folder_name)


if __name__ == '__main__':
    app = QApplication(sys.argv)

    window = Window()
    selected_scheme = {'dir': None}  # Используем словарь, чтобы обойти ограничение области видимости


    def store_selected_dir(chosen_dir):
        selected_scheme['dir'] = os.path.join(Window.program_directory, chosen_dir)


    window.my_signal.connect(store_selected_dir)
    window.show()

    app.exec_()  # Блокирующий вызов — ждёт, пока пользователь выберет схему

    # Проверка: выбрал ли пользователь схему
    WORK_DIR = selected_scheme['dir']
    if not WORK_DIR or not os.path.exists(WORK_DIR):
        warning_window("Схема не выбрана или директория не найдена", out=True)

    # Загружаем конфигурацию
    config_defaults = {
        'textbox_w': 800,
        'textbox_h': 180,
        'imitation': False,
        'adjust_index': (lambda x: x - 1),
        'IZDELIE': '',
        'IMG': os.path.join(WORK_DIR, 'BG.png'),
        'setting': os.path.join(WORK_DIR, 'setting1.txt'),
        'IPS': {},
        'sensor_size': 14,
        'hidename': 0,
        'format_time': "%H_%M_%S__%d-%m-%y",
        'pack': 4,
        'GRID': '#' * 79,
        'COLORS': {
            "Красный": "FF5733", "Зелёный": "00ff00", "Синий": "50b4bd",
            'Черный': '000000', 'Голубой': '01fdfc', 'Тёмносерый': '49423d',
            'Серый': '808080', 'Светлосерый': 'bbbbbb', 'Пурпурный': 'e600e6',
            'Жёлтый': 'fde910', 'Прозрачный': 'transparent'
        },
        'daq_prefix': ['net', '.device01'],
        'graph_step': 1000,
        'graph_point': 300,
        'SIDE': {'Лево': 'left', 'Право': 'right', 'Верх': 'top', 'Низ': 'bottom'},
        'dampers_signals': {},
        'damper_data_queue': {},
        'ORIENTATION': {"Горизантально": 'H', 'Вертикально': 'V'}
    }


    def update_config_from_file(filename, config):
        try:
            with open(filename, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#') or '=' not in line:
                        continue
                    key, value = line.split('=', 1)
                    try:
                        config[key.strip()] = ast.literal_eval(value.strip())
                    except Exception as e:
                        print(
                            f"[config warning] Невозможно разобрать значение '{value.strip()}' для ключа '{key.strip()}': {e}")
        except FileNotFoundError:
            warning_window(f"Файл конфигурации не найден: {filename}", True)
            sys.exit(1)
        return config


    try:
        config = update_config_from_file(config_defaults['setting'], config_defaults)
    except FileNotFoundError:
        warning_window(f"Файл настроек не найден:\n{config_defaults['setting']}", out=True)
        sys.exit(1)

    config['imitation'] = Imitation


def check_and_warn_about_connection(config):
    """Проверяет соединение с каждым IP-адресом и выводит предупреждение при потере соединения."""

    def ping_and_warn(ip, retries=3, delay=5):
        if len(ip) < 5:
            return True
        for attempt in range(retries):
            try:
                if ping(ip, timeout=1):
                    return True
            except Exception as e:
                print(f"[ping error] {ip}: {e}")
            warning_window(f'Try to reconnect {ip} (попытка {attempt + 1}/{retries})', False)
            for _ in range(delay * 10):  # чтобы не блокировать GUI
                QCoreApplication.processEvents()
                sleep(0.1)
        return False

    if not config.get('imitation', False):
        for ip in config['IPS'].keys():
            if not ping_and_warn(ip):
                warning_window(f"{ip} \n lost connection")
                break


check_and_warn_about_connection(config)


def initialize_data_streams(channels, dampers_list):
    """Создает потоки для различных протоколов в сети для получения данных."""
    queue_names = []
    config['threads'] = []

    function_dict = {
        'modbus': partial(fetch_data_from_modbus, device_type='modbus'),
        'elemer': partial(fetch_data_from_modbus, device_type='elemer'),
        'daq': partial(fetch_daq_data),
        'opc': partial(fetch_opc_data),
        'port': partial(fetch_port)
    }

    for index, (ip_address, protocol_type) in enumerate(config['IPS'].items()):
        queue_name = f'data_{protocol_type}_{index}'
        config[queue_name] = queue.LifoQueue()
        queue_names.append(config[queue_name])

        # Создание клиента, если нужно
        client = None
        if protocol_type in ['modbus', 'elemer']:
            client = ModbusClient(host=ip_address, port=502, unit_id=1, auto_open=True)
            relevant_sensors = [s for s in channels if s.reg == index]
            config.setdefault('queue_expected_lengths', {})[queue_name] = len(relevant_sensors)
        # Подбор аргументов
        if function_dict.get(protocol_type):
            if client:
                args = (index, client, channels, dampers_list, config[queue_name])
            elif protocol_type == 'daq':
                args = (config[queue_name], index, dampers_list)
            elif protocol_type in ['opc', 'port']:
                args = (index, ip_address, channels, config[queue_name])
            else:
                args = ()

            data_thread = threading.Thread(
                target=function_dict[protocol_type],
                args=args,
                name=f"{protocol_type}_thread_{index}",
                daemon=True
            )
            data_thread.start()
            config['threads'].append(data_thread)
            print(f"[INFO] Поток {data_thread.name} запущен для {ip_address} ({protocol_type})")
        else:
            warning_window(f"Неизвестный протокол: {protocol_type}", out=False)

    return queue_names


def fetch_port(protocol_index, server_ip, channels, data_queue):
    sensors = [sensor for sensor in channels if sensor.reg == protocol_index]
    sensor_data_indices = [sensor.ch for sensor in sensors]

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(('', int(server_ip) + 1))
        dataname, _ = sock.recvfrom(1024)
        dataname = dataname.decode('windows-1251').split(';')
        config['ports'] = {f'{server_ip}_port_names': [f'{i + 1} {name}' for i, name in enumerate(dataname)]}
        sock.close()
    except Exception as e:
        print(f"[PORT] Ошибка инициализации: {e}")

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('', int(server_ip)))
    backup_data = [float('nan')] * len(sensor_data_indices)

    try:
        while True:
            try:
                data, _ = sock.recvfrom(1024)
                parts = data.decode('utf-8').split(';')
                values = [float(parts[i].replace(',', '.')) for i in sensor_data_indices]
                backup_data = values.copy()
            except Exception as e:
                print(f"[PORT] Ошибка чтения: {e}")
                values = backup_data.copy()
                time.sleep(0.5)

            data_queue.put(values)
            time.sleep(0.1)
    finally:
        sock.close()


def format_modopc(ip_address):
    """Формирование имени модуля для OPC сервера на основе IP-адреса."""
    ip_part = config['daq_prefix'][0] + ''.join([part.zfill(3) for part in ip_address.split('.', 2)[2].split('.')]) + \
              config['daq_prefix'][1]
    return ip_part


def fetch_opc_data(protocol_index, server_ip, channels, data_queue):
    sensors = [sensor for sensor in channels if sensor.reg == protocol_index]
    opc_url = f"opc.tcp://{server_ip}:4840"
    client = UaClient(opc_url)
    backup_data = [float('nan')] * len(sensors)

    try:
        client.connect()
        print(f"[OPC UA] Connected to {opc_url}")

        node_ids = [f"ns=2;s={sensor.name}" for sensor in sensors]

        while True:
            try:
                values = [float(client.get_node(nid).get_value()) for nid in node_ids]
                backup_data = values.copy()
            except Exception as e:
                print(f"[OPC UA] Read error: {e}")
                values = backup_data.copy()
                time.sleep(0.5)

            data_queue.put(values)
            time.sleep(0.1)
    except Exception as e:
        print(f"[OPC UA] Connection error: {e}")
    finally:
        try:
            client.disconnect()
        except:
            pass


def read_sensors_ops(sensors, opc_device, opc_client):
    """
    Читает значения датчиков с OPC сервера.

    :param sensors: Список датчиков, значения которых необходимо прочитать.
    :param opc_device: Идентификатор устройства на OPC сервере.
    :param opc_client: Клиент для подключения к OPC серверу.
    :return: Генератор, возвращающий значения датчиков.
    """
    # Подключение к OPC серверу
    opc_client.connect('Metran-910.OPC')

    # Чтение данных для каждого датчика
    for sensor in sensors:
        sensor_value = opc_client.properties(f"{opc_device}.AI{sensor.ch + 1:02d}Value", 2)
        yield round(sensor_value, 4)

    # Закрытие соединения с OPC сервером
    opc_client.close()


def fetch_data_from_modbus(protocol_index, modbus_client, channels, dampers_list, data_queue, device_type='modbus'):
    try:
        relevant_sensors = [sensor for sensor in channels if sensor.reg == protocol_index]
        relevant_dampers = {
            (damper.name, damper.reg): [damper.chdv_open, damper.chdv_close]
            for damper in dampers_list if damper.reg == protocol_index
        }

        # Инициализация сигналов заслонок
        try:
            max_value = max(max(vals) for vals in relevant_dampers.values())
            config['dampers_signals'][protocol_index] = {key: 0 for key in range(0, max_value + 1)}
            dampers_signals = config['dampers_signals'][protocol_index].copy()

            try:
                input_signals = modbus_client.read_discrete_inputs(0, 9)
                config['damper_data_queue'][protocol_index] = input_signals or [0] * 10
            except Exception as e:
                print(f"[modbus-{device_type}] Ошибка чтения входов: {e}")
                config['damper_data_queue'][protocol_index] = [0] * 10
        except Exception:
            dampers_signals = config['dampers_signals'][protocol_index] = 0

        backup_data = [float('nan')] * len(relevant_sensors)  # резерв на случай ошибки

        while True:
            try:
                # Основной цикл чтения сенсоров
                modbus_data = list(fetch_sensor_data(relevant_sensors, modbus_client, device_type))

                # 🚨 Чтение входов КАЖДЫЙ ЦИКЛ
                try:
                    input_signals = modbus_client.read_discrete_inputs(0, 9)
                    if input_signals != config['damper_data_queue'][protocol_index]:
                        print(
                            f"[modbus-{device_type}] Входы изменились: {config['damper_data_queue'][protocol_index]} → {input_signals}")
                        config['damper_data_queue'][protocol_index] = input_signals
                except Exception as e:
                    print(f"[modbus-{device_type}] Ошибка чтения входов в цикле: {e}")

                # Проверка сигналов заслонок
                if config['dampers_signals'][protocol_index] != dampers_signals:
                    try:
                        modbus_client.write_multiple_coils(
                            0, list(config['dampers_signals'][protocol_index].values())
                        )
                        dampers_signals = config['dampers_signals'][protocol_index].copy()
                    except Exception as e:
                        print(f"[modbus-{device_type}] Ошибка управления заслонками: {e}")

                backup_data = modbus_data.copy()

            except Exception as e:
                print(f"[modbus-{device_type}] Ошибка чтения: {e}")
                modbus_data = backup_data.copy() if backup_data else [float('nan')] * len(relevant_sensors)

            data_queue.put(modbus_data)
            time.sleep(0.1)

    except Exception as e:
        warning_window(f'{e}  {device_type.capitalize()} connection failed')


def fetch_sensor_data(sensor_list, modbus_client, device_type='modbus'):
    for sensor in sensor_list:
        try:
            if device_type == 'modbus':
                register_address = sensor.ch * 2
                word_count = 2
            else:  # 'elemer'
                register_address = 0x4000 + sensor.ch * 4
                word_count = 4
                response = modbus_client.read_input_registers(register_address, 2 if device_type == 'modbus' else 4)
                print(response)
                decoded_value = BinaryPayloadDecoder.fromRegisters(response, Endian.BIG,
                                                                   wordorder=Endian.LITTLE).decode_32bit_float()
                yield round(decoded_value, 4)

            response = modbus_client.read_input_registers(register_address, word_count)
            if response is None:
                raise ValueError("Нет ответа от устройства")

            decoded_value = ModbusClientMixin.convert_from_registers(
                response,
                ModbusClientMixin.DATATYPE.FLOAT32,
                word_order="little"
            )
            yield round(decoded_value, 4)
        except Exception as e:
            print(f"[modbus-{device_type}] ошибка на датчике {sensor.name} (ch={sensor.ch}): {e}")
            yield float('nan')


def generate_daq_configuration(ips_config):
    """
    Генерирует конфигурацию DAQ устройства на основе доступных модулей и их типов.

    Параметры:
    - ips_config: словарь с IP-адресами устройств.

    Возвращает:
    - daq_config: словарь с информацией о доступных модулях и их типах.
    """

    # Словарь моделей модулей и их типов
    MODULE_MAPPINGS = {
        '9208': 'ai', '9403': 'do', '9425': 'di',
        '9265': 'ao', '9213': 'tc', '9214': 'tc',
        '9217': 'rtd', '9222': 'vi'
    }

    # Инициализация системы и получение списка доступных устройств
    system = nidaqmx.system.System.local()
    devices_list = system.devices
    daq_config = {}

    # Обработка каждого устройства в списке (проверяет ip)
    for device_identifier in devices_list.device_names:
        try:
            device_ip = devices_list[device_identifier].tcpip_ethernet_ip
        except Exception:
            continue

        # Если IP устройства присутствует в конфигурации
        if device_ip in ips_config:
            current_device = devices_list[device_identifier]
            current_device.reserve_network_device(True)

            # Получение списка модулей для текущего устройства
            modules_info = {module.name: module.product_type for module in current_device.chassis_module_devices}

            for module_name, module_type in modules_info.items():
                module_key = next((key for key, value in MODULE_MAPPINGS.items() if key in module_type), None)
                if module_key:
                    daq_config[f"{module_name}/{module_key}/{MODULE_MAPPINGS[module_key]}"] = config.get(
                        module_name.replace('-', '_'), '')
    return daq_config


# Проверка условия config['imitation] и наличие 'daq' в значениях словаря config['IPS']
if not config['imitation'] and any(value == 'daq' for value in config['IPS'].values()):
    config['daq_configuration'] = generate_daq_configuration(config['IPS'])


def task_dido(dampers_list, index):
    """
    Настроить и выполнить задачи для работы с DAQ (Data Acquisition) устройством.
    :param dampers_list: Список демпферов для обработки.
    :param index: Индекс, используемый для фильтрации демпферов и настройки задач DAQ.
    :return: Кортеж, содержащий:
             - dampers_signals: Сигналы демпферов.
             - do_task: Задача для цифрового вывода.
             - di_task: Задача для цифрового ввода.
             - di_max: Максимальное количество выборок для цифрового ввода.
             """
    try:
        # Создаем словарь relevant_dampers для хранения данных по демпферам с указанным индексом
        relevant_dampers = {}

        # Фильтруем dampers_list для получения только демпферов с заданным индексом
        for damper in [damper for damper in dampers_list if damper.reg == index]:
            relevant_dampers[damper.name, damper.reg] = [[damper.chr_open, damper.chr_close],
                                                         [damper.chdv_open, damper.chdv_close]]

        # Находим максимальные значения для di и do
        di_max = do_max = 32
        # Извлекаем информацию о DAQ-конфигурации из файла config
        daq_di = next(key.split('/')[0] for key in config['daq_configuration'].keys() if 'di' in key)
        di_task = nidaqmx.Task()
        for i in range(di_max):
            di_task.di_channels.add_di_chan(f"{daq_di}/port0/line{i}")
        config['damper_data_queue'][index] = [item for sublist in di_task.read(number_of_samples_per_channel=1) for item
                                              in sublist]

        daq_do = next(key.split('/')[0] for key in config['daq_configuration'].keys() if 'do' in key)
        do_task = nidaqmx.Task()
        for i in range(do_max):
            do_task.do_channels.add_do_chan(f"{daq_do}/port0/line{i}")
        config['dampers_signals'][index] = {key: False for key in range(0, do_max)}
        dampers_signals = config['dampers_signals'][index].copy()

    except Exception:
        # Обработка исключений, если что-то пошло не так
        dampers_signals = config['dampers_signals'][index] = di_max = do_task = di_task = 0

    return dampers_signals, do_task, di_task, di_max


def task_aigen(index):
    """
    Создать и настроить задачу для работы с модулями AI (Analog Input) DAQ.

    :param index: Индекс, используемый для фильтрации сенсоров.
    :return: Кортеж, содержащий:
             - task: Задача для сбора данных с модулей AI.
             - endcfg: Конечная конфигурация модулей AI.
    """

    ai_modules = ai_modules = {k: v for k, v in config.items() if ('DAQ' in k or 'SIU' in k) and v}
    # Создаем новую задачу DAQ
    task = nidaqmx.Task()
    # Создаем словарь для хранения диапазонов каналов DAQ
    daq_channel_ranges = {}
    # Извлекаем сенсоры, относящиеся к заданному индексу
    relevant_sensors = [sensor for sensor in dlgMain.sensor_list if sensor.reg == index]
    # Создаем словарь endcfg для хранения конфигурации DAQ по модулям
    endcfg = {}
    # Итерируем по модулям AI
    for i, (module_name, values) in enumerate(ai_modules.items()):
        new_daq_channel_ranges = {}
        new_values = {}

        # Извлекаем название модуля без среднего числа
        module = re.sub(r"/\d+/", "/", module_name).replace("_", "-")
        endcfg[module] = {}

        # Итерируем по ключам и значениям каждого модуля
        for old_key, old_value in values.items():
            new_values[old_key] = old_value

        # Сортируем новые значения и сохраняем их в новом словаре
        new_daq_channel_ranges[module] = dict(sorted(new_values.items()))

        # Обновляем словарь daq_channel_ranges
        daq_channel_ranges[module] = new_daq_channel_ranges[module]

        # Добавляем AI-каналы для соответствующих сенсоров
        for sensor in relevant_sensors:
            for key, val in daq_channel_ranges[module].items():
                if sensor.ch == key - 1:
                    chnl = sensor.ch % 16  # Необходимый канал после вычитания 1 и приведения к диапазону 0-15
                    task.ai_channels.add_ai_current_chan(f"{module}/ai{chnl}")
                    endcfg[module][chnl] = val
                    break
        print(endcfg)
    # Настройка задачи для чтения данных с DAQ
    # Измените параметры тактовой частоты и режима сбора данных на необходимые вам
    task.timing.cfg_samp_clk_timing(rate=13, sample_mode=AcquisitionType.CONTINUOUS)
    # Раскомментируйте, если вам нужно вывести имена каналов для отладки
    for ai_channel in task.ai_channels:
        print(ai_channel.name)
    return task, endcfg


def fetch_daq_data(data_queue, index, dampers_list):
    try:
        dampers_signals, do_task, di_task, di_max = task_dido(dampers_list, index)
        task_ai, endcfg = task_aigen(index)
        task_ai.start()

        def generate_processed_data(endcfg, data):
            module_values = np.concatenate([np.array(list(cfg.values())) for cfg in endcfg.values()])
            chunks = [data[i:i + len(module_values)] for i in range(0, len(data), len(module_values))]
            chunk_array = np.array(chunks)
            processed_values = np.round(
                ((chunk_array * 1000 - 4) * (module_values[:, 1] - module_values[:, 0])) / 16 + module_values[:, 0], 4
            )
            return processed_values.reshape(-1)

        backup_data = [float('nan')] * sum(len(cfg) for cfg in endcfg.values())
        should_read_data = True

        while True:
            try:
                dataai = task_ai.read()
                if should_read_data:
                    config['damper_data_queue'][index] = list(
                        itertools.chain.from_iterable(di_task.read(number_of_samples_per_channel=1)))
                    should_read_data = False

                if config['dampers_signals'][index] != dampers_signals:
                    dampers_signals = config['dampers_signals'][index].copy()
                    do_task.write(data=list(config['dampers_signals'][index].values()))
                    should_read_data = True

                processed = list(generate_processed_data(endcfg, dataai))
                backup_data = processed.copy()
            except Exception as e:
                print(f"[DAQ] Ошибка: {e}")
                processed = backup_data.copy()
                time.sleep(0.5)

            data_queue.put(processed)
            time.sleep(0.1)

    except Exception as e:
        warning_window(f"DAQ init failed: {e}", False)


def process_data_channel(data_channel, dampers_list):
    """
    Обрабатывает данные из всех очередей. Устойчиво к падениям отдельных источников.
    """
    data_channel_condition = threading.Condition()
    config['processed_data_queue'] = queue.LifoQueue()

    with data_channel_condition:
        while data_channel is None:
            sleep(2)
            data_channel_condition.wait()

        if not config['imitation']:
            data_sources = initialize_data_streams(data_channel, dampers_list)

            while True:
                values = []
                for i, q in enumerate(data_sources):
                    try:
                        val = q.get(timeout=1)
                    except queue.Empty:
                        # Восстановление: определяем длину
                        queue_name = f"data_{list(config['IPS'].values())[i]}_{i}"
                        expected_len = config.get('queue_expected_lengths', {}).get(queue_name, 1)
                        val = [float('nan')] * expected_len
                    values.append(val)

                config['processed_data_queue'].put(values)


def fetch_live_data(max_attempts=5):
    """
    Пытается извлечь данные из очереди. Если очередь пуста, функция будет ждать и пытаться снова.

    :param max_attempts: Максимальное количество попыток чтения из очереди.
    :return: Извлеченные данные или None, если очередь пуста после всех попыток.
    """
    attempts = 0
    while attempts < max_attempts:
        try:
            return config['processed_data_queue'].get()
        except queue.Empty:
            sleep(1)
            print('error processing')
            warning_window('connection problems', False)
            attempts += 1
        except Exception as e:
            print('error processing', e)
    return None


class MovableObject(QWidget):
    def mousePressEvent(self, evt):
        if getattr(self, 'moveon', False) and evt.button() == Qt.LeftButton:
            self._dragging_pos = evt.globalPos()
            self._drag_active = True
            self.raise_()  # ⬅ поднять поверх всех

    def mouseMoveEvent(self, evt):
        if getattr(self, 'moveon', False) and getattr(self, '_drag_active', False):
            delta = evt.globalPos() - self._dragging_pos
            self.move(self.x() + delta.x(), self.y() + delta.y())
            self._dragging_pos = evt.globalPos()

    def mouseReleaseEvent(self, evt):
        self._dragging_pos = None
        self._drag_active = False

        if getattr(self, 'moveon', False) and 'setting' in config:
            with open(config['setting'], 'r') as f:
                lines = f.readlines()
            with open(config['setting'], 'w') as f:
                for line in lines:
                    if self.name + ' ' in line:
                        line = f'{line[:line.rfind(" (")]} ({self.x()} {self.y()})\n'
                    f.write(line)


class IndicatorLamp(MovableObject):
    def __init__(self, name: str, reg: int, ch: int, parent=None):
        super().__init__(parent)
        self.reg = reg - 1
        self.ch = ch - 1
        self.resize(100, 50)
        self.setToolTip(f"LAMP: reg={reg}, ch={ch}")
        self.name = name
        self.color = QColor("gray")
        self.moveon = False
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_state)
        self.timer.start(300)

    def update_state(self):
        try:
            val = config['damper_data_queue'][self.reg][self.ch]
            self.color = Qt.green if val else Qt.red  # ✅ правильная
        except Exception:
            self.color = QColor("gray")
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # Новый радиус круга
        circle_size = 24
        circle_margin = 4

        # Крупный круг слева
        painter.setBrush(QBrush(self.color))
        painter.setPen(Qt.black)
        painter.drawEllipse(circle_margin, circle_margin, circle_size, circle_size)

        # Текст справа от круга
        painter.setFont(QFont('Arial', 10))
        text_rect = QRect(circle_size + 2 * circle_margin, circle_margin,
                          self.width() - (circle_size + 3 * circle_margin), circle_size)
        painter.drawText(text_rect, Qt.AlignVCenter | Qt.AlignLeft, self.name)


class Damper(MovableObject):
    sensor_data = []
    all_impuls = {}
    modbus_instances = {}  # Dictionary to store ModbusClient instances by modules
    opc_instances = {}  # Dictionary to store opc instances by modules
    lock = threading.Lock()
    DEFAULT_NAME = 'ЗУ'
    DEFAULT_SIDE = 'G'

    def __init__(self, name=DEFAULT_NAME, side=DEFAULT_SIDE, chr_open=1, chr_close=2, chdv_open=1, chdv_close=2,
                 side_auto='left', reg=1,
                 parent=None):
        """Damper Initialization"""
        super().__init__(parent=parent)
        self.valve_widget = None
        self.modbus_lock = threading.Lock()
        self.reg = config['adjust_index'](reg)
        if not 0 <= self.reg < len(config['IPS']):
            raise ValueError("Invalid 'reg' value")
        self.ip = list(config['IPS'].keys())[self.reg]

        handlers = {
            'opc': self.initialize_opc_connection,
            'elemer': lambda: self.initialize_modbus_connection('elemer'),
            'modbus': lambda: self.initialize_modbus_connection('modbus'),
            'daq': self.initialize_daq_channels
        }
        handlers[config['IPS'].get(self.ip)]()

        self.chdv_open = config['adjust_index'](chdv_open)
        self.chdv_close = config['adjust_index'](chdv_close)
        self.chr_open = config['adjust_index'](chr_open)
        self.chr_close = config['adjust_index'](chr_close)

        self.widget_automat = None
        self.name = name
        self.side = side
        self.widget = QWidget(self)
        self.layout = QGridLayout()
        self.setup_ui_elements()
        self.auto_side = side_auto
        self.scaletext(config.get("damper_size", 2))

    def setup_ui_elements(self):
        """Setup UI elements for the damper."""
        self.lab = QPushButton(f'{self.name}')
        self.lab.setToolTip(
            f"откр: ch={self.chr_open}, закр: ch={self.chr_close}\n"
            f"конц_откр: ch={self.chdv_open}, конц_закр: ch={self.chdv_close}\n"
            f"регистратор: {self.reg}"
        )
        self.lab.clicked.connect(self.info)
        self.lab.setStyleSheet(
            'font:bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0;text-align: top;')

        self.moveon = False
        self.widget.setLayout(self.layout)
        self.widget.setStyleSheet(
            ".QWidget {border: 1px solid black;border-radius: 25;background-color: rgb(255, 255, 255);}")

        self.setup_buttons()
        self.layout.setVerticalSpacing(0)
        self.layout.setHorizontalSpacing(0)
        self.widget.setFixedSize(120, 60)

        self.layout.addWidget(self.lab, 0, 0, 1, 2)
        self.layout.addWidget(self.red_button, 1, 0, 4, 1)
        self.layout.addWidget(self.green_button, 1, 1, 4, 1)

        if self.side == 'V':
            self.adjust_for_vertical_side()

        self.chkb = QCheckBox()
        self.chkb.stateChanged.connect(self.automatvisibl)
        self.chkb.setStyleSheet("QCheckBox::indicator { width: 10; height: 10;}")
        self.layout.addWidget(self.chkb, 0, 0, 3, 1)

        self.lab.clicked.connect(self.info)

    def setup_buttons(self):
        """Setup buttons for the damper."""

        def setup_button_func(button, on_press_action, on_release_action):
            button.mousePressEvent = lambda event: (
                self.Press(on_press_action) if event.button() == Qt.RightButton else (
                    self.onButtonPressed(on_press_action) if event.button() == Qt.LeftButton else None
                )
            )
            button.mouseReleaseEvent = lambda event: (
                self.onButtonPressed(on_release_action) if event.button() == Qt.LeftButton else None)

        self.red_button = QPushButton()
        setup_button_func(self.red_button, 'turnOnRed', 'turnOffRed')

        self.green_button = QPushButton()
        setup_button_func(self.green_button, 'turnOnGreen', 'turnOffGreen')

        self.pressed = None

        self.update_button_styles(self.red_button, self.green_button, '13px')
        self.red_button.setFixedSize(50, 35)
        self.green_button.setFixedSize(50, 35)
        self.lab.setFixedSize(100, 25)

    def Press(self, action):
        toggle_actions = {
            'turnOnGreen': 'turnOffGreen',
            'turnOnRed': 'turnOffRed'
        }

        if action in toggle_actions:
            toggled_action = toggle_actions[action] if self.pressed == action else action
            self.pressed = None if self.pressed == action else action
            self.onButtonPressed(toggled_action)

    def adjust_for_vertical_side(self):
        """Adjust UI elements for vertical side."""
        self.update_button_styles(self.red_button, self.green_button, '0px')
        self.layout.setHorizontalSpacing(1)
        self.widget.setFixedSize(65, 110)
        self.red_button.setFixedSize(25, 50)
        self.green_button.setFixedSize(25, 50)
        self.lab.setFixedSize(25, 95)
        self.layout.addWidget(self.lab, 0, 1, 2, 1)
        self.layout.addWidget(self.red_button, 1, 0, 1, 1)
        self.layout.addWidget(self.green_button, 0, 0, 1, 1)

    def initialize_modbus_connection(self, attribute_name):
        """
        Инициализирует соединение с Modbus и сохраняет клиентское соединение в атрибуте объекта.

        :param attribute_name: Имя атрибута, в котором будет сохранен клиент Modbus.
        """
        try:
            # Создание нового клиента Modbus.
            modbus_client = ModbusClient(host=self.ip, port=502, unit_id=1, timeout=5, auto_open=True, auto_close=True)

            # Обновление словаря экземпляров Modbus.
            Damper.modbus_instances.update({self.ip: modbus_client})

            # Установка атрибута объекта с клиентом Modbus.
            setattr(self, attribute_name, Damper.modbus_instances[self.ip])
        except Exception as error:
            # Вывод предупреждения в случае ошибки.
            warning_window(f'Ошибка Ошибка инициализации каналов modbus {error}', False)

    def initialize_opc_connection(self):
        from opcua import Client as UaClient

        try:
            url = f"opc.tcp://{self.ip}:4840"
            client = UaClient(url)
            client.connect()

            Damper.opc_instances[self.ip] = client
            self.opc = client

            # Можно сохранить NodeId-шаблоны, если нужны
            self.opc_node_map = {
                "AI": lambda ch: f"ns=2;s={self.name}.AI{ch + 1:02d}Value",
                "DI": lambda ch: f"ns=2;s={self.name}.DI{ch + 1:02d}Value",
                "DO": lambda ch: f"ns=2;s={self.name}.DO{ch + 1:02d}Value",
                "AO": lambda ch: f"ns=2;s={self.name}.AO{ch + 1:02d}Value",
            }

        except Exception as error:
            warning_window(f"[OPC UA] Init error: {error}", False)

    def initialize_daq_channels(self):
        """
        Инициализирует каналы ввода/вывода для DAQ устройства на основе конфигурации.
        """
        try:
            # Создание словаря, связывающего типы каналов (ввод/вывод) с именами модулей.
            channel_to_module_map = {
                key.split('/')[-1]: key.split('/')[0]
                for key, value in config['daq_configuration'].items()
                if key.endswith(('do', 'di'))
            }

            # Установка атрибутов объекта с именами модулей для каналов ввода/вывода.
            self.daq_output_module = channel_to_module_map.get('do')
            self.daq_input_module = channel_to_module_map.get('di')
        except Exception as error:
            # Вывод предупреждения в случае ошибки.
            warning_window(f'Ошибка инициализации каналов DAQ {error}', False)

    def update_button_styles(self, open_button, close_button, margin_top):
        """
        Обновляет стили кнопок "Открыть" и "Закрыть".

        :param open_button: Объект кнопки "Открыть".
        :param close_button: Объект кнопки "Закрыть".
        :param margin_top: Значение верхнего отступа для кнопок.
        """

        open_button_style = f"""
                             QPushButton{{
                             background-color: #A61300;
                             border-bottom-left-radius:10px;
                             border-top-right-radius:10px;
                             margin-top: {margin_top};
                             }}
                             QPushButton:pressed {{ background-color: #FF2800 }}
                             """

        close_button_style = f"""
                              QPushButton{{
                              background-color: #007C21;
                              border-top-left-radius:10px;
                              border-bottom-right-radius:10px;
                              margin-top: {margin_top};
                              }}
                              QPushButton:pressed {{ background-color:#64DF85 }}
                              """

        open_button.setStyleSheet(open_button_style)
        close_button.setStyleSheet(close_button_style)

    def automatvisibl(self):
        # Проверяем, установлен ли флажок
        if self.chkb.isChecked():
            try:
                # Попытка показать существующий valve_widget
                self.valve_widget.show()
            except Exception:
                # Если valve_widget не существует, создаем новый экземпляр ValveControlWidget

                self.valve_widget = ValveControlWidget(self, dlgMain, self.side, self.auto_side)
                self.valve_widget.show()
        else:
            # Если флажок не установлен, скрываем valve_widget
            self.valve_widget.hide()

    def _update_shutter_display_color(self):
        """
        Обновляет цвет отображения заслонки на основе текущего состояния устройства.
        """
        with threading.Lock():
            try:
                shutter_open, shutter_close = self._fetch_device_state()
                determined_color = self._get_shutter_color(shutter_open, shutter_close)
                self._apply_color_to_label(determined_color)
            except Exception:
                self._apply_color_to_label('#FFFF00')

    def _fetch_device_state(self):
        """
        Получает текущее состояние устройства на основе его типа.

        :return: Кортеж из двух состояний: открыто и закрыто.
        """
        device_state_fetchers = {
            'daq': self._read_from_endcup,
            'opc': self._read_from_opc,
            'modbus': self._read_from_endcup,
            'elemer': self._read_from_endcup
        }
        return device_state_fetchers[config['IPS'].get(self.ip)]()

    def _get_shutter_color(self, shutter_open, shutter_close):
        """
        Определяет цвет заслонки на основе ее состояния.

        :param shutter_open: Состояние открытой заслонки.
        :param shutter_close: Состояние закрытой заслонки.
        :return: Строка, представляющая цвет в формате HEX.
        """
        return '#00FF00' if shutter_open else ('#FF0000' if shutter_close else '#FFFF00')

    def _apply_color_to_label(self, color):
        """
        Применяет заданный цвет к метке заслонки.

        :param color: Строка, представляющая цвет в формате HEX.
        """
        self.lab.setStyleSheet(
            f"""font:bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0;background-color: {color};text-align: center;""")

    def _read_from_opc(self):
        try:
            node_open = self.opc.get_node(f"ns=2;s={self.name}.DI{self.chr_open + 1:02d}Value")
            node_close = self.opc.get_node(f"ns=2;s={self.name}.DI{self.chr_close + 1:02d}Value")
            val_open = node_open.get_value()
            val_close = node_close.get_value()
            return val_open, val_close
        except Exception as e:
            print(f"[OPC UA] read_from_opc error: {e}")
            return 0, 0

    def update_lab_color(self):
        open_signal, close_signal = self._read_from_endcup()
        if open_signal and not close_signal:
            color = '#00FF00'  # зелёный — открыт
        elif close_signal and not open_signal:
            color = '#FF0000'  # красный — закрыт
        else:
            color = '#FFFF00'  # жёлтый — в движении/неизвестно

        self.lab.setStyleSheet(
            f"""font:bold;border-radius: 10px;border: 1px solid black;
            margin-bottom: 0;background-color: {color};text-align: center;""")

    def _read_from_endcup(self):

        shutter_open = config['damper_data_queue'][self.reg][self.chr_open]
        shutter_close = config['damper_data_queue'][self.reg][self.chr_close]
        return shutter_open, shutter_close

    def onButtonPressed(self, action_name_suffix):
        '''Метод, который выполняется при нажатии кнопки или выполнении определенного действия.

        Параметры:
        - self: ссылка `на экземпляр класса, в котором определен этот метод.
        - action_name_suffix: строка, содержащая суффикс имени действия или кнопки.

        Действия:
        - Определяет, включено ли устройство (is_on) на основе наличия подстроки 'On' в action_name_suffix.
        - Определяет тип данных (chdv_type), которые должны быть обработаны, на основе наличия подстроки 'Green' в action_name_suffix.
        - Создает новый поток (thread) для выполнения функции `update_damper` с заданными параметрами.
        - Потоку присваивается имя, содержащее имя экземпляра класса и action_name_suffix.
        - Поток запускается.

        Примечание:
        Этот метод предназначен для выполнения определенных действий при взаимодействии с устройством, например, при включении/выключении чего-то, и он использует многозадачность (потоки) для параллельного выполнения задач.
        '''
        is_on = 'On' in action_name_suffix
        chdv_type = self.chdv_open if 'Green' in action_name_suffix else self.chdv_close
        with Damper.lock:
            trz = threading.Thread(target=self.update_damper,
                                   args=[is_on, chdv_type, action_name_suffix],
                                   name=f'{self.name}_{action_name_suffix}')
            trz.start()

    def pressing(self, bt, time):
        """
          Метод, который выполняет действия при нажатии на кнопку в пользовательском интерфейсе.

          Параметры:
          - self: ссылка на экземпляр класса, в котором определен этот метод.
          - bt: тип кнопки (Open или Close).
          - time: время задержки.

          Действия:
          - Определяет действия для каждой кнопки (Open или Close) с использованием лямбда-функций и выполняет их в отдельном потоке.

          Примечание:
          Этот метод используется для обработки действий при нажатии кнопок в пользовательском интерфейсе.

          """
        button_actions = {
            'Open': lambda: (self.onButtonPressed('turnOnGreen'), sleep(time), self.onButtonPressed('turnOffGreen')),
            'Close': lambda: (self.onButtonPressed('turnOnRed'), sleep(time), self.onButtonPressed('turnOffRed'))
        }
        # Получаем нужное действие на основе типа кнопки
        action = button_actions.get(bt)
        if not action:
            return
        # Создаем и запускаем новый поток для выполнения действия
        t1 = threading.Thread(target=action, name=f'{self}_{bt}')
        t1.start()

    def update_damper(self, ch_push_value, channel, calling_function_name):
        """
        Метод, обновляющий интерфейс и выполняющий различные действия в зависимости от переданных параметров.
        Параметры:
        - self: ссылка на экземпляр класса, в котором определен этот метод.
        - ch_push_value: значение для управления заслонкой.
        - channel: номер канала управления.
        - calling_function_name: имя вызывающей функции.
        Действия:
        - Обновляет интерфейс (цвет кнопок) и выполняет действия в зависимости от переданных параметров.
        Примечание:
        Этот метод используется для обработки действий, связанных с управлением заслонкой и обновлением интерфейса.
        """
        color_map = {
            'turnOnGreen': ('8cd9ad', self.green_button),
            'turnOnRed': ('df022a', self.red_button),
            'turnOffGreen': ('007C21', self.green_button),
            'turnOffRed': ('A61300', self.red_button)
        }
        color, button = color_map.get(calling_function_name, (None, None))
        pattern = r"background-color:\s*#([A-Fa-f0-9]{6})"
        if button:
            current_stylesheet = button.styleSheet()
            match = re.search(pattern, current_stylesheet)
            if match:
                new_stylesheet = current_stylesheet.replace(match.group(1), color)
                button.setStyleSheet(new_stylesheet)
        #    self.lab.setStyleSheet(
        #        'font:bold;border-radius: 10px;border: 1px solid black;'
        #        f'margin-bottom: 0;background-color: #{color};text-align: center;')
        if config['imitation']:
            return

        hardware_actions = {
            'daq_output_module': lambda: self._signal_changed(channel, ch_push_value, 'daq'),
            'opc': lambda: (self._opc_action(channel, ch_push_value), sleep(0.05)),
            'modbus': lambda: self._signal_changed(channel, ch_push_value, 'modbus'),
            'elemer': lambda: self._signal_changed(channel, ch_push_value, 'elemer'),
        }
        for attr, action in hardware_actions.items():
            if hasattr(self, attr):
                action()
                break

        if calling_function_name in ('turnOffRed', 'turnOffGreen'):
            self._update_shutter_display_color()
        sleep(0.1)

    def _signal_changed(self, channel, ch_push_value, type):
        if type == 'modbus':
            config['dampers_signals'][self.reg][channel] = int(ch_push_value)
        elif type == 'daq':
            config['dampers_signals'][self.reg][channel] = ch_push_value
        else:
            config['dampers_signals'][self.reg][0x3000 + channel * 4] = 16256 if int(ch_push_value) else 0

    def _opc_action(self, ch, ch_push):
        try:
            node = self.opc.get_node(f"ns=2;s={self.name}.DO{ch + 2:02d}Value")
            node.set_value(bool(ch_push))
        except Exception as e:
            print(f"[OPC UA] write error: {e}")

    def _elemer_action(self, ch_push, ch):
        """Метод для выполнения действий с устройством Elemer.

        Параметры:
        - self: ссылка на экземпляр класса, в котором определен этот метод.
        - ch_push: значение для управления устройством.
        - ch: номер канала или устройства.

        Действия:
        - Определение значения `push` на основе `ch_push` (применяется 16256, если `ch_push` истинно, в противном случае 0).
        - Запись значения `push` в устройство Elemer в соответствии с номером канала `ch`.

        Примечание:
        Этот метод используется для выполнения действий с устройством Elemer, такими как запись значений в указанные каналы на устройстве.

        """
        push = 16256 if ch_push else 0
        self.elemer.write_single_register(0x3000 + ch * 4, push)

    def info(self):
        '''Метод для отображения информации о текущем экземпляре класса в новом окне.

        Действия:
        - Создает новое окно (`AnotherWindow`).
        - Устанавливает тексты для меток в новом окне, отображая информацию о текущем экземпляре класса (название, номера каналов и другие параметры).
        - Связывает событие изменения значения слайдера (`slider`) с методом `scaletext`.
        - Задает размеры и отображает элементы интерфейса (метки, кнопки) в новом окне.

        Примечание:
        Этот метод используется для отображения информации о текущем экземпляре класса и взаимодействия с элементами пользовательского интерфейса.

        '''
        self.w = InfoWidget()  # ,chr_open=0, chr_close=1, chdv_open=0, chdv_close=1,
        self.w.label1.setText(f'name {self.name}')
        self.w.label2.setText(
            f'chr_op {self.chr_open} ,chr_cl {self.chr_close} ')
        self.w.label3.setText(
            f'chdv_op {str(self.chdv_open)} ,chdv_cl {str(self.chdv_close)}')
        self.w.label4.setText(f'{self.pos()}')
        self.w.slider.valueChanged.connect(self.scaletext)
        self.wi = self.widget.width()
        self.he = self.widget.height()
        self.wi_lab = self.lab.width()
        self.he_lab = self.lab.height()
        self.wi_b1 = self.red_button.width()
        self.he_b1 = self.red_button.height()
        self.wi_b2 = self.green_button.width()
        self.he_b2 = self.green_button.height()
        self.w.show()

    def scaletext(self, value):
        try:
            value = int(value)
        except ValueError:
            value = 0

        value = max(-10, min(value, 50))  # разумный диапазон

        font_size = 10 + value
        btn_w = 50 + value * 2
        btn_h = 35 + value
        widget_w = 120 + value * 4
        widget_h = 60 + value * 2

        self.lab.setFont(QFont('Arial', font_size))
        self.lab.setFixedSize(widget_w - 20, 25 + value)

        self.red_button.setFixedSize(btn_w, btn_h)
        self.green_button.setFixedSize(btn_w, btn_h)

        self.widget.setFixedSize(widget_w, widget_h)

        if self.side == 'V':
            # вертикальная ориентация — другой расчёт
            widget_w = 65 + value * 2
            widget_h = 110 + value * 3
            self.widget.setFixedSize(widget_w, widget_h)
            self.lab.setFixedSize(25 + value, 95 + value * 2)
            self.red_button.setFixedSize(25 + value, 50 + value)
            self.green_button.setFixedSize(25 + value, 50 + value)

    def __str__(self):
        return f"Name:{self.name}"


class ValveControlWidget(QWidget):
    all_impuls_mutex = threading.Lock()

    def __init__(self, pa, gradpa, side, side_auto):
        super().__init__()
        """
        Конструктор класса ValveControlWidget.

        Args:
            dlgMain: Главное окно (предполагается, что это объект главного окна вашего приложения).
        """
        self.side = side
        self.side_auto = side_auto  # ориентация автоматики (панели)
        self.gradpa = gradpa
        self.pa = pa
        self.widget_automat = None
        self.create_automat_widget()

    def create_automat_widget(self):
        """
        Создает виджет для настройки параметров управления заслонкой, если он еще не создан.
        """
        if self.widget_automat is None:
            self.widget_automat = True
            self.setGeometry(self.calculate_widget_position())
            self.setup_ui_elements()

    def calculate_widget_position(self):
        """
        Позиционирует автоматику по self.side_auto с тонкой подгонкой от заслонки.
        """
        base_x = self.pa.x()
        base_y = self.pa.y()

        auto_w = 120
        auto_h = 180
        offset = 10

        match self.side_auto.lower():
            case 'left':
                x = base_x - auto_w - offset - 10  # левее
                y = base_y
            case 'right':
                x = base_x + self.pa.width() + offset - 20  # чуть левее
                y = base_y - auto_h // 4
            case 'top':
                x = base_x
                y = base_y - auto_h - 60
            case 'bottom':
                x = base_x
                y = base_y + self.pa.height() + offset - auto_h // 2
            case _:
                x = base_x
                y = base_y + self.pa.height() + offset

        return QRect(x, y, auto_w, auto_h)

    def setup_ui_elements(self):
        """
        Настраивает элементы пользовательского интерфейса внутри виджета.
        """
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        self.comboA = QComboBox()
        self.comboA.view().setMinimumWidth(100)
        self.comboA.addItems([f'{i}' for i in self.gradpa.dlg_ourch])

        self.ustA = QDoubleSpinBox()
        self.ustA.setSuffix(' уставка')
        self.ustA.setDecimals(4)
        self.ustA.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)

        # Добавьте остальные элементы пользовательского интерфейса аналогичным образом
        self.dopskA = QDoubleSpinBox()
        self.dopskA.setSuffix(' допуск')
        self.dopskA.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.dopskA.setDecimals(4)
        self.dopskA.setValue(0.1)
        self.dopskA.setMinimum(0.01)

        self.k_delay = QDoubleSpinBox()
        self.k_delay.setSuffix(' k задержки')
        self.k_delay.setDecimals(2)
        self.k_delay.setValue(2.0)
        self.k_delay.setMinimum(0.0)
        self.k_delay.setMaximum(10.0)

        self.max_delay = QDoubleSpinBox()
        self.max_delay.setSuffix(' макс задержка')
        self.max_delay.setDecimals(1)
        self.max_delay.setValue(5.0)
        self.max_delay.setMinimum(1.0)
        self.max_delay.setMaximum(60.0)

        self.timesleepaft = QDoubleSpinBox()
        self.timesleepaft.setSuffix(' задержка')
        self.timesleepaft.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.timesleepaft.setDecimals(4)
        self.timesleepaft.setMinimum(0.01)
        self.timesleepaft.setValue(2)

        self.limit = QDoubleSpinBox()
        self.limit.setSuffix(' аварийное')
        self.limit.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.limit.setDecimals(4)
        self.limit.setValue(12)

        self.kp = QDoubleSpinBox()
        self.kp.setSuffix('  Kp')
        self.kp.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.kp.setDecimals(4)
        self.kp.setValue(0.08)

        self.ki = QDoubleSpinBox()
        self.ki.setSuffix('  Ki')
        self.ki.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.ki.setDecimals(4)
        self.ki.setValue(0.005)

        self.kd = QDoubleSpinBox()
        self.kd.setSuffix('  Kd')
        self.kd.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.kd.setDecimals(4)
        self.kd.setValue(0.001)

        self.chkbA = QCheckBox()
        self.chkbA.stateChanged.connect(self.automatwork)

        # Добавьте созданные элементы в макет
        self.layout.addWidget(QLabel(f'{self.pa.name}'))
        self.layout.addWidget(self.comboA)
        self.layout.addWidget(self.ustA)

        self.chk_safe = QCheckBox("⏱ Контроль отклика")
        self.chk_safe.setToolTip("Включает проверку реакции после импульса (датчик / концевики)")

        self.layout.addWidget(self.chk_safe)
        self.layout.addWidget(self.k_delay)
        self.layout.addWidget(self.max_delay)
        self.layout.addWidget(self.dopskA)
        self.layout.addWidget(self.timesleepaft)
        self.layout.addWidget(self.limit)
        self.layout.addWidget(self.kp)
        self.layout.addWidget(self.ki)
        self.layout.addWidget(self.kd)
        self.layout.addWidget(self.chkbA)
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setStyleSheet("border: 1px solid black;")

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_dragging = True
            self.offset = event.pos()

    def mouseMoveEvent(self, event):
        if self.is_dragging:
            new_pos = event.globalPos() - self.offset
            self.move(new_pos)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_dragging = False
            self.offset = None

    def automatwork(self):
        # Если флажок установлен, запускаем автоматический режим
        if self.chkbA.isChecked():
            self.condition = True
            self.tr_auto = threading.Thread(target=self.p_auto)
            self.tr_auto.start()
        # Если флажок не установлен, останавливаем автоматический режим
        else:
            self.condition = False
            if hasattr(self, 'tr_auto') and self.tr_auto.is_alive():
                self.tr_auto.join()

    def p_auto(self):
        """Основная функция для автоматического управления."""
        try:
            self._initialize_auto_params()
            while self.condition:
                self._process_auto_control()
        except Exception as e:
            print(e, 'p_auto')
            sleep(1)

    def _update_pid(self, setpoint, feedback):
        '''
          Функция обновления PID-регулятора.

          Эта функция принимает желаемую уставку (setpoint) и текущую обратную связь (feedback) в качестве аргументов и
          рассчитывает управляющий сигнал PID для регулирования системы.

          Параметры:
          setpoint (float): Желаемая уставка.
          feedback (float): Текущая обратная связь.

          Возвращает:
          float: Управляющий сигнал PID.

          '''
        # Рассчитать абсолютное значение ошибки между желаемой уставкой и текущей обратной связью.
        error = abs(setpoint - feedback)
        # Рассчитать компонент дифференциации (derivative) путем вычисления изменения ошибки с момента последнего обновления.
        derivative = error - self.last_error
        # Накапливать компонент интеграции (integral) путем суммирования ошибки с течением времени.
        self.integral += error
        # Вычислить управляющий сигнал PID на основе коэффициентов P, I и D и компонентов ошибки.
        output = (self.kp.value() * error) + (self.ki.value() * self.integral) + (self.kd.value() * derivative)
        # Обновить последнее значение ошибки для использования в следующей итерации.
        self.last_error = error
        # Вернуть вычисленный управляющий сигнал, который может быть применен для управления системой и минимизации ошибки.
        return output

    def _initialize_auto_params(self):
        """Инициализация параметров для автоматического управления."""
        # Определение датчика на основе выбранного значения в комбо-боксе
        self.sensor_for_auto = next(
            sensor for sensor in self.gradpa.dlg_ourch if sensor.name in self.comboA.currentText())
        self.index = self.comboA.findText(str(self.sensor_for_auto))

        # Определение диапазона значений
        self.diapozon = np.round(
            np.arange(self.ustA.value() - self.dopskA.value(), self.ustA.value() + self.dopskA.value(), 0.001,
                      dtype=float), 3)

        # Инициализация ошибок для PID-регулятора
        self.last_error = 0.0  # Последняя ошибка
        self.integral = 0.0  # Интеграл ошибки

    def _process_auto_control(self):
        """Цикл автоматического управления: импульс → анализ → пауза перед следующим действием."""
        self.sensor_data = float(
            f"{Damper.sensor_data.get((self.sensor_for_auto.reg, self.sensor_for_auto.ch), float('nan')):.3f}")
        self.impuls = round(max(0, self._update_pid(self.ustA.value(), self.sensor_data) or 0), 4) or 0

        # Определение действия
        on_action, off_action, value = (
                (self.sensor_data > self.limit.value() and ('turnOnRed', 'turnOffRed', self.timesleepaft.value())) or
                ((self.sensor_data < self.diapozon[0] or self.sensor_data < 0) and (
                    'turnOnGreen', 'turnOffGreen', self.impuls)) or
                (self.sensor_data > self.diapozon[-1] and ('turnOnRed', 'turnOffRed', self.impuls))
        )

        # Включаем сигнал
        self.pa.onButtonPressed(on_action)
        with self.all_impuls_mutex:
            self.pa.__class__.all_impuls.update({self.pa.name: self.impuls})
        sleep(value)  # длительность импульса (удержание сигнала)

        # Выключаем сигнал
        self.pa.onButtonPressed(off_action)
        with self.all_impuls_mutex:
            self.pa.__class__.all_impuls.update({self.pa.name: 0})

        # Контроль отклика и пауза перед следующим импульсом
        if self.chk_safe.isChecked():
            expected = 'open' if 'Green' in on_action else 'close'
            success = self.wait_and_check(expected=expected)

            if not success:
                print(f"[AUTO][{self.pa.name}] ❗ Нет реакции на {on_action}")

            # Адаптивная пауза между циклами
            delta = abs(self.sensor_data - self.ustA.value())
            base = self.timesleepaft.value()
            k = self.k_delay.value()
            maxd = self.max_delay.value()
            delay = min(base + k * delta, maxd)

            if self.behavior == 'скачок':
                print(f"[AUTO][{self.pa.name}] 💥 Скачок — пауза {delay:.2f} сек")
                sleep(delay)

            elif self.behavior == 'перелёт':
                delta_ust = self.ustA.value() - self.sensor_data
                if delta_ust > self.dopskA.value() * 3:
                    print(f"[AUTO][{self.pa.name}] ❗ Сильный перелёт — экстренное закрытие")
                    self.pa.onButtonPressed('turnOnRed')
                    sleep(1.5)
                    self.pa.onButtonPressed('turnOffRed')
                else:
                    print(f"[AUTO][{self.pa.name}] ↘ Незначительный перелёт — пауза {delay:.2f}")
                    sleep(delay)

            elif self.behavior == 'норма':
                print(f"[AUTO][{self.pa.name}] ✅ Норма — пауза {delay:.2f} сек")
                sleep(delay)

            elif self.behavior == 'нет реакции':
                print(f"[AUTO][{self.pa.name}] ⚠ Нет реакции — пауза {base:.2f} сек")
                sleep(base)
        else:
            # Без контроля отклика — обычная пауза после импульса
            sleep(self.timesleepaft.value())

    def wait_and_check(self, expected='open', step=0.2):
        """
        Проверяет, изменилась ли ситуация после импульса:
        - по концевикам (если есть)
        - по значению сенсора (если выбран)

        Также определяет характер отклика:
        - 'скачок' — резкое повышение давления
        - 'перелёт' — резкое понижение (пережатие)
        - 'норма' — корректное изменение
        - 'нет реакции' — ничего не изменилось

        :param expected: 'open' или 'close'
        :return: True если есть отклик, False если нет
        """

        timeout = self.timesleepaft.value()
        start_time = time.time()
        ok = False
        self.behavior = 'нет реакции'

        try:
            sensor_value_before = float(Damper.sensor_data.get(
                (self.sensor_for_auto.reg, self.sensor_for_auto.ch), float('nan')))
            chr_expected = self.pa.chr_open if expected == 'open' else self.pa.chr_close

            for _ in range(int(timeout / step)):
                QCoreApplication.processEvents()
                time.sleep(step)

                # Проверка по концевику
                if config['damper_data_queue'][self.pa.reg][chr_expected]:
                    self.behavior = 'норма'
                    ok = True
                    break

                # Проверка по сенсору
                sensor_value_now = float(Damper.sensor_data.get(
                    (self.sensor_for_auto.reg, self.sensor_for_auto.ch), float('nan')))
                if not math.isnan(sensor_value_before) and not math.isnan(sensor_value_now):
                    delta = sensor_value_now - sensor_value_before

                    if abs(delta) > 0.8:
                        self.behavior = 'скачок'
                    elif delta < -0.5:
                        self.behavior = 'перелёт'
                    elif abs(delta) > 0.05:
                        self.behavior = 'норма'
                    else:
                        self.behavior = 'нет реакции'

                    ok = self.behavior in ('норма', 'перелёт')
                    break
        except Exception as e:
            print(f"[AUTO][{self.pa.name}] wait_check error: {e}")

        return ok


class InfoWidget(QWidget):
    # Этот класс представляет собой пользовательский виджет, который может быть использован
    # для отображения информации и управления определенными параметрами в пользовательском интерфейсе.
    def __init__(self):
        super().__init__()
        self.pa = self.sender().parent()
        self.setFont(QFont("Arial", 12))

        self.layoutAW = QVBoxLayout()
        self.label1 = QLabel()
        self.label2 = QLabel()
        self.label3 = QLabel()
        self.label4 = QLabel()
        self.slider = QSlider()
        self.slider.setOrientation(Qt.Horizontal)
        self.slider.setRange(-100, 500)

        self.chk = QCheckBox()
        self.chk.stateChanged.connect(self.toggle_other_element)
        self.chklbl = QLabel()
        self.chklbl.setText('спрятать имя')

        self.const = QLineEdit()
        #self.const.setText(str(self.pa.amendment))

        self.const.setValidator(QRegExpValidator(QRegExp(r'-?\d*\.?\d+')))
        self.const.textChanged.connect(lambda: self.on_text_changed(self.const.text()))

        self.layoutAW.addWidget(self.chk)
        self.layoutAW.addWidget(self.chklbl)
        self.layoutAW.addWidget(self.slider)
        self.layoutAW.addWidget(self.label1)
        self.layoutAW.addWidget(self.label2)
        self.layoutAW.addWidget(self.label3)
        self.layoutAW.addWidget(self.label4)
        self.layoutAW.addWidget(self.const)
        self.setLayout(self.layoutAW)
        self.chk.stateChanged.connect(self.toggle_other_element)

        self.timer = QTimer(self)
        self.timer.setSingleShot(True)  # Устанавливаем однократный запуск
        self.timer.timeout.connect(self.process_text)

    def on_text_changed(self, text):
        # Сбрасываем таймер при каждом изменении текста
        self.pa.update_sensor_amendment.emit(text)
        self.timer.stop()
        self.timer.start(2000)  # Запускаем таймер на 3 секунды

    def process_text(self):
        # Метод, который будет вызван по истечении 3 секунд без изменений в тексте
        text = self.const.text()
        if text == '':
            text = '0'
        self.const.setText(text)
        self.pa.amendment = float(text)

    def toggle_other_element(self, state):
        try:
            if state == Qt.Checked:
                self.pa.l1.setText(' ')
            else:
                self.pa.l1.setText(f'{self.pa.name}')
        except AttributeError:
            pass


class Sensor(MovableObject):
    '''
    Класс Sensor представляет пользовательский виджет для отображения информации о сенсорах.

    Атрибуты:
    - name: Название сенсора.
    - reg: Регистр (с учетом смещения на 1).
    - ch: Канал (с учетом смещения на 1).
    - amendment: Поправка.
    - bit_depth: Разрядность.
    - l1: QPushButton с названием сенсора.
    - l2: QLabel с символом '♣'.
    - clr: Цвет сенсора.
    - ip: IP-адрес сенсора на основе регистра.
    - side_name: Название стороны, на которой сенсор отображается.
    - moveon: Флаг для перемещения сенсора.

    Методы:
    - bge(clr): Определяет стиль фона QLabel на основе цвета.
    - layoutside(side_name): Настроить макет в зависимости от выбранной стороны.
    - mousePressEvent(evt): Обрабатывает нажатие кнопки мыши для перемещения сенсора.
    - mouseMoveEvent(evt): Обрабатывает перемещение сенсора мышью и сохраняет его новую позицию.
    - poschange(): Изменяет позицию сенсора и перераспределяет элементы в макете.
    - info(): Отображает информацию о сенсоре в отдельном окне.
    - hidename(h): Скрывает или отображает имя сенсора в зависимости от значения h.
    - scaletext(value): Изменяет размер текста и размеры сенсора в зависимости от значения value.
    - __str__(): Возвращает строковое представление объекта Sensor.

    '''
    update_sensor_bord = pyqtSignal(str)  # сигнал: имя сенсора и новое значение
    update_sensor_amendment = pyqtSignal(str)
    def __init__(self, name='♥', ch=1, clr='bl', side_name='l', bit_depth=2, reg=1, amendment=0.0, parent=None):
        super(Sensor, self).__init__(parent)
        self.name = name
        self.reg = config['adjust_index'](reg)
        self.ch = config['adjust_index'](ch)
        self.amendment = amendment
        self.bit_depth = bit_depth
        self.l1 = QPushButton(self.name)
        self.l1.setFont(QFont("Arial", 13))
        self.l1.setStyleSheet('border : 5;background: transparent;')
        self.l2 = QLabel('♣')
        self.l2.setAlignment(Qt.AlignCenter)
        self.update_sensor_bord.connect(self.on_update_sensor_bord)
        self.clr = clr
        self.ip = list(config['IPS'])[self.reg]

        self.side_name = side_name
        self.layoutside(self.side_name)
        self.l2.setFont(QFont('Times', 18, weight=QFont.Bold))
        self.l2.setStyleSheet(self.bge(self.clr))

        self.l1.clicked.connect(self.info)
        self.moveon = False
        self.scaletext(config['sensor_size'])
        self.hidename(config['hidename'])
        self.l1.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.l2.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        #      layout.setContentsMargins(0, 0, 0, 0)
        #      layout.setSpacing(4)
        self.setToolTip(f"рег={self.reg}, канал={self.ch}")
        self.update_sensor_amendment.connect(self.amendment_eddit)

    @pyqtSlot(str)
    def amendment_eddit(self, amendment):
        self.amendment=float(amendment)
    @pyqtSlot(str)
    def on_update_sensor_bord(self, color):
        self.l2.setStyleSheet(color)

    def bge(self, clr):
        # выбор цвета
        clr = clr.lstrip('#')
        colors = {
            'si': '192,192,192',
            'wh': '255,255,255',
            'fu': '255,0,255',
            'pu': '238,130,238',
            're': '255,160,137',
            'ma': '128,0,0',
            'ye': '255,255,0',
            'ol': '128,128,0',
            'li': '0,255,0',
            'gr': '50,205,50',
            'aq': '0,255,255',
            'te': '0,128,128',
            'bl': '153,153,255',
            'na': '0,0,128'
        }

        if clr not in colors:
            return f'.QLabel{{background-color: #{clr};margin:1px;border:1px solid rgb(0,0,0);border-radius: 10px;}}'
        else:
            return f'.QLabel{{background-color: rgb({colors[clr]});margin:1px;border:1px solid rgb(0,0,0);border-radius: 10px;}}'

    def layoutside(self, side_name):
        # выбор стороны
        side_layouts = {
            'left': (150, 20, QHBoxLayout, [self.l1, self.l2]),
            'top': (110, 50, QVBoxLayout, [self.l1, self.l2]),
            'right': (150, 20, QHBoxLayout, [self.l2, self.l1]),
            'bottom': (110, 50, QVBoxLayout, [self.l2, self.l1])
        }

        side_name = side_name.lower()

        if side_name in side_layouts:
            width, height, layout_type, widgets = side_layouts[side_name]
            layout = layout_type(self)
            for widget in widgets:
                layout.addWidget(widget)

    def info(self):
        self.w = InfoWidget()
        self.w.label1.setText(f'{self}')
        self.w.label4.setText(f'{self.pos()}')
        self.w.slider.valueChanged.connect(self.scaletext)
        self.w.chk.stateChanged.connect(self.hidename)
        self.w.show()

    def hidename(self, h):
        self.l1.hide() if h == 1 else self.l1.show()

    def scaletext(self, value):
        try:
            value = int(value)
        except ValueError:
            value = 0  # запасной вариант

        value = max(-10, min(value, 500))  # диапазон -10..50

        self.l2.setFont(QFont('Times', 14 + value, weight=QFont.Bold))
        self.l2.setFixedSize(100 + value * 5, 35 + value)
        self.setFixedSize(150 + value * 5, 70 + value * 2)

    def __str__(self):
        return f"{self.name}  ch {self.ch}  reg {self.reg}"


class Translate(QPushButton):
    """
        Класс Translate представляет собой пользовательский виджет кнопки, который выполняет операции перекладки между элементами.
        """

    def __init__(self, z1, z2, damper_list, z1_sleep, z2_sleep, time_rearrangement, parent=None):
        super(Translate, self).__init__(parent)
        self.rearrangement_cond = True
        self.setGeometry(self.x(), self.y(), 150, 30)
        self.setFont(QFont("Fira Mono Bold", 13))
        self.name = f' {z1}←→{z2}'
        self.setText(f'{self.name}')
        self.setStyleSheet(
            "QPushButton {padding-top:7px;background-color: lightgreen;font: bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0}")
        self.clicked.connect(self.threading_rearrangement)
        self.z1 = next((i for i in damper_list if z1 in i.name), None)
        self.z2 = next((i for i in damper_list if z2 in i.name), None)
        self.z1_sleep = z1_sleep
        self.z2_sleep = z2_sleep
        self.time_rearrangement = time_rearrangement

    def threading_rearrangement(self):
        self.setEnabled(False)  # Отключите кнопку
        threading.Thread(target=self.rearrangement, args=[self.z1, self.z2]).start()

    def rearrangement(self, z1, z2):
        try:
            self.rearrange_elements(z1, z2)
        except Exception:
            warning_window('Check the limit switches')

    def rearrange_elements(self, active_element, inactive_element):
        """
                Управляет перестановкой элементов, изменением стилей и выполнением операций в отдельных потоках.
                """
        open_color, close_color = '#00FF00', '#FF0000'
        active_element.lab.setStyleSheet(f'background-color: {open_color if self.rearrangement_cond else close_color}')
        inactive_element.lab.setStyleSheet(
            f'background-color: {close_color if self.rearrangement_cond else open_color}')
        active_sleep, inactive_sleep = self.z1_sleep, self.z2_sleep
        button1, button2 = ('Green', 'Red') if self.rearrangement_cond else ('Red', 'Green')
        threading.Thread(target=self.execute, args=(active_element, active_sleep, button1)).start()
        threading.Thread(target=self.execute, args=(inactive_element, inactive_sleep, button2)).start()
        self.rearrangement_cond = not self.rearrangement_cond

    def execute(self, element, sleep_time, indicator_name):
        """
                Выполняет операции над элементом, включая установку цветовых индикаторов и временные задержки.
                """
        sleep(float(sleep_time))
        element.onButtonPressed(f'turnOn{indicator_name}')
        sleep(int(self.time_rearrangement))
        element.onButtonPressed(f'turnOff{indicator_name}')
        self.setEnabled(True)  # Включите кнопку снова


class Formula(Sensor, QWidget):
    def __init__(self, name, mathematics, clr, side_name, bit_depth=1):
        super().__init__()
        self.name = name
        self.clr = clr
        self.l2.setStyleSheet(self.bge(self.clr))
        self.mathematics = mathematics
        self.bit_depth = bit_depth
        self.l1.setText(self.name)
        self.layoutside(side_name)

    def __str__(self):
        return f'{self.name},{self.mathematics}'


class Const(Sensor, QWidget):
    def __init__(self, name, const, clr, side_name, bit_depth=1):
        super().__init__()
        self.name = name
        self.const = const
        self.clr = clr
        self.bit_depth = bit_depth
        self.moveon = False

        self.l2 = QLineEdit(self)
        self.l2.setText(str(self.const))
        self.l2.setFont(QFont('Times', 14, weight=QFont.Bold))
        self.l2.setFixedSize(80, 25)

        self.l1.setText(self.name)
        self.layoutside(side_name)  # ← обязательно!
        self.setStyleSheet(f"color: {self.clr}; background-color: transparent;")

        regex = QRegExp(r'-?\d*\.?\d+')
        validator = QRegExpValidator(regex)
        self.l2.setValidator(validator)
        self.l2.textChanged.connect(self.on_text_changed)

        # Таймер для отложенной обработки
        self.timer = QTimer(self)
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.process_text)

        # Сохраняем ссылку на себя
        config.setdefault('constants', {})[self.name] = self

    def on_text_changed(self, text):
        self.timer.stop()
        self.timer.start(2000)

    def process_text(self):
        text = self.l2.text()
        if text in ['', '0', '0.']:
            text = '1'
        try:
            self.const = float(text)
            self._update_setting_file()

            # 🔁 Автоперерасчёт формул
            parent = self.parent()
            if hasattr(parent, "formuls") and hasattr(parent, "calculate_formulas"):
                formulas = [f.name for f in parent.formuls]
                parent.calculate_formulas(formulas)

        except ValueError:
            self.l2.setText(str(self.const))  # откат

    def _update_setting_file(self):
        try:
            path = config.get('setting_file', 'setting1.txt')
            with open(path, 'r', encoding='utf-8') as f:
                lines = f.readlines()

            with open(path, 'w', encoding='utf-8') as f:
                for line in lines:
                    if line.startswith('Const') and line.split()[1] == self.name:
                        parts = line.split()
                        parts[2] = str(self.const)
                        line = ' '.join(parts) + '\n'
                    f.write(line)
        except Exception as e:
            print(f"[Const Save Error] {e}")


class Furnace(QSlider):
    sensor_data = []

    """Печи"""

    def __init__(self, name='♥', ch_ao=1, diapason=8.0, reg=1, x=0, y=0, parent=None):
        super(Furnace, self).__init__(parent)

        self.clicked_once = False
        self.last_warning_time_dp = 0.0
        self.last_warning_time_dt = True
        self.second = 1
        self.condition = False
        self.ch_ao = config['adjust_index'](ch_ao)
        self.reg = config['adjust_index'](reg)
        self.diapason = diapason

        self.ip = list(config['IPS'])[self.reg]
        self.client = ModbusClient(
            host=self.ip,
            port=502,
            unit_id=1,
            auto_open=True)

        handlers = {
            'daq': self.handle_daq,
            'opc': self.handle_opc,
            'modbus': lambda: setattr(self, 'modbus', True),
            'elemer': lambda: setattr(self, 'elemer', True)
        }

        handlers[config['IPS'].get(self.ip)]()
        self.name = name
        self.resize(30, int(parent.frameGeometry().height() / 4))
        self.lb = QLabel(self.parent())
        self.lb.setText('0.0')
        self.lb.setFont(QFont('Arial', 11))
        self.lb.move(int(x), int(y) + self.height())
        self.parent().layout().addWidget(self.lb)
        self.setSingleStep(10)
        self.setRange(0, int(self.diapason * 10))
        self.valueChanged.connect(lambda v: self.lb.setText(str(v / 1000)))

        # Параметры ПИД-регулятора
        self.setpoint = 0.0  # Уставка ПИД-регулятора
        self.last_error = 0.0  # Последняя ошибка
        self.integral = 0.0  # Интеграл ошибки
        self.output = 0.0  # Выходное значение

        self.container_hight = QWidget(self.parent())
        row_layout_0 = QVBoxLayout(self.container_hight)

        container_widget = QWidget()
        row_layout = QHBoxLayout(container_widget)
        self.button = QCheckBox()
        self.button.stateChanged.connect(self.toggle_pid)
        self.pid_enabled = False

        self.setpoint_value = QDoubleSpinBox()
        self.setpoint_value.setMaximum(999)
        self.setpoint_value.setDecimals(0)

        self.sensordt = QComboBox()
        self.sensordt.currentIndexChanged.connect(self.value_changed)
        self.first_mouse_clickdt = True
        self.sensordt.installEventFilter(self)

        self.sensordp = QComboBox()
        self.sensordp.currentIndexChanged.connect(self.value_changed)
        self.first_mouse_clickdp = True
        self.sensordp.installEventFilter(self)

        row_layout.setContentsMargins(0, 0, 0, 0)  # Устанавливаем отступы в 0 пикселей
        row_layout.addWidget(self.button, 1)  # первый виджет, 1/4 пространства
        row_layout.addWidget(self.setpoint_value, 3)  # второй виджет, 3/4 пространства
        row_layout_0.addWidget(container_widget)
        row_layout_0.addWidget(self.sensordt)
        row_layout_0.addWidget(self.sensordp)
        self.kp = QDoubleSpinBox(self.parent())
        self.kp.setSuffix(' kp')
        row_layout_0.addWidget(self.kp)

        self.kp.setValue(20)
        self.kp.setDecimals(4)
        self.kp.setMinimum(-999)
        self.kp.setMaximum(999)

        self.ki = QDoubleSpinBox(self.parent())
        self.ki.setSuffix(' ki')
        self.ki.setMaximum(999)
        self.ki.setMinimum(-999)

        row_layout_0.addWidget(self.ki)

        self.ki.setDecimals(4)
        self.ki.setValue(0.45)

        self.kd = QDoubleSpinBox(self.parent())
        self.kd.setDecimals(4)
        self.kd.setMaximum(999)
        self.kd.setMinimum(-999)
        self.kd.setSuffix(' kd')
        row_layout_0.addWidget(self.kd)
        self.kd.setValue(200)

        self.T = QDoubleSpinBox(self.parent())
        self.T.setSuffix(' Ti')
        self.T.setDecimals(4)
        self.T.setMaximum(999)
        self.T.setValue(3)
        row_layout_0.addWidget(self.T)

        self.Max_mV = QDoubleSpinBox(self.parent())
        self.Max_mV.setDecimals(4)
        self.Max_mV.setMaximum(20)
        self.Max_mV.valueChanged.connect(lambda value: self.setRange(0, int(value * 1000)))
        row_layout_0.addWidget(self.Max_mV)
        self.container_hight.setGeometry(int(x) + self.width(), int(y), 85, 180)
        self.Max_mV.setValue(self.diapason)

        self.valueChanged.connect(self.onSliderChange)
        self.timerSlider = QTimer()
        self.timerSlider.setSingleShot(True)  # Устанавливаем однократное срабатывание
        self.timerSlider.timeout.connect(self.tz)

    def onSliderChange(self):
        self.timerSlider.start(1000)

    def handle_daq(self):
        try:
            self.daq = [key.split('/')[0] for key, value in config['daq_configuration'].items() if 'ao' in key][0]
        except Exception:
            pass

    def handle_opc(self):
        ip_part = ''.join([part.zfill(3) for part in self.ip.split('.', 2)[2].split('.')])
        self.modopc = config['daq_prefix'][0] + ip_part + config['daq_prefix'][1]

        self.opc = OpenOPC.client()

    def __str__(self):
        return f"{self.name}"

    def mousePressEvent(self, event):
        if not self.clicked_once:
            self.container_hight.show()
            self.clicked_once = True
        super().mousePressEvent(event)

    def eventFilter(self, obj, event):
        if obj == self.sensordt and event.type() == QEvent.MouseButtonPress and event.button() == 1:
            if self.first_mouse_clickdt:
                self.on_activated('DT')
                self.first_mouse_clickdt = False
            if self.first_mouse_clickdp:
                self.on_activated('DA')
                self.first_mouse_clickdp = False
            return True
        return super().eventFilter(obj, event)

    def on_activated(self, type):
        if type == 'DT':
            self.sensordt.addItems(
                [f'{sn.name}_{sn.ch}_{sn.reg}_{i}' for i, sn in enumerate(dlgMain.dlg_ourch) if type in sn.name])
        if type == 'DA':
            self.sensordp.addItems(
                [f'{sn.name}_{sn.ch}_{sn.reg}_{i}' for i, sn in enumerate(dlgMain.dlg_ourch) if type in sn.name])

    def value_changed(self, sender):
        try:
            if sender == 'DT':
                print(self.sensor_data)
                vl = self.sensordt.currentText().split('_')
                reg, ch = int(vl[2]), int(vl[3])
                datavl = self.sensor_data.get((reg, ch), float('nan'))
                return datavl
            if sender == 'DA':
                vl = self.sensordp.currentText().split('_')
                datavl = self.sensor_data[int(vl[2])][int(vl[3])]
                return datavl

        except IndexError:
            warning_window('Выберити датчики для отслеживания PID', False)

    def tz(self):
        if config['imitation']: return
        fr = threading.Thread(target=self.signal, args=[self.value()])
        fr.start()
        fr.join()

    def send_daq_signal(self, value):
        with nidaqmx.Task() as task:
            task.ao_channels.add_ao_current_chan(f"{self.daq}/ao{self.ch_ao}",
                                                 name_to_assign_to_channel="Analog_Output_Channel")

            task.write(value / 1000000, auto_start=True)

    def send_opc_signal(self, value):
        try:
            node = self.opc.get_node(f"ns=2;s={self.name}.AO{self.ch_ao + 1:02d}Value")
            node.set_value(float(value))
        except Exception as e:
            print(f"[OPC UA] AO write error: {e}")

    def send_modbus_signal(self, value):
        v = struct.unpack('>l', struct.pack('>f', value / 1000000))[0]
        x = [(v & 0xffff), (v >> 16)]
        sleep(0.1)
        self.client.write_multiple_registers(self.ch_ao * 2, x)
        # self.c.close()

    def send_elemer_signal(self, value):
        pass

    def signal(self, value):
        protocol_handlers = {
            'daq': lambda: self.send_daq_signal(value),
            'opc': lambda: self.send_opc_signal(value),
            'modbus': lambda: self.send_modbus_signal(value),
            'elemer': lambda: self.send_elemer_signal(value)
        }
        protocol_handlers[config['IPS'].get(self.ip)]()

    def update_pid(self):
        if self.value_changed('DA') < 0.1:
            current_time = time.time()
            if current_time - self.last_warning_time_dp > 60:  # Проверка времени с последнего предупреждения
                warning_window('Низкое давление PID', False)
                self.last_warning_time_dp = current_time  # Обновление времени последнего предупреждения
            self.setValue(0)
            self.toggle_pid()
            return

        frirst = self.value_changed('DT')
        if self.setpoint_value.value() <= int(frirst) and frirst - self.second >= 0:
            self.condition = True
        if frirst > self.setpoint_value.value() + 5 and self.condition:
            if self.last_warning_time_dt:  # Проверка времени с последнего предупреждения
                self.last_warning_time_dt = False
                self.setValue(int(self.value() / 1.5))
            if frirst - self.second <= 0:
                self.condition = False
            self.second = frirst
            return
        self.last_warning_time_dt = True
        error = self.setpoint_value.value() - self.value_changed('DT')  # Разность между уставкой и текущим значением
        self.integral += error  # Интеграл ошибки
        derivative = error - self.last_error  # Дифференциал ошибки
        self.output = self.kp.value() * error + self.ki.value() * self.integral + self.kd.value() * derivative
        self.last_error = error  # Сохранение текущей ошибки
        self.setValue(int(self.output))

    def toggle_pid(self):
        self.pid_enabled = not self.pid_enabled  # Инвертировать текущее состояние ПИД-регулятора
        self.last_error = 0.0  # Последняя ошибка
        self.integral = 0.0  # Интеграл ошибки
        self.output = 0.0  # Выходное значение

        if self.pid_enabled:
            self.timer = QTimer(self)  # Таймер для обновления ПИД-регулятора
            self.timer.timeout.connect(lambda: threading.Thread(target=self.update_pid()))
            self.timer.start(int(self.T.value()) * 1000)  # Интервал обновления ПИД-регулятора (в миллисекундах)
        else:
            self.setValue(0)
            self.timer.stop()


class SquareWidget(QWidget):
    posChanged = pyqtSignal(tuple)
    color_changed = pyqtSignal(QColor)

    def __init__(self, pa, index=0, fill=False, w=400, h=100, check=False, x=120, y=120):
        super().__init__(parent=pa)
        self.alive = True  # признак, что виджет ещё жив
        self.square_width = w  # начальная ширина квадрата
        self.square_height = h  # начальная высота квадрата
        self.setFocusPolicy(Qt.StrongFocus)  # устанавливаем фокус на виджет
        self.dragging = False
        self.offset = QPoint()
        self.check = check
        self.index = index
        self.label = QLabel(self)
        self.label.setText(f'{self.pos().x(), self.pos().y()},{self.index + 1}')
        self.label.resize(200, 20)  # Устанавливаем размер метки (ширина, высота)
        self.label.setFont(QFont('Arial', 15))
        self.label.move(self.width() // 4, self.height() // 2)
        self.label.hide()
        self.fill = fill
        self.x = (self.parent().width()) // 2
        self.y = (self.parent().height()) // 2
        self.setGeometry(self.x, self.y, 220, 50)
        self.move(50, self.parent().size().height() - 300)
        self.labl_vision = False
        self.color = 'yeallow'

    def labl_vision_def(self):
        self.label.show() if self.labl_vision else self.label.hide()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and self.check:
            self.dragging = True
            self.offset = event.pos()

    def mouseDoubleClickEvent(self, event):
        if self.check:
            self.fill = not self.fill

    def mouseMoveEvent(self, event):
        if self.dragging and self.check:
            self.move(self.pos() + event.pos() - self.offset)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.check:
            self.dragging = False

            if self.check:
                # self.label.setText(f'{self.pos().x(), self.pos().y()},{self.index + 1}')
                self.label.show()
                pos_tuple = (self.pos().x(), self.pos().y())
                self.posChanged.emit(pos_tuple)  # Вызываем сигнал с передачей значения pos_tuple

    def keyPressEvent(self, event):
        step = 5
        if not self.check:
            return
        if event.key() == Qt.Key_Left:
            self.square_width = max(self.square_width - step, 1)
        elif event.key() == Qt.Key_Right:
            self.square_width += step
        elif event.key() == Qt.Key_Up:
            self.square_height += step
        elif event.key() == Qt.Key_Down:
            self.square_height = max(self.square_height - step, 1)
        else:
            return
        self.updateGeometry()

    def updateGeometry(self):
        parent_rect = self.parent().rect()
        new_width = min(self.square_width, parent_rect.width())
        new_height = min(self.square_height, parent_rect.height())
        self.setGeometry(
            self.pos().x(),
            self.pos().y(),
            new_width,
            new_height,
        )
        self.label.resize(
            new_width,
            new_height)

    def set_color(self, color):
        self.color = color
        self.color_changed.emit(QColor(color))  # сигнал для Set_point
        self.update()  # перерисовать

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)  # сглаживание
        pen = painter.pen()

        if not self.fill:
            painter.setBrush(Qt.NoBrush)  # прозрачная заливка
        else:
            painter.setBrush(Qt.black)
        if self.color == 'green':
            pen.setColor(QColor(0, 161, 31))
            pen.setWidth(10)  # увеличить толщину рамки на 5
        elif self.color == 'red':
            pen.setColor(Qt.red)
            pen.setWidth(10)  # увеличить толщину рамки на 5
        else:
            pen.setColor(QColor(244, 169, 0))
            pen.setWidth(10)  # увеличить толщину рамки на 2
            pen.setStyle(Qt.DashLine)  # добавить пунктирный стиль

        painter.setPen(pen)
        x = 0
        y = 0
        width = self.width()
        height = self.height()
        painter.drawRect(x, y, width, height)


class Set_point(QWidget):
    sensor_data = None
    name_formuls = []
    formuls = []

    def __init__(self, pa, index):
        super().__init__(parent=pa)
        self.alive = True
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.setWindowTitle("Sensor Configuration")
        self.setFont(QFont('Arial', 14))
        self.index = index
        layout = QGridLayout(self)
        layout.setVerticalSpacing(1)  # Устанавливаем отступ между рядами равным 5 пикселей
        self.sensorlist = pa.sensor_list
        self.formulslist = pa.formuls
        self.description_input = QLineEdit()
        self.description_input.setPlaceholderText("Описание")
        self.description_input.setMinimumSize(85, 17)
        layout.addWidget(self.description_input, 0, 0, 1, 2)  # row 0, column 0

        self.sensor_input = QComboBox()
        self.sensor_input.addItems([i.name for i in self.sensorlist])
        self.sensor_input.addItems([i.name for i in self.formulslist])
        self.sensor_input.setPlaceholderText("Датчик")
        layout.addWidget(self.sensor_input, 0, 2)  # row 0, column 1

        self.setpoint_input = QDoubleSpinBox()
        self.setpoint_input.setDecimals(3)
        self.setpoint_input.setSingleStep(0.1)
        self.setpoint_input.setMinimum(-999)
        self.setpoint_input.setMaximum(999)
        self.setpoint_input.setSuffix("У")
        layout.addWidget(self.setpoint_input, 0, 3)  # row 0, column 3, span 1 row and 2 columns
        self.tolerance_input = QDoubleSpinBox()
        self.tolerance_input.setSingleStep(0.1)  # Установить шаг равным 0.1

        self.tolerance_input.setSuffix("Д")
        self.tolerance_input.setDecimals(3)
        layout.addWidget(self.tolerance_input, 0, 4)  # row 0, column 4
        self.toggle_square = QCheckBox("Показать рамки")
        self.toggle_square.setChecked(False)
        self.toggle_square.stateChanged.connect(self.toggle_square_visibility)
        layout.addWidget(self.toggle_square, 0, 6)
        self.checkbox = QCheckBox('Редактирование рамки')
        layout.addWidget(self.checkbox, 0, 5)  # row 0, column 5
        self.square_widget = SquareWidget(pa, index=self.index)  # на dlgMain
        self.square_widget.color_changed.connect(self.update_border)
        self.square_widget.show()
        self.square_widget.mouseDoubleClickEvent = self.square_widget_double_click
        self.description_input.textChanged.connect(self.description_input_changed)
        self.setLayout(layout)
        self.checkbox.stateChanged.connect(self.checkbox_state_changed)
        self.move(10, self.parent().size().height() - 300)
        self.load_settings()  # Load the saved settings
        self.data_condition_changed()
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(2)

    # self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
    # self.setMinimumSize(0, 0)

    # for w in self.findChildren(QWidget):
    #     w.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
    #     w.setMinimumSize(0, 0)

    def toggle_square_visibility(self, state):
        if hasattr(self, "square_widget") and self.square_widget:
            self.square_widget.setVisible(state == Qt.Checked)

    def update_border(self, color=None):
        if color is None:
            color = QColor("gray")

        # получить цвет рамки и осветлённую версию для фона
        border_color = color.name()
        background_color = color.lighter(160).name()  # 160% светлее

        self.setStyleSheet(f"""
        
                border: 2px solid {border_color};
                border-radius: 6px;
                background-color: {background_color};
                padding: 6px;
           
        """)

    def scaletext(self, value):
        try:
            value = int(value)
        except ValueError:
            value = 0

        value = max(-30, min(value, 70))  # расширенный диапазон

        font_size = max(6, 12 + value)  # не даём шрифту уйти в 0
        font = QFont('Arial', font_size)

        for widget in self.findChildren(QWidget):
            widget.setFont(font)

        self.setMinimumHeight(40 + value * 2)
        self.setStyleSheet(f"font-size: {font_size}px;")  # на всякий случай

    def description_input_changed(self):
        self.square_widget.label.setText(f'{self.description_input.text()}')

    def square_widget_double_click(self, event):
        self.hide() if self.isVisible() else self.show()

    def load_settings(self):
        try:
            settings = QSettings("Teplo", f"{config["IZDELIE"]}_SensorSettings_{self.index}")  # Use a unique identifier for each instance
            description = settings.value("description")
            sensor = settings.value("sensor")
            setpoint = settings.value("setpoint")
            tolerance = settings.value("tolerance")
            position = settings.value("square_widget_position", self.square_widget.pos())
            size = settings.value("size")  # Get the size as a QSize object

            self.description_input.setText(description)
            self.sensor_input.setCurrentText(sensor)
            self.setpoint_input.setValue(float(setpoint))
            self.tolerance_input.setValue(float(tolerance))
            self.move(position)
            self.square_widget.move(position)  # Move the square widget to the loaded position
            if size is not None:
                width, height = size.width(), size.height()
            else:
                default_size = QSize(220, 50)  # Set default size
                width, height = default_size.width(), default_size.height()
            self.square_widget.resize(width, height)
        except:
            pass

    def save_settings(self):
        settings = QSettings("Teplo", f"{config["IZDELIE"]}_SensorSettings_{self.index}")  # Use a unique identifier for each instance
        description = self.description_input.text()
        sensor = self.sensor_input.currentText()
        setpoint = self.setpoint_input.value()
        tolerance = self.tolerance_input.value()
        position = self.square_widget.pos()
        size = self.square_widget.size()

        settings.setValue("square_widget_position", position)
        settings.setValue("description", description)
        settings.setValue("sensor", sensor)
        settings.setValue("setpoint", setpoint)
        settings.setValue("tolerance", tolerance)
        settings.setValue("size", size)

    def checkbox_state_changed(self, state):
        setattr(self.square_widget, 'check', state)
        setattr(self.square_widget, 'labl_vision', state)
        self.square_widget.labl_vision_def()
        self.save_settings()

    def data_condition_changed(self):
        def check_condition():
            while True:
                # ✅ Безопасность перед всеми действиями
                if not getattr(self, 'alive', True):
                    return
                if not hasattr(self, "sensor_input") or not self.sensor_input:
                    return
                if not hasattr(self, "square_widget") or not self.square_widget or not getattr(self.square_widget,
                                                                                               'alive', True):
                    return
                try:
                    sensor_name = self.sensor_input.currentText()
                    sens = next((s for s in self.sensorlist if s.name == sensor_name), None)

                    if sens is None:
                        sens = next((f for f in self.formulslist if f.name == sensor_name), None)
                        index = self.formulslist.index(sens)
                        sens_data = Set_point.formuls[index]
                    else:
                        key = (sens.reg, sens.ch)
                        sens_data = Set_point.sensor_data.get(key, float('nan'))

                    setpoint_input = self.setpoint_input.value()
                    tolerance_input = self.tolerance_input.value()

                    lower = setpoint_input - tolerance_input
                    upper = setpoint_input + tolerance_input

                    if lower <= sens_data <= upper:
                        color = 'green'
                    elif sens_data > upper:
                        color = "red"
                    else:
                        color = "yellow"
                    self.square_widget.set_color(color)
                    sens.update_sensor_bord.emit(sens.l2.styleSheet()[:-1] + "border: 6px solid " + color + ";}")

                except Exception:
                    # Здесь тоже нужна защита, чтобы self.square_widget не упал
                    if hasattr(self, "square_widget") and self.square_widget and getattr(self.square_widget, 'alive',
                                                                                         True):
                        self.square_widget.set_color(False)
                time.sleep(1)

        thread = threading.Thread(target=check_condition)
        thread.daemon = True
        thread.start()


class Timers(QMainWindow):
    sensor_data = None
    name_formuls = []
    formuls = []

    def __init__(self, start_hour=0, start_minute=0, start_second=0, start_msecond=0):
        super().__init__()
        self.setWindowTitle("Таймер")
        self.setWindowFlags(Qt.Window)

        self.end = QLabel()
        self.start = QLabel()
        self.setFont(QFont('Arial', 18))
        self.last = False
        self.condition = True
        settings = QSettings('Teplo', f"{config["IZDELIE"]}_timers")
        self.cond = False
        layh = QHBoxLayout()
        self.timers = QComboBox()
        layh.addWidget(self.timers)
        self.timers_settings_build(settings)
        self.timer_numbers = QLineEdit()

        self.input_number_cycles = QSpinBox()
        self.input_number_cycles.setFont(QFont('Arial', 14))
        self.input_number_cycles.setMaximum(1000000)
        self.input_number_cycles.setSuffix('  число циклов')
        layh.addWidget(self.input_number_cycles)

        self.add_timer = QPushButton("Добавить таймер")
        self.exp_timer = QPushButton("Экспорт таймеров")
        self.add_timer.clicked.connect(lambda: self.add_timer_combobox(settings))
        self.exp_timer.clicked.connect(lambda: self.export_registry_directory(r'HKEY_CURRENT_USER\SOFTWARE\Teplo\m7m',
                                                                              fr'{config["IZDELIE"]}\{config["IZDELIE"]}.reg'))

        self.delete_timer = QPushButton("Удалить таймер")
        self.delete_timer.clicked.connect(lambda: self.del_timer_combobox(settings))
        self.action_timers = QComboBox()
        max_width = max(self.action_timers.view().sizeHintForColumn(0), self.action_timers.width())
        self.action_timers.setMinimumWidth(max_width)

        self.start_time = QLabel()
        self.end_time = QLabel()
        self.timers_cb_b = QPushButton("Добавить событие", self)
        self.htimebox = QHBoxLayout()
        self.time_input = QTimeEdit()
        self.time_input.setFont(QFont('Arial', 15))
        self.time_input.setDisplayFormat("HH:mm:ss.zzz")
        self.time_input.setTime(QTime(start_hour, start_minute, start_second, start_msecond))
        self.trlist = dlgMain.translate_list
        self.dmplist = dlgMain.dampers_list
        self.furanceslist = dlgMain.furnace_list
        self.sensorlist = dlgMain.sensor_list
        self.math = Timers.name_formuls
        self.layoutH = QHBoxLayout()

        self.action_cb_list = QComboBox()
        self.action_cb_list.addItem('ожидание')
        self.action_cb_list.addItems([tr.name for tr in self.trlist])
        self.action_cb_list.addItems([dmp.name for dmp in self.dmplist])
        self.action_cb_list.addItems([str(fur) for fur in self.furanceslist])
        self.action_cb_list.addItems([sen.name for sen in self.sensorlist])
        self.action_cb_list.addItems([m for m in self.math])

        self.action_cb_list.currentIndexChanged.connect(self.reset_values)

        self.inptust = QDoubleSpinBox()
        self.inptust.setSuffix('  уст')
        self.inptust.setFont(QFont('Arial', 15))

        self.inptdop = QDoubleSpinBox()
        self.inptdop.setSuffix('  доп')

        self.inptdop.setFont(QFont('Arial', 15))

        self.inptdop.setMaximum(999)
        self.inptust.setMaximum(999)
        self.inptdop.setDecimals(4)
        self.inptust.setDecimals(4)
        self.name_sen = QLineEdit()
        self.name_sen.setPlaceholderText('инпут')
        self.info_input = QLineEdit()
        self.info_input.setPlaceholderText('коментарий')
        self.question_button = QPushButton()
        self.question_button.setText('?')
        self.question_button.setFont(QFont('Arial', 12))
        self.question_button.setToolTip(
            "Поле 'задержка' работает совсеми событиями\nДля 'объекта' 'ожидания' указать продолжительность в поле 'задержки'\nДля отслеживания датчика выбрать 'объект' датчик(DA1)указать уставку и допуск ,а также создать событие 'ожидание' перед событием датчика\nДля работы автомата заслонки выбрать 'объект' заслонку(RU1) указать уставку,допуск и датчик отслеживания ввести в поле инпут: DA1\nДля работы автомата печи выбрать 'объект' печь(F1) неоходима указать уставку и датчики отслеживания ввести в поле инпут: DT1-DA1\nДля подачи сигнала на открытия либо закрытия выбрать 'объект' заслонку(RU1) в поле уставки указать продолжительность в секундах (10 уст) ввести в поле инпут : открыть/закрыть\nДля влкючения/выключения автомата заслонки/печи выбрать 'объект' для манипуляции(RU1/F1) ввести в поле инпут: включить/выключить\nДля выполнение события только 1 раз(первом круге) ввести в поле инпут добавить *: DA1* (для ожидания: *) ")
        self.question_button.setToolTipDuration(30000)
        self.question_button.setStyleSheet('QToolTip { font: bold 18px Arial; color:black;}')
        self.lablobj = QLabel('Объект')
        self.layoutH.addWidget(self.lablobj, 1)
        self.layoutH.addWidget(self.action_cb_list, 1)
        self.layoutH.addWidget(self.inptust, 1)
        self.layoutH.addWidget(self.inptdop, 1)
        self.layoutH.addWidget(self.name_sen, 2)
        self.layoutH.addWidget(self.question_button)
        """    self.button = QCheckBox()
        self.button.stateChanged.connect(self.toggle_pid)
        self.pid_enabled = False

        self.setpoint_value = QDoubleSpinBox()"""
        self.timers_cb_del = QPushButton('Удалить событие')

        self.timers_start_timer = QPushButton('Старт_Логики')
        self.timers_start_timer.setStyleSheet("""
            QPushButton {
                background-color: green;
                color: white; 
                font-family: Arial;
                font-size: 18px;
            }
            QPushButton:pressed {
                background-color: darkgreen;
            }
        """)

        self.timers_start_timer.clicked.connect(lambda: self.start_timer(settings))

        self.continuous_checkbox = QCheckBox('первый круг')
        self.continuous_checkbox.setFont(QFont('Arial', 14))
        self.last_cycle = QCheckBox('завершающий цикл')
        self.last_cycle.setFont(QFont('Arial', 14))
        self.last_cycle.stateChanged.connect(
            lambda state: setattr(self, 'last', True if state == Qt.Checked else False))
        self.reform_action_timers(settings)
        self.timer_stop = QPushButton('Стоп')
        self.timer_stop.setStyleSheet("""
            QPushButton {
                background-color: red;
                color: white;  /* Установите цвет текста кнопки */
                font-family: Arial;
                font-size: 18px;
            }
            QPushButton:pressed {
                background-color: darkred;
            }
        """)

        self.alarm_stop = QPushButton('аварийный')
        self.alarm_stop.setStyleSheet("""
                    QPushButton {
                        background-color: red;
                        color: white;  /* Установите цвет текста кнопки */
                        font-family: Arial;
                        font-size: 18px;
                    }
                    QPushButton:pressed {
                        background-color: darkred;
                    }
                """)
        self.alarm_stop.clicked.connect(self.alarm_stop_def)
        self.lb_cycle = QLabel('Циклов: 0')
        self.timers.currentIndexChanged.connect(
            lambda: self.lb_cycle.setText(settings.value(f'cycle_{self.timers.currentText()}')))
        # Создаём центральный виджет для QMainWindow
        central = QWidget()
        self.setCentralWidget(central)

        # Layout для центрального содержимого
        vbox = QVBoxLayout(central)

        vbox.addLayout(layh)

        hbox0 = QHBoxLayout()
        hbox0.addWidget(self.add_timer)
        hbox0.addWidget(self.exp_timer)
        hbox0.addWidget(self.delete_timer)
        vbox.addLayout(hbox0)

        self.htimebox.addWidget(self.time_input)
        self.htimebox.addWidget(QLabel('    Задержка'))
        vbox.addLayout(self.htimebox)

        vbox.addLayout(self.layoutH)
        vbox.addWidget(self.info_input)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(self.timers_cb_b)
        hbox1.addWidget(self.timers_cb_del)
        vbox.addLayout(hbox1)

        hbox2 = QHBoxLayout()
        hbox2.addWidget(self.continuous_checkbox)
        hbox2.addWidget(self.last_cycle)
        vbox.addWidget(self.action_timers)
        vbox.addLayout(hbox2)

        self.reset_button = QPushButton('Сброс_циклов')
        self.reset_button.clicked.connect(lambda: self.reset_cycle(settings=settings))

        hbox3 = QHBoxLayout()
        hbox3.addWidget(self.timers_start_timer)
        hbox3.addWidget(self.reset_button)
        hbox3.addWidget(self.timer_stop)
        hbox3.addWidget(self.alarm_stop)
        vbox.addLayout(hbox3)

        self.info = QLabel()
        # vbox.addWidget(self.info)  # если нужно отобразить

        hbox4 = QHBoxLayout()
        hbox4.addWidget(self.start_time)
        hbox4.addWidget(QLabel(' - '))
        hbox4.addWidget(self.end_time)
        hbox4.addWidget(self.lb_cycle, 2)
        vbox.addLayout(hbox4)

        hbox5 = QHBoxLayout()
        hbox5.addWidget(self.start)
        hbox5.addWidget(QLabel(' - '))
        hbox5.addWidget(self.end)
        vbox.addLayout(hbox5)

        # Остальные действия
        self.timers_cb_del.clicked.connect(lambda: self.del_action(settings=settings))
        self.timers_cb_b.clicked.connect(
            lambda: self.add_action_to_combo_box(settings=settings, count=self.action_timers.count()))
        self.iteration_count = 0
        self.setMouseTracking(True)
        self.dragging = False
        self.offset = None

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.dragging = True
            self.offset = event.pos()

    def mouseMoveEvent(self, event):
        if self.dragging:
            new_pos = self.mapToParent(event.pos() - self.offset)
            self.move(new_pos)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.dragging = False
            self.offset = None
            self.setCursor(Qt.ArrowCursor)  # ← вернуть курсор обратно

    def mouseDoubleClickEvent(self, event):
        self.hide()

    def export_registry_directory(self, key_path, output_file):
        subprocess.run(['reg', 'export', key_path, output_file, '/y'], check=True)

    def alarm_stop_def(self):
        self.timer_stop.click()
        self.iteration_count = 0
        self.timers.setCurrentIndex(self.timers.count() - 1)
        self.action_timers.setCurrentIndex(0)
        self.timers_start_timer.click()

    def reset_cycle(self, settings):
        cycle = settings.value(f'cycle_{self.timers.currentText()}')
        cycle = '0_' + cycle.split('_')[1]
        self.lb_cycle.setText(cycle)
        settings.setValue(f'cycle_{self.timers.currentText()}', cycle)

    def reset_values(self):
        self.inptust.setValue(0.0)
        self.inptdop.setValue(0.0)
        self.name_sen.setText('')
        self.info_input.setText('')
        self.time_input.setTime(QTime(0, 0, 0))

    def timers_settings_build(self, settings):
        self.timers.clear()
        self.timer_settings = [setting for setting in settings.allKeys() if
                               'timer' in setting.lower() and 'cycle_' not in setting.lower()]
        self.timers.addItems(self.timer_settings)
        self.timers.currentIndexChanged.connect(lambda: self.reform_action_timers(settings))

    #   self.input_number_cycles.setValue()

    def add_timer_combobox(self, settings):
        if self.timers.currentIndex() < self.timers.count() - 1 or len(self.timers.currentText()) > 7:
            name = self.timers.currentText()[:7]
            counter = 0
            while settings.contains(name):
                name = name[:7]
                name = f'{name}_{counter}'
                counter += 1
        else:
            try:
                name = f'timer_' + str(int(self.timers.currentText().split('_')[1]) + 1)
            except IndexError:
                name = 'timer_0'
        self.timers.insertItem(self.timers.currentIndex() + 1, name)
        settings.setValue(name, [])
        self.timers_settings_build(settings)
        if not settings.contains(f'cycle_{name}'):
            cycle = '0_' + str(self.input_number_cycles.value())
            settings.setValue(f'cycle_{name}', cycle)

    def del_timer_combobox(self, settings):
        name = self.timers.currentText()
        [settings.remove(key) for key in settings.allKeys() if name in key]
        self.timers.removeItem(self.timers.currentIndex())
        self.timers_settings_build(settings)

    def reform_action_timers(self, settings):
        self.action_timers.clear()
        action_timers = settings.value(self.timers.currentText())
        if action_timers is not None:
            self.action_timers.addItems(action_timers)

    def add_action_to_combo_box(self, settings, count):
        action_list = []
        if self.info_input.text() != '':
            timer_str = f't{count}_{self.time_input.text()}_{self.action_cb_list.currentText()}_{"" if self.inptust.value() == 0 else self.inptust.value()}_{"" if self.inptdop.value() == 0 else self.inptdop.value()}_{self.name_sen.text()}!{self.info_input.text()}'
        else:
            timer_str = f't{count}_{self.time_input.text()}_{self.action_cb_list.currentText()}_{"" if self.inptust.value() == 0 else self.inptust.value()}_{"" if self.inptdop.value() == 0 else self.inptdop.value()}_{self.name_sen.text()}'
        self.action_timers.insertItem(self.action_timers.currentIndex() + 1, timer_str)
        for index in range(self.action_timers.count()):
            action_list.append(self.action_timers.itemText(index))
        settings.setValue(self.timers.currentText(), action_list)

    def del_action(self, settings):
        action_list = []
        current_index = self.action_timers.currentIndex()
        self.action_timers.removeItem(current_index)
        for index in range(self.action_timers.count()):
            action_list.append(self.action_timers.itemText(index))
        settings.setValue(self.timers.currentText(), action_list)

    def hide_timer_settings(self):
        self.add_timer.hide()
        self.info_input.hide()
        self.exp_timer.hide()
        self.question_button.hide()
        self.lablobj.hide()
        self.delete_timer.hide()
        for i in range(self.htimebox.count()):
            widget = self.htimebox.itemAt(i).widget()
            if widget:
                widget.hide()
        self.action_cb_list.hide()
        #  self.action_timers.hide()
        self.timers_cb_b.hide()
        self.timers_cb_del.hide()
        self.inptust.hide()
        self.inptdop.hide()
        self.name_sen.hide()
        self.input_number_cycles.hide()
        self.continuous_checkbox.hide()
        self.timers.hide()
        self.reset_button.hide()

    def resize_setting_widget(self, width, height):

        setting_widget = self.parent().parent().parent().parent()
        if isinstance(setting_widget, Setting):
            setting_widget.resize(width, height)
            setting_widget.btnreboot.hide()

    def start_timer(self, settings):
        with threading.Lock():
            self.initialize_timer_info()
            cycle = self.get_cycle(settings)
            self.lb_cycle.setText(f'  {cycle}')

            current_time = QDateTime.currentDateTime()
            self.start_time.setText(current_time.toString("hh:mm:ss.z"))

            try:
                tname, ttime, tbutton, tust, tdop, tname_sen = self.action_timers.currentText().split('_')
            except ValueError:
                self.handle_timer_value_error()
                return

            total_seconds = self.calculate_total_seconds(ttime)

            self.end_time.setText(current_time.addMSecs(total_seconds).toString("hh:mm:ss.z"))

            self.setup_timer(tbutton, settings, tust, tdop, tname_sen, total_seconds)

    def initialize_timer_info(self):
        if not hasattr(self, 'first_loop'):
            self.start.setText(QDateTime.currentDateTime().toString("hh:mm:ss"))
            self.first_loop = True
            self.hide_timer_settings()

    def get_cycle(self, settings):
        return settings.value(f'cycle_{self.timers.currentText()}', '0_1')

    def handle_timer_value_error(self):
        self.timer_stop.click()
        self.timers.setCurrentIndex(0)
        self.action_timers.setCurrentIndex(0)

    def calculate_total_seconds(self, ttime):
        hours, minutes, seconds_with_fraction = map(float, ttime.split(':'))
        return int((hours * 3600 + minutes * 60 + seconds_with_fraction) * 1000)

    def setup_timer(self, tbutton, settings, tust, tdop, tname_sen, total_seconds):
        self.timer = QTimer()
        self.timer_stop.clicked.connect(lambda: self.timer_action_stop(settings))
        self.timer.setInterval(total_seconds)
        self.timer.timeout.connect(
            lambda: self.timer_action(tbutton, self.iteration_count, settings, tust, tdop, tname_sen))
        self.timer.start()

    def timer_action_stop(self, settings):
        self.end.setText(QDateTime.currentDateTime().toString("hh:mm:ss"))
        self.last = False
        self.last_cycle.setChecked(False)
        if self.continuous_checkbox.isChecked():
            self.first_loop = True
        self.continuous_checkbox.setChecked(False)
        #       self.resize_setting_widget(600,400)
        if hasattr(self, 'first_run'):
            del self.first_run
        self.timer.stop()
        self.start_time.setText('')
        self.end_time.setText('')
        self.info.setText('')
        try:
            if isinstance(self.parent().parent().parent().parent(), Setting):
                self.add_timer.show()
                self.exp_timer.show()
                self.delete_timer.show()
                for i in range(self.htimebox.count()):
                    widget = self.htimebox.itemAt(i).widget()
                    if widget:
                        widget.hide()
                self.action_cb_list.show()
                self.timers_cb_b.show()
                self.timers_cb_del.show()
                self.inptust.show()
                self.inptdop.show()
                self.name_sen.show()
                self.input_number_cycles.show()
                self.continuous_checkbox.show()
                self.timers.show()
                self.reset_button.show()
        except Exception:
            pass
        self.timers.setCurrentIndex(0)

    #   settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')

    def timer_action(self, button, iteration_count, settings, ust, dop, name_sens):
        with threading.Lock():
            if name_sens != '':
                try:
                    self.info.setText(name_sens.split('!')[1])
                except IndexError:
                    self.info.setText(name_sens)
            self.timer.stop()
            cycle_str = self.lb_cycle.text()
            cycle_parts = cycle_str.split('_')
            if int(cycle_parts[0]) != int(cycle_parts[1]):
                if self.first_loop or '*' not in name_sens:
                    tr_dict = {tr.name: tr for tr in self.trlist}
                    dmp_dict = {dm.name: dm for dm in self.dmplist}
                    furn_dict = {fr.name: fr for fr in self.furanceslist}
                    sens_dict = {sn.name: sn for sn in self.sensorlist}
                    math_dict = dict(zip(self.name_formuls, self.formuls))
                    objects = [tr_dict.get(button), dmp_dict.get(button), furn_dict.get(button), sens_dict.get(button),
                               math_dict.get(button)]
                    result = next((obj for obj in objects if obj is not None), None)
                    ust = float(ust) if ust != '' else None
                    dop = float(dop) if dop != '' else None
                    if result is not None:
                        case = {
                            Formula: lambda: self.process_math_case(result, ust, dop, name_sens),
                            Sensor: lambda: self.process_sens_case(result, ust, dop, name_sens),
                            Damper: lambda: self.process_dmpb_case(result, name_sens, ust, dop),
                            Translate: lambda: self.process_trb_case(result, name_sens),
                            Furnace: lambda: self.process_furn_case(result, name_sens, ust),
                        }
                        if type(result) in case:
                            case[type(result)]()
                self.action_timers.setCurrentIndex((self.action_timers.currentIndex() + 1) % self.action_timers.count())
                print(self.action_timers.currentText())
                if self.cond:
                    self.iteration_count -= 1
                elif iteration_count < len(self.action_timers) - 1:
                    self.iteration_count += 1
                else:
                    cycle_parts[0] = str(int(cycle_parts[0]) + 1)
                    result_str = '_'.join(cycle_parts)
                    self.lb_cycle.setText(result_str)
                    settings.setValue(f'cycle_{self.timers.currentText()}', result_str)
                    self.iteration_count = 0
                    self.first_loop = True if self.continuous_checkbox.isChecked() else False
                    self.continuous_checkbox.setChecked(False)
                    if self.last:
                        self.timers.setCurrentIndex(self.timers.count() - 1)
                        self.lb_cycle.setText('0_1')
            else:
                if self.timers.currentIndex() == 0:
                    settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')
                if self.timers.currentIndex() == self.timers.count() - 1:
                    settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')

                self.timers.setCurrentIndex((self.timers.currentIndex() + 1))
                self.first_loop = True
            self.cond = False
            self.start_timer(settings)

    def process_math_case(self, math, ust, dop, name_sens):
        index = self.formuls.index(math)
        math_data = Timers.formuls[index]
        if math_data < ust - dop or ust + dop < math_data:
            self.action_timers.setCurrentIndex(self.action_timers.currentIndex() - 2)
            self.cond = True

    def process_sens_case(self, sens, ust, dop, name_sens):
        sens_data = Set_point.sensor_data.get((sens.reg, sens.ch), float('nan'))
        if sens_data < ust - dop or ust + dop < sens_data:
            self.action_timers.setCurrentIndex(self.action_timers.currentIndex() - 2)
            self.cond = True

    def process_dmpb_case(self, dmpb, name_sens, ust, dop):
        print(dmpb)
        name_sens = name_sens.rstrip('*')
        if 'откр' in name_sens.lower():
            dmpb.pressing('Open', ust)
        elif 'закр' in name_sens.lower():
            dmpb.pressing('Close', ust)
        elif 'выкл' in name_sens.lower():
            try:
                dmpb.chkbA.setChecked(False)
            except Exception:
                pass
        elif 'вкл' in name_sens.lower():
            try:
                dmpb.chkbA.setChecked(True)
            except Exception:
                pass
        else:
            ust = 0 if ust is None else ust
            dop = 0 if dop is None else dop
            if not dmpb.chkb.isChecked():
                dmpb.chkb.setChecked(True)
            dmpb.valve_widget.comboA.setCurrentIndex(
                dmpb.valve_widget.comboA.findText(name_sens, flags=Qt.MatchContains))
            dmpb.valve_widget.ustA.setValue(ust)
            dmpb.valve_widget.dopskA.setValue(dop)
            dmpb.valve_widget.chkbA.setChecked(not dmpb.valve_widget.chkbA.isChecked())

    def process_trb_case(self, trb, name_sens):
        name_sens = name_sens.rstrip('*')

        if 'сброс' in name_sens:
            trb.rearrangement_cond = False
        else:
            trb.click()

    def process_furn_case(self, furn, name_sens, ust):
        name_sens = name_sens.rstrip('*')

        if 'вкл' in name_sens.lower():
            furn.button.setChecked(True)
        elif 'выкл' in name_sens.lower():
            furn.button.setChecked(False)
        else:
            furn.setpoint_value.setValue(ust)
            furn.on_activated('DT')
            furn.on_activated('DA')
            dt, da = name_sens.split('-')
            furn.sensordt.setCurrentIndex(furn.sensordt.findText(dt, flags=Qt.MatchContains))
            furn.sensordp.setCurrentIndex(furn.sensordp.findText(da, flags=Qt.MatchContains))
            furn.button.toggle()


class File_formatter:
    @classmethod
    def rw_lines(cls, suf: str, new_lines: list[str] = None):
        with open(config['setting'], suf) as file:
            match suf:
                case 'r':
                    return file.readlines()
                case 'w':
                    return file.writelines(new_lines)

    def extract_text_between_grids(self, start_grids_index, end_grids_index, sort_key_index):
        lines = self.rw_lines('r')

        grid_count = 0
        start_index = -1
        end_index = -1

        # Find start and end indices of the relevant section
        for i, line in enumerate(lines):
            if line.strip() == config['GRID']:
                grid_count += 1
                if grid_count == start_grids_index:
                    start_index = i + 1
                elif grid_count == end_grids_index:
                    end_index = i
                    break

        if start_index == -1 or end_index == -1:
            return  # Grids not found

        # Extract and sort the text between grids
        between_grids = [line for line in lines[start_index:end_index] if
                         line.strip() and line.strip() != config['GRID']]

        between_grids.sort(key=lambda x: int(x.split()[sort_key_index]))
        result = {}
        for line in between_grids:
            parts = line.strip().split()
            try:
                fifth_column = int(parts[sort_key_index])
                if fifth_column not in result:
                    result[fifth_column] = []
                result[fifth_column].append(line)
            except ValueError:
                print(f"Ошибка преобразования в число в строке: {line}")

        # Сортировка строк внутри каждой группы по первому столбцу
        if start_grids_index == 2:
            between_grids = []
            for key, value in result.items():
                between_grids += sorted(value, key=lambda x: int(x.split()[1]))

        # Reconstruct the file
        new_lines = lines[:start_index - 1] + between_grids + lines[end_index:]
        new_lines.insert(start_index - 1, config['GRID'] + '\n')  # Re-insert the GRID line.
        self.rw_lines('w', new_lines)


class Setting(QWidget, File_formatter):
    CONFIRM = 'Подтвердить'
    _instance = None
    _initialized = False

    def __new__(cls, *args, **kwargs):

        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        self.cb_daq_mod_type = None
        if not self._initialized:
            super().__init__()
            self._initialized = True
            self.sensor_list = dlgMain.sensor_list
            self.dampers_list = dlgMain.dampers_list

            self.setMinimumSize(100, 100)
            self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

            self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
            self.setFont(QFont("Arial", 14))
            self.setWindowTitle('Настройки')
            self.setStyleSheet('''QPushButton {font-size: 14pt;background-color: #A3C1DA; border-radius: 8px;}
                              QPushButton:hover {background-color: #49B69F;}
                              QPushButton:pressed {background-color: #5549B6;}''')
            screen = QDesktopWidget().screenGeometry()
            width = screen.width()
            height = screen.height()
            self.checked_items = []

            self.central_widget = SquareWidget(dlgMain, check=True)
            self.central_widget.setGeometry(555, 555, 250, 50)
            self.central_widget.show()

            def handle_value_change(x, y):
                self.central_widget.move(int(x), int(y))

            window0 = QWidget()
            layout0 = QHBoxLayout(window0)
            timer1 = Timers()
            layout0.addWidget(timer1)

            self.btn_timer_open = QPushButton("Открыть алгоритмы")
            self.btn_timer_open.clicked.connect(self.open_timer_logic)
            layout0.addWidget(self.btn_timer_open)

            window = QWidget()
            layout1 = QGridLayout(window)

            self.cb_name = QComboBox(self)
            self.cb_name.setToolTip("Имя")
            self.cb_name.addItems(['DA', 'DD', 'dP', 'DT', 'G', 'своё имя'])
            self.cb_name.currentIndexChanged.connect(self.setname)
            self.cb_namenumber = QComboBox(self)
            self.cb_channel = QComboBox(self)
            self.cb_bit_depth = QComboBox(self)
            for i in range(1, 101):
                self.cb_namenumber.addItem(str(i))
                self.cb_channel.addItem(str(i))
                self.cb_bit_depth.addItem(str(i))
            self.cb_color = QComboBox(self)

            self.cb_color.addItems(config['COLORS'].keys())
            self.cb_color.addItem('Свой цвет')
            self.color_label = QLabel(self)
            self.color_label.setText('Цвет')
            self.color_label.setGeometry(50, 100, 200, 50)
            self.color_label.setAutoFillBackground(True)
            self.color_label.setStyleSheet(f"background-color: #FF5733")
            self.cb_color.currentIndexChanged.connect(
                lambda: self.on_combo_box_change(config['COLORS'], self.cb_color, self.color_label))

            self.cb_name_side = QComboBox(self)
            self.cb_name_side.addItems(config['SIDE'].keys())
            self.cb_bit_depth.setCurrentIndex(2)

            self.cb_reg = QComboBox(self)
            for i in config['IPS']:
                self.cb_reg.addItem(i)

            self.cb_pos_x = QDoubleSpinBox(self)
            self.cb_pos_y = QDoubleSpinBox(self)
            self.cb_pos_x.setFont(QFont('Arial', 12))
            self.cb_pos_y.setFont(QFont('Arial', 12))

            self.cb_pos_x.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y.lineEdit().setAlignment(Qt.AlignCenter)
            self.deepxy(width, height, self.cb_pos_x, self.cb_pos_y)
            self.cb_pos_x.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x.value(), self.cb_pos_y.value()))
            self.cb_pos_y.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x.value(), self.cb_pos_y.value()))
            self.central_widget.posChanged.connect(self.handlePosChanged)

            layout1.addWidget(QLabel('Имя'), 0, 0)
            layouth1_1 = QHBoxLayout()
            layouth1_1.addWidget(self.cb_name)
            layouth1_1.addWidget(self.cb_namenumber)
            layout1.addLayout(layouth1_1, 0, 1)

            layout1.addWidget(QLabel('Канал'), 1, 0)
            layout1.addWidget(self.cb_channel, 1, 1)
            layout1.addWidget(self.color_label)
            layout1.addWidget(self.cb_color)
            layout1.addWidget(QLabel('Расположение имени'))
            layout1.addWidget(self.cb_name_side)
            layout1.addWidget(QLabel('Разрядность'))
            layout1.addWidget(self.cb_bit_depth)
            layout1.addWidget(QLabel('Регистратор'), 5, 0)
            layout1.addWidget(self.cb_reg, 5, 1)
            layout1.addWidget(QLabel('Позиция по X и Y'))
            layouth1_2 = QHBoxLayout()
            layouth1_2.addWidget(self.cb_pos_x)
            layouth1_2.addWidget(self.cb_pos_y)
            layout1.addLayout(layouth1_2, 6, 1)

            confirm1 = QPushButton("Подтвердить")
            layout1.addWidget(confirm1, 7, 0, 2, 0)
            confirm1.clicked.connect(lambda: self.create_item('sensor'))

            window2 = QWidget()
            layout2 = QVBoxLayout()
            window2.setLayout(layout2)

            delete = QPushButton('Удалить')
            delete.clicked.connect(self.deletesensor)
            hide = QPushButton('Скрыть/Отбразить')
            hide.clicked.connect(self.hidewidget)
            layout2_1 = QHBoxLayout()

            layout2_1.addWidget(hide)
            layout2_1.addWidget(delete)
            layout2.addLayout(layout2_1)

            widget_2 = QWidget()
            layout = QVBoxLayout()
            self.scroll_area = QScrollArea()
            self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
            self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.scroll_area.setWidgetResizable(True)
            self.scroll_content = QWidget(self.scroll_area)
            self.scrollLayout = QVBoxLayout(self.scroll_content)

            self.scrollLayout.setContentsMargins(0, 0, 0, 0)
            self.scrollLayout.setSpacing(0)
            self.content_add()
            layout.addWidget(self.scroll_area)
            widget_2.setLayout(layout)
            widget_2.setFont(QFont('Arial', 12))
            layout2.addWidget(widget_2)

            window3 = QWidget()
            layout3 = QVBoxLayout()
            window3.setLayout(layout3)
            self.input3 = QLineEdit()
            self.input3.setText('69.5*sqrt(342.15*DA1*dP1*10000)/(273+DT1)')
            self.input3.setPlaceholderText('Формула')
            self.input3_1 = QLineEdit()
            self.input3_1.setPlaceholderText('имя')
            self.cb_bit_depth_math = QComboBox()
            for i in range(0, 10):
                self.cb_bit_depth_math.addItem(str(i))
            self.cb_bit_depth_math.setCurrentIndex(2)
            self.cb_color_math = QComboBox()
            self.cb_color_math.addItems(config['COLORS'].keys())
            self.cb_color_math.addItem("Cвой цвет")

            self.color_label_math = QLabel(self)
            self.color_label_math.setText('Цвет')
            self.color_label_math.setGeometry(50, 100, 200, 50)
            self.color_label_math.setAutoFillBackground(True)
            self.color_label_math.setStyleSheet(f"background-color: #FF5733")
            self.cb_color_math.currentIndexChanged.connect(
                lambda: self.on_combo_box_change(config['COLORS'], self.cb_color_math, self.color_label_math))

            self.cb_name_side_math = QComboBox()
            self.cb_name_side_math.addItems(config['SIDE'].keys())
            self.cb_pos_x_math = QDoubleSpinBox()
            self.cb_pos_y_math = QDoubleSpinBox()
            self.cb_pos_x_math.setMaximum(1920)
            self.cb_pos_y_math.setMaximum(1080)
            self.cb_pos_x_math.setFont(QFont("Arial", 12))
            self.cb_pos_y_math.setFont(QFont("Arial", 12))
            self.cb_pos_x_math.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_math.value(), self.cb_pos_y_math.value()))
            self.cb_pos_y_math.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_math.value(), self.cb_pos_y_math.value()))
            self.cb_pos_x_math.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_math.lineEdit().setAlignment(Qt.AlignCenter)

            self.deepxy(width, height, self.cb_pos_x_math, self.cb_pos_y_math)

            layout3_h1 = QHBoxLayout()
            layout3_h1.addWidget(QLabel('Разрядность'))
            layout3_h1.addWidget(self.cb_bit_depth_math)
            layout3_h2 = QHBoxLayout()
            layout3_h2.addWidget(QLabel('Расположение имени'))
            layout3_h2.addWidget(self.cb_name_side_math)
            layout3_h3 = QHBoxLayout()
            layout3_h3.addWidget(self.color_label_math)
            layout3_h3.addWidget(self.cb_color_math)

            layout3_h4 = QHBoxLayout()
            layout3_h4.addWidget(QLabel('Расположение по X и Y'))
            layout3_h4.addWidget(self.cb_pos_x_math)
            layout3_h4.addWidget(self.cb_pos_y_math)

            layout3.addWidget(self.input3)
            layout3.addWidget(self.input3_1)
            layout3.addLayout(layout3_h1)
            layout3.addLayout(layout3_h2)
            layout3.addLayout(layout3_h3)
            layout3.addLayout(layout3_h4)

            confirm3 = QPushButton("Подтвердить")
            layout3.addWidget(confirm3)
            confirm3.clicked.connect(self.addformula)

            #  window4_0 = QWidget(self)
            #  layout4_0 = QVBoxLayout()
            #  window4_0.setLayout(layout4_0)
            #  self.cb_daq = QComboBox()
            #  system = nidaqmx.system.System.local()
            #  devices = system.devices
            #  self.cb_daq.addItems([f'{daq}/{devices[daq].tcpip_ethernet_ip}' for daq in devices.device_names if 'Mod' not in daq])
            #  for index in range(self.cb_daq.count()):
            #      cb_daq = self.cb_daq.itemText(index).split('/')[1]
            #      if cb_daq in config['IPS']:
            #          self.cb_daq.setCurrentIndex(index)
            #          break
            #
            #  self.cb_daq_mod_type = QComboBox()
            #  self.cd_daq_cur(devices)
            #  self.cb_daq.currentIndexChanged.connect(lambda: self.cd_daq_cur(devices))
            #  self.scroll = QScrollArea()  # Создание объекта QScrollArea
            #  self.scroll.setWidgetResizable(True)  # Установка возможности изменения размера виджета внутри QScrollArea
            #  self.update_scroll_content()  # Вызов функции для первоначального заполнения содержимого
            #  self.cb_daq_mod_type.currentIndexChanged.connect(self.update_scroll_content)  # Подключение сигнала к слоту
            #  device_modules = devices[self.cb_daq_mod_type.currentText().split('/')[0]]
            ##   self.cb_daq_mod_type.clear()
            #
            #  self.input4_0_ch = QSpinBox()
            #  self.input4_0_ch.setMinimum(1)
            #  self.input4_0_ch.setMaximum(
            #      len([channel.name for channel in device_modules.ai_physical_chans]) if hasattr(device_modules,
            #                                                                                     'ai_physical_chans') else 32)
            #  self.cb_daq_mod_range_min = QDoubleSpinBox()
            #  self.cb_daq_mod_range_min.setMaximum(999)
            #  self.cb_daq_mod_range_min.setMinimum(-999)
            #  self.cb_daq_mod_range_min.setDecimals(4)
            #  self.cb_daq_mod_range_max = QDoubleSpinBox()
            #  self.cb_daq_mod_range_max.setMaximum(999)
            #  self.cb_daq_mod_range_max.setMinimum(-999)
            #  self.cb_daq_mod_range_min.setDecimals(4)
            #
            #  layout4_0_h = QHBoxLayout()
            #  layout4_0_h.addWidget(QLabel('ch'))
            #  layout4_0_h.addWidget(self.input4_0_ch)
            #  layout4_0_h.addWidget(QLabel('min'))
            #  layout4_0_h.addWidget(self.cb_daq_mod_range_min)
            #  layout4_0_h.addWidget(QLabel('max'))
            #  layout4_0_h.addWidget(self.cb_daq_mod_range_max)
            #
            #  layout4_0.addWidget(self.cb_daq)
            #  layout4_0.addWidget(self.cb_daq_mod_type)
            #  layout4_0.addLayout(layout4_0_h)
            #  self.btn4_0 = QPushButton('add')
            #  self.btn4_0.clicked.connect(self.get_ch_range)
            #  layout4_0.addWidget(QLabel('ch: min, max'))
            #  layout4_0.addWidget(self.scroll)
            #  layout4_0.addWidget(self.btn4_0)

            window4 = QWidget()
            layout4 = QVBoxLayout()
            window4.setLayout(layout4)
            self.input4 = QLineEdit()
            self.input4.setPlaceholderText('192.168.201.1')
            validator = QRegExpValidator(QRegExp("[0-9\\.]*"))
            self.input4.setValidator(validator)
            self.cb_add_type = QComboBox()
            self.cb_add_type.addItems(['modbus', 'opc', 'elemer', 'daq'])

            self.cb_ip = QComboBox()
            self.cb_ip.addItems(config['IPS'])

            btn4sed = QPushButton('Отправить ip')
            btn4sed.clicked.connect(self.send_ip)
            btn4del = QPushButton('удалить ip')
            btn4del.clicked.connect(lambda: self.delip(self.cb_ip.currentText()))

            layout4_h = QHBoxLayout()
            layout4_h.addWidget(QLabel('ip адрес'))
            layout4_h.addWidget(self.input4)
            layout4_h.addWidget(QLabel('тип'))
            layout4_h.addWidget(self.cb_add_type)
            layout4.addLayout(layout4_h)

            layout4.addWidget(btn4sed)
            layout4.addWidget(self.cb_ip)
            layout4.addWidget(btn4del)

            window5 = QWidget()
            layout5 = QGridLayout()
            window5.setLayout(layout5)
            self.cb_name_ru = QComboBox()
            self.cb_name_ru.addItems(['RU', 'ZU'])
            self.cb_orientate = QComboBox()
            self.cb_orientate.addItems(config['ORIENTATION'].keys())
            self.cb_name_runumber = QComboBox()
            self.cb_chr_open = QComboBox()
            self.cb_chr_close = QComboBox()
            self.cb_chdv_open = QComboBox()
            self.cb_chdv_close = QComboBox()
            self.cb_reg_ru = QComboBox()

            self.cb_pos_x_ru = QDoubleSpinBox()
            self.cb_pos_y_ru = QDoubleSpinBox()
            self.cb_pos_x_ru.setFont(QFont('Arial', 12))
            self.cb_pos_y_ru.setFont(QFont('Arial', 12))
            self.cb_pos_x_ru.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_ru.value(), self.cb_pos_y_ru.value()))
            self.cb_pos_y_ru.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_ru.value(), self.cb_pos_y_ru.value()))
            self.cb_pos_x_ru.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_ru.lineEdit().setAlignment(Qt.AlignCenter)

            for i in range(1, 101):
                self.cb_name_runumber.addItem(str(i))
                self.cb_chr_open.addItem(str(i))
                self.cb_chr_close.addItem(str(i))
                self.cb_chdv_open.addItem(str(i))
                self.cb_chdv_close.addItem(str(i))

            self.deepxy(width, height, self.cb_pos_x_ru, self.cb_pos_y_ru)

            self.cb_reg_ru.addItems({k: i + 1 for i, k in enumerate(config['IPS'])})

            self.cb_chr_close.setCurrentIndex(1)
            self.cb_chdv_close.setCurrentIndex(1)

            layout5.addWidget(QLabel("Имя"), 0, 0)
            layout5_1 = QHBoxLayout()
            layout5_1.addWidget(self.cb_name_ru)
            layout5_1.addWidget(self.cb_name_runumber)
            layout5.addLayout(layout5_1, 0, 1)

            self.oritntation = QLabel("Ориетирование")
            layout5.addWidget(self.oritntation, 1, 0)
            layout5.addWidget(self.cb_orientate, 1, 1)

            self.chr_open = (QLabel("Канал откр"))
            layout5.addWidget(self.chr_open, 2, 0)
            layout5.addWidget(self.cb_chr_open)

            self.chr_close = (QLabel("Канал закр"))
            layout5.addWidget(self.chr_close, 3, 0)
            layout5.addWidget(self.cb_chr_close)

            self.chdv_open = (QLabel("Концевик откр"))
            layout5.addWidget(self.chdv_open, 4, 0)
            layout5.addWidget(self.cb_chdv_open)

            self.chdv_close = (QLabel("Концевик закр"))
            layout5.addWidget(self.chdv_close, 5, 0)
            layout5.addWidget(self.cb_chdv_close)

            layout5.addWidget(QLabel("Регистратор"), 6, 0)

            layout5.addWidget(self.cb_reg_ru)

            layout5.addWidget(QLabel("Положение по X и Y"), 7, 0)
            layout5_2 = QHBoxLayout()

            layout5_2.addWidget(self.cb_pos_x_ru)
            layout5_2.addWidget(self.cb_pos_y_ru)
            layout5.addLayout(layout5_2, 7, 1)
            self.cb_name_ru.currentIndexChanged.connect(self.Furn)

            confirm5 = QPushButton(self.CONFIRM)
            confirm5.clicked.connect(lambda: self.create_item('RU'))
            layout5.addWidget(confirm5, 9, 0, 2, 0)

            window7 = QWidget()
            layout7 = QGridLayout()
            window7.setLayout(layout7)
            self.r1 = QComboBox()
            self.r2 = QComboBox()
            self.r1_sleep = QDoubleSpinBox()
            self.r2_sleep = QDoubleSpinBox()
            self.r1_sleep.setFont(QFont('Arial', 16))
            self.r2_sleep.setFont(QFont('Arial', 16))
            self.r1_sleep.setSuffix('   задержка для первой заслонки')
            self.r2_sleep.setSuffix('   задержка для второй заслонки')

            self.time_rearrangement = QDoubleSpinBox()
            self.time_rearrangement.setFont(QFont('Arial', 16))
            self.time_rearrangement.setSuffix('   время перекладки')

            confirm7 = QPushButton(self.CONFIRM)
            self.r1.addItems([i.name for i in self.dampers_list])
            self.r2.addItems([i.name for i in self.dampers_list])
            layout7.addWidget(self.r1)
            layout7.addWidget(self.r1_sleep)
            layout7.addWidget(self.r2)
            layout7.addWidget(self.r2_sleep)
            layout7.addWidget(self.time_rearrangement)

            self.cb_pos_x_rerange = QDoubleSpinBox()
            self.cb_pos_y_rerange = QDoubleSpinBox()
            self.cb_pos_x_rerange.setMaximum(1920)
            self.cb_pos_y_rerange.setMaximum(1080)
            self.cb_pos_x_rerange.setFont(QFont('Arial', 16))
            self.cb_pos_y_rerange.setFont(QFont('Arial', 16))

            self.cb_pos_x_rerange.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_rerange.value(), self.cb_pos_y_rerange.value()))
            self.cb_pos_y_rerange.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_rerange.value(), self.cb_pos_y_rerange.value()))
            self.cb_pos_x_rerange.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_rerange.lineEdit().setAlignment(Qt.AlignCenter)

            layout7_h1 = QHBoxLayout()
            layout7_h1.addWidget(QLabel('Расположение по X и Y'))
            layout7_h1.addWidget(self.cb_pos_x_rerange)
            layout7_h1.addWidget(self.cb_pos_y_rerange)
            layout7.addLayout(layout7_h1, 5, 0)
            layout7.addWidget(confirm7)
            confirm7.clicked.connect(lambda: self.create_item('Rer'))

            window8 = QWidget()
            layout8 = QGridLayout()
            window8.setLayout(layout8)
            # Furn F1 1 1.6 1
            self.number = QSpinBox()
            self.number.setSuffix(' Номер')
            self.number.setMinimum(1)
            self.number.setFont(QFont('Arial', 16))

            self.ch_furn = QSpinBox()
            self.ch_furn.setMinimum(1)
            self.ch_furn.setSuffix('    Канал')
            self.ch_furn.setFont(QFont('Arial', 16))

            self.max = QDoubleSpinBox()
            self.max.setSuffix('    Максимальный ток')
            self.max.setFont(QFont('Arial', 16))
            self.max.setMinimum(.5)

            self.reg_furn = QSpinBox()
            self.reg_furn.setMinimum(1)
            self.reg_furn.setSuffix('   Регистратор')
            self.reg_furn.setFont(QFont('Arial', 16))
            self.cb_pos_x_furn = QDoubleSpinBox()
            self.cb_pos_y_furn = QDoubleSpinBox()
            self.cb_pos_x_furn.setMaximum(1920)
            self.cb_pos_y_furn.setMaximum(1080)
            self.cb_pos_x_furn.setFont(QFont('Arial', 16))
            self.cb_pos_y_furn.setFont(QFont('Arial', 16))

            self.cb_pos_x_furn.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_furn.value(), self.cb_pos_y_furn.value()))
            self.cb_pos_y_furn.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_furn.value(), self.cb_pos_y_furn.value()))
            self.cb_pos_x_furn.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_furn.lineEdit().setAlignment(Qt.AlignCenter)

            layout8_h1 = QHBoxLayout()
            layout8_h1.addWidget(QLabel('Расположение по X и Y'))
            layout8_h1.addWidget(self.cb_pos_x_furn)
            layout8_h1.addWidget(self.cb_pos_y_furn)

            confirm8 = QPushButton(self.CONFIRM)
            confirm8.clicked.connect(lambda: self.create_item('Furn'))
            layout8.addWidget(self.number)
            layout8.addWidget(self.ch_furn)
            layout8.addWidget(self.max)
            layout8.addWidget(self.reg_furn)
            layout8.addLayout(layout8_h1, 4, 0)
            layout8.addWidget(confirm8, 5, 0)

            window6 = QWidget()
            try:
                port_names = QComboBox()
                for port, names in config["ports"].items():
                    port_names.addItem(port)
                    port_names.addItems(names)
            except:
                pass
            button6_1 = QPushButton('Графики')
            button6_1.clicked.connect(GraphWindow.create_new_graph_window)
            button6_set = QPushButton('Уставки')
            button6_set.clicked.connect(self.show_setpoint_window)

            button6_2 = QPushButton('Экспорт Уставок (рамок)')

            def export_registry():
                subprocess.run(['reg', 'export', r'HKEY_CURRENT_USER\SOFTWARE\MyApp',
                                fr'{config["IZDELIE"]}\{config["IZDELIE"]}_ust.reg', '/y'], check=True)

            button6_2.clicked.connect(export_registry)

            layout6 = QVBoxLayout()
            layout6.addWidget(button6_1)
            layout6.addWidget(button6_set)
            layout6.addWidget(button6_2)
            window6.setLayout(layout6)

            hbox6_3 = QHBoxLayout()
            self.ustbtn = QPushButton('Изменить')
            line_edit = QSpinBox()
            line_edit.setAlignment(Qt.AlignCenter)
            line_edit.setFont(QFont('Arial', 14))
            label6_3 = QLabel("Количество уставок:")
            self.ustbtn.clicked.connect(lambda: self.on_ustbtn_click(str(line_edit.value())))
            hbox6_3.addWidget(label6_3)
            hbox6_3.addWidget(line_edit)
            hbox6_3.addWidget(self.ustbtn)
            layout6.addLayout(hbox6_3)

            # Размер сенсоров — слайдер
            self.cb_size = QSlider(Qt.Horizontal)
            self.cb_size.setMinimum(-10)
            self.cb_size.setMaximum(100)
            self.cb_size.setValue(config.get('sensor_size', 5))
            self.cb_size.setTickInterval(1)
            self.cb_size.setTickPosition(QSlider.TicksBelow)

            self.cb_size.valueChanged.connect(
                lambda val: (
                    self.update_setting_file('sensor_size', str(val)),
                    self.refresh_sensor_size(val)
                )
            )

            hbox6_2 = QHBoxLayout()
            hbox6_2.addWidget(QLabel("Размер сенсоров:"))
            hbox6_2.addWidget(self.cb_size)
            layout6.addLayout(hbox6_2)

            self.cb_damper_size = QSlider(Qt.Horizontal)
            self.cb_damper_size.setMinimum(-35)
            self.cb_damper_size.setMaximum(35)
            self.cb_damper_size.setValue(config.get('damper_size', 2))
            self.cb_damper_size.setTickInterval(1)
            self.cb_damper_size.setTickPosition(QSlider.TicksBelow)

            self.cb_damper_size.valueChanged.connect(
                lambda val: (
                    self.update_setting_file('damper_size', str(val)),
                    self.refresh_damper_size(val)
                )
            )

            self.ckhidename_b = QPushButton('Отображение имени')
            self.ckhidename_b.clicked.connect(lambda: (
                self.setting('hidename'),
                self.refresh_sensor_names_visibility()
            ))

            hbox6_2 = QHBoxLayout()
            layout6.addLayout(hbox6_2)

            hbox6_4 = QHBoxLayout()
            hbox6_4.addWidget(QLabel("Размер заслонок:"))
            hbox6_4.addWidget(self.cb_damper_size)
            layout6.addLayout(hbox6_4)

            try:
                layout6.addWidget(port_names)
            except:
                pass
            layout6.addWidget(self.ckhidename_b)

            layout = QVBoxLayout()
            layout.addWidget(QWidget())

            self.tabs = QTabWidget()
            self.tabs.setFont(QFont('Arial', 14))
            self.tabs.setStyleSheet("QTabWidget::pane { border-top: 2px solid #C2C7CB; }"
                                    "QTabBar::tab { height: 30px;  border-top-left-radius: 10px; border-top-right-radius: 10px;margin-right:15px; }"
                                    "QTabBar::tab:hover {background-color: #49B69F;}"
                                    "QTabBar::tab:selected { background-color: #A3C1DA;color:white ; border-top-left-radius: 10px; border-top-right-radius: 10px;}"
                                    "QLabel {font-size: 14pt;}"
                                    "QComboBox {font-size: 14pt;}"
                                    "QLineEdit {font-size: 14pt;}"
                                    """QPushButton {font-size: 14pt;background-color: #A3C1DA; border-radius: 8px;}
                                       QPushButton:hover {background-color: #49B69F;}
                                       QPushButton:pressed {background-color: #5549B6;}

                                       """)
            self.tabs.addTab(window0, "Таймер")
            self.tabs.addTab(window, "Добавление датчика")
            self.tabs.addTab(window2, "Скрыть/Удаление")
            self.tabs.addTab(window3, "Математика")
            # self.tabs.addTab(window4_0, "DAQ_modules")
            self.tabs.addTab(window4, "Добавление/удаление IP")
            self.tabs.addTab(window5, "Добавление заслоки")
            self.tabs.addTab(window8, "Добавление печи")
            self.tabs.addTab(window7, "Добавление перекладки")
            self.tabs.addTab(window6, "Настройка")
            self.tabs.currentChanged.connect(self.on_tab_changed)
            layout = QVBoxLayout()
            layout.addWidget(self.tabs)
            self.btnreboot = QPushButton('Перезагрузка')
            self.btnreboot.clicked.connect(self.reboots)
            layout.addWidget(self.btnreboot)
            custom_font = QFont()
            custom_font.setWeight(18)

            self.setLayout(layout)

    def refresh_sensor_names_visibility(self):
        """
        Обновляет отображение имён у всех сенсоров на основе config['hidename'].
        """
        hide = int(config.get('hidename', 0)) == 1

        if hasattr(dlgMain, 'sensor_list'):
            for sensor in dlgMain.sensor_list:
                sensor.hidename(hide)

        if hasattr(dlgMain, 'formuls'):
            for formula in dlgMain.formuls:
                formula.hidename(hide)

        if hasattr(dlgMain, 'const'):
            for const in dlgMain.const:
                const.hidename(hide)

    def refresh_damper_size(self, new_value: int):
        """Обновляет масштаб всех заслонок"""
        for damper in dlgMain.dampers_list:
            damper.scaletext(new_value)

    def update_setting_file(self, key: str, value: str):
        path = config['setting']
        with open(path, 'r') as f:
            lines = f.readlines()

        found = False
        with open(path, 'w') as f:
            for line in lines:
                if line.strip().startswith(f"{key}"):
                    f.write(f"{key} = {value}\n")
                    found = True
                else:
                    f.write(line)
            if not found:
                f.write(f"{key} = {value}\n")

    def refresh_sensor_size(self, new_value: int):
        """
        Обновляет масштаб всех сенсоров, формул и констант.
        """
        config['sensor_size'] = new_value

        if hasattr(dlgMain, 'sensor_list'):
            for sensor in dlgMain.sensor_list:
                if hasattr(sensor, 'scaletext'):
                    sensor.scaletext(new_value)

        if hasattr(dlgMain, 'formuls'):
            for formula in dlgMain.formuls:
                if hasattr(formula, 'scaletext'):
                    formula.scaletext(new_value)

        if hasattr(dlgMain, 'const'):
            for const in dlgMain.const:
                if hasattr(const, 'scaletext'):
                    const.scaletext(new_value)

    def show_setpoint_window(self):
        if not hasattr(dlgMain, 'set_window') or dlgMain.set_window is None or not dlgMain.set_window.isVisible():
            dlgMain.set_window = SetPointWindow(dlgMain)
            dlgMain.set_window.setWindowModality(Qt.NonModal)
            dlgMain.set_window.setAttribute(Qt.WA_DeleteOnClose, False)

        dlgMain.set_window.show()
        dlgMain.set_window.raise_()
        dlgMain.set_window.activateWindow()

    def on_ustbtn_click(self, new_value):
        try:
            with open(config['setting'], 'r') as file:
                lines = file.readlines()
            with open(config['setting'], 'w') as file:
                for line in lines:
                    if line.startswith("pack"):
                        file.write('pack =' + new_value + '\n')
                    else:
                        file.write(line)
        except Exception as e:
            print("Error while updating setting:", e)

    def open_timer_logic(self):
        if not hasattr(dlgMain, 'algoritms') or dlgMain.algoritms is None or not dlgMain.algoritms.isVisible():
            dlgMain.algoritms = Timers()
            dlgMain.algoritms.setGeometry(400, 800, 400, 200)
            dlgMain.algoritms.hide_timer_settings()
            dlgMain.algoritms.show()
        else:
            dlgMain.algoritms.raise_()
            dlgMain.algoritms.activateWindow()

    def closeEvent(self, event):
        self.central_widget.hide()
        event.accept()

    def handlePosChanged(self, pos_tuple):
        x, y = pos_tuple
        self.cb_pos_x.setValue(x)
        self.cb_pos_x_ru.setValue(x)
        self.cb_pos_x_math.setValue(x)
        self.cb_pos_x_furn.setValue(x)
        self.cb_pos_x_rerange.setValue(x)
        self.cb_pos_y.setValue(y)
        self.cb_pos_y_ru.setValue(y)
        self.cb_pos_y_math.setValue(y)
        self.cb_pos_y_furn.setValue(y)
        self.cb_pos_y_rerange.setValue(y)

    def content_add(self):
        while self.scrollLayout.count():
            item = self.scrollLayout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        self.f = self.get_name()
        for line in self.f:
            if line.count('#') >= 2 or line == '\n':
                continue
            checkbox = QCheckBox(line)
            if '#' in line:
                checkbox.setStyleSheet('background-color:  #CCCCCC')
            else:
                checkbox.setStyleSheet('background-color: white')
            self.scrollLayout.addWidget(checkbox)
        self.scroll_area.setWidget(self.scroll_content)

    def update_scroll_content(self):

        scroll_content_channls = QWidget()
        scroll_layout = QVBoxLayout(scroll_content_channls)  # Создание нового вертикального макета
        selected_daq = self.cb_daq_mod_type.currentText().split('/')[0].replace('-',
                                                                                '_')  # Получение выбранного значения из combobox
        if selected_daq in globals():
            daq_dict = globals()[selected_daq]
            for key, value in daq_dict.items():
                label = QLabel(f"{str(key)} : {str(value)}", self)
                scroll_layout.addWidget(label)

        self.scroll.setWidget(scroll_content_channls)

    def get_ch_range(self):
        try:
            infile_name = self.cb_daq_mod_type.currentText().split('/')[0].replace('-', '_')
            ch_num = int(self.input4_0_ch.value())
            min_ch = self.cb_daq_mod_range_min.value()
            max_ch = self.cb_daq_mod_range_max.value()
        except ValueError as e:
            warning_window('Добавлены неправильные аргументы \nпроверьте ch min max', False)
            return
        globals()[infile_name].update({ch_num: (min_ch, max_ch)})
        dict_range = globals()[infile_name]
        self.redact(infile_name, dict_range)
        self.update_scroll_content()

    def redact(self, infile_name, dict_range):
        with open(config['setting'], 'r') as file:
            lines = file.readlines()

        flag = False
        with open(config['setting'], 'w') as f:
            for line in lines:
                if infile_name in line:
                    f.write(f'{infile_name} = {dict_range}\n')
                    flag = True
                else:
                    f.write(line)
            if not flag:
                lines.insert(7, infile_name)

    def cd_daq_cur(self, devices):
        selected_device = self.cb_daq.currentText().split('/')[0]
        device_modules = devices[selected_device]
        self.cb_daq_mod_type.clear()
        name_models = {module.name: module.product_type for module in device_modules.chassis_module_devices}
        self.cb_daq_mod_type.addItems(self.detect_module_type(name_models))
        for index in range(self.cb_daq_mod_type.count()):
            cb_daq = self.cb_daq_mod_type.itemText(index)
            if 'ai' in cb_daq:
                self.cb_daq_mod_type.setCurrentIndex(index)
                break

    def detect_module_type(self, name_models):
        names = []

        MODULELIST = {'9208': 'ai', '9403': 'do', '9425': 'di', '9265': 'ao', '9213': 'tc',
                      '9214': 'tc', '9217': 'rtd', '9222': 'vi'}
        for name, module in name_models.items():
            for mod, value in MODULELIST.items():
                if mod in module:
                    names.append(name + '/' + module + '/' + value)
        return names

    def on_tab_changed(self, current_tab_index):
        tab_widget_name = self.tabs.tabText(current_tab_index)
        self.btnreboot.show() if tab_widget_name != "Таймер" else self.btnreboot.hide()

    def on_combo_box_change(self, colors, cbox, cblabel):
        if cbox.currentText() in colors:
            cblabel.setStyleSheet(f"background-color: #{colors[cbox.currentText()]}")

        elif cbox.currentText() == 'Свой цвет':
            color = QColorDialog.getColor()
            if color.isValid():
                cblabel.setStyleSheet(f"background-color: {color.name()}")
                cbox.addItem(color.name())
                cbox.setCurrentIndex(cbox.count() - 1)

    def set_sensor_size(self, f):
        value = self.cb_size.currentText()
        f.write(f"sensor_size = {value}\n")

    def toggle_hidename(self, line, f):
        value = '1' if '0' in line else '0'
        f.write(f"hidename = {value}\n")

    def setting(self, too):
        with open(config['setting'], 'r') as file:
            lines = file.readlines()

        with open(config['setting'], 'w') as f:
            for line in lines:
                if too == 'sensor_size' and 'sensor_size' in line:
                    self.set_sensor_size(f)
                elif too == 'hidename' and 'hidename' in line:
                    self.toggle_hidename(line, f)
                else:
                    f.write(line)

    def setname(self):
        if 'своё имя' in self.cb_name.currentText():
            text, okpressed = QInputDialog.getText(self, "Имя", "Имя датчика", QLineEdit.Normal, "")
            if okpressed and text != '':
                self.cb_name.addItem(text)
                self.cb_name.setCurrentIndex(self.cb_name.count() - 1)

    def Furn(self):
        if 'Furn' in self.cb_name_ru.currentText():
            self.cb_orientate.hide()
            self.cb_chr_open.hide()
            self.cb_chr_close.hide()
            self.cb_chdv_open.hide()

            self.oritntation.hide()
            self.chr_close.hide()
            self.chr_open.hide()
            self.chdv_open.hide()

            self.cb_chdv_close.clear()
            self.cb_chdv_close.addItems([str(i) for i in range(1, 100, 2)])
            self.chdv_close.setText('Канал печи')
        else:
            self.cb_orientate.show()
            self.cb_chr_open.show()
            self.cb_chr_close.show()
            self.cb_chdv_open.show()

            self.oritntation.show()
            self.chr_close.show()
            self.chr_open.show()
            self.chdv_open.show()

            self.cb_chdv_close.clear()
            self.cb_chdv_close.addItems([str(i) for i in range(1, 100)])
            self.cb_chdv_close.setCurrentIndex(1)

            self.chdv_close.setText("Концевик закр")

    def deepxy(self, width, height, xpos, ypos):
        xpos.setRange(-width, width)
        xpos.setValue(int(width / 2))
        ypos.setRange(-height, height)
        ypos.setValue(int(height / 2))

    def hidewidget(self):
        with open(config['setting'], 'r') as file:
            data = file.readlines()
        for index_item in range(self.scrollLayout.count()):
            widget = self.scrollLayout.itemAt(index_item).widget()
            if isinstance(widget, QCheckBox) and widget.isChecked():
                self.checked_items.append(widget.text())
        data = ['#' + line if line in self.checked_items and '#' not in line else line[
                                                                                  1:] if line in self.checked_items and '#' in line else line
                for line in data]
        with open(config['setting'], 'w') as file:
            file.writelines(data)
        self.checked_items.clear()
        self.content_add()

    def deletesensor(self):
        with open(config['setting'], "r") as f:
            lines = f.readlines()

        self.checked_items.clear()
        names_to_remove = []

        # 1. Сохраняем выделенные строки и их имена
        for i in range(self.scrollLayout.count()):
            widget = self.scrollLayout.itemAt(i).widget()
            if isinstance(widget, QCheckBox) and widget.isChecked():
                line = widget.text()
                self.checked_items.append(line)
                name = line.strip().split()[0]
                names_to_remove.append(name)

        # 2. Удаляем строки из setting1.txt
        with open(config['setting'], 'w') as f:
            for line in lines:
                stripped = line.strip()

                # Сохраняем все заголовки, комментарии, пустые строки и т.д.
                if not stripped or stripped.startswith(
                        '#') or '##' in stripped or '###' in stripped or '###############################################################################' in stripped:
                    f.write(line)
                    continue

                # Берём имя первого слова (например DA3, RU4, Furn и т.д.)
                parts = stripped.split()
                name = parts[0] if parts else ''

                # Если имя не отмечено — оставляем строку
                if name not in names_to_remove:
                    f.write(line)

        # 3. Удаляем из GUI
        for name in names_to_remove:
            dlgMain.remove_sensor(name)

        # 4. Обновляем список в интерфейсе
        self.checked_items.clear()
        self.content_add()

    def addformula(self):
        variables = set(re.findall(r'[a-zA-Z]\w*', self.input3.text()))  # извлечение переменных из формулы
        missing_variables = [var for var in variables if
                             var != 'sqrt' and var not in [i.name for i in self.sensor_list]]

        if missing_variables:
            warning_window(f'Следующие {missing_variables} переменные отсутствуют в базе или скрыты (начинаются с #)',
                           False)
            return

        clr = config['COLORS'].get(self.cb_color_math.currentText(), self.cb_color_math.currentText().lstrip('#'))
        side = config['SIDE'].get(self.cb_name_side.currentText(), 'transparent')

        with open(config['setting'], 'r') as f:
            lines = f.readlines()
            counter = 1
            if self.input3_1.text() == '':
                while any('math' in line for line in lines):
                    counter += 1
                self.input3_1.setText(f'math{counter}')
            for line in lines:
                if self.input3_1.text() in line:
                    warning_window(f'{lines.index(line)} {self.input3_1.text()} уже в настройках', False)
                    return
        with open(config['setting'], 'a') as file:
            file.write(
                f'Math {self.input3_1.text()} {self.input3.text()} {clr} {side} {self.cb_bit_depth_math.currentText()} ({int(self.cb_pos_x_math.value())} {int(self.cb_pos_y_math.value())})')

    def send_ip(self):
        with open(config['setting'], 'r') as file:
            data = file.readlines()
        with open(config['setting'], 'w') as file:
            for line in data:
                if config['IPS'] == '{' in line:
                    if self.input4.text() not in config['IPS']:
                        line = line.replace('}', f',\'{self.input4.text()}\':\'{self.cb_add_type.currentText()}\'}}')

                file.write(line)

    def delip(self, ip_to_delete):
        with open(config['setting'], 'r') as f:
            lines = f.readlines()

        with open(config['setting'], 'w') as f:
            for line in lines:
                if config['IPS'] in line and '##' not in line:
                    del config['IPS'][ip_to_delete]
                    line = f'{config["IPS"]} = {str(config["IPS"])}\n'
                f.write(line)

    def create_item(self, objct):
        # Создание айтима`
        side = config['SIDE'].get(self.cb_name_side.currentText(), 'transparent')
        p = {k: i + 1 for i, k in enumerate(config['IPS'])}
        ip = p.get(self.cb_reg.currentText())
        clr = config['COLORS'].get(self.cb_color.currentText(), self.cb_color.currentText().lstrip('#'))
        with open(config['setting'], 'r') as f:
            lines = f.readlines()
            for line in lines:
                try:
                    words = line.split(' ')
                    if objct == 'sensor' and self.cb_name.currentText() + self.cb_namenumber.currentText() in line or \
                            self.cb_channel.currentText() == words[1] and objct == 'sensor' and str(
                        self.cb_reg.currentIndex() + 1) in words[
                        5]:
                        warning_window(
                            f"Строка {lines.index(line) + 1} {self.cb_name.currentText() + self.cb_namenumber.currentText() + ' ' + self.cb_channel.currentText() + ' ' + str(self.cb_reg.currentIndex() + 1)} sensor уже  присутствует в настройках.",
                            False)
                        return

                    if (objct == 'RU' and words[
                        0] == self.cb_name_ru.currentText() + self.cb_name_runumber.currentText() or \
                            objct == 'RU' and self.cb_chr_open.currentText() == words[2] and str(
                                self.cb_reg_ru.currentIndex() + 1) in words[6] or \
                            objct == 'RU' and self.cb_chr_close.currentText() == words[3] and str(
                                self.cb_reg_ru.currentIndex() + 1) in words[6] or \
                            objct == 'RU' and self.cb_chdv_open.currentText() == words[4] and str(
                                self.cb_reg_ru.currentIndex() + 1) in words[6] or \
                            objct == 'RU' and self.cb_chdv_close.currentText() == words[5] and str(
                                self.cb_reg_ru.currentIndex() + 1) in words[6]):
                        warning_window(
                            f"Строка {lines.index(line)} {self.cb_name_ru.currentText() + self.cb_name_runumber.currentText()} RU уже  присутствует в настройках.",
                            False)
                        return
                    if objct == 'Furn' and f'F{str(self.number.value())}' == words[1] or \
                            objct == 'Furn' and 'Furn' in line and str(self.ch_furn.value()) == words[2] and str(
                        self.reg_furn.value()) == words[4]:
                        print(line)
                        warning_window(
                            f"Строка {lines.index(line) + 1} {f'F{str(self.number.value())} '} {str(self.ch_furn.value())} {str(self.max.value())} {str(self.reg_furn.value())}  Furn уже  присутствует в настройках.",
                            False)
                        return
                except Exception:
                    pass
        with open(config['setting'], 'w') as f:
            count = 0
            for i, line in enumerate(lines):
                f.write(line)
                if config['GRID'] in line:
                    count += 1
                if count == 2 and objct == 'sensor':
                    count += 1
                    f.write(
                        f'{self.cb_name.currentText() + self.cb_namenumber.currentText()} {self.cb_channel.currentText()} {clr} {side} {self.cb_bit_depth.currentText()} {ip} 0.0 ({int(self.cb_pos_x.value())} {int(self.cb_pos_y.value())})\n')
                    name = self.cb_name.currentText() + self.cb_namenumber.currentText()
                    ch = int(self.cb_channel.currentText())
                    clr = config['COLORS'].get(self.cb_color.currentText(), self.cb_color.currentText().lstrip('#'))
                    side = config['SIDE'].get(self.cb_name_side.currentText(), 'left')
                    bit_depth = int(self.cb_bit_depth.currentText())
                    reg = self.cb_reg.currentIndex() + 1  # индекс начинается с 0, а у тебя в файле с 1
                    amendment = 0.0  # по умолчанию
                    x = int(self.cb_pos_x.value())
                    y = int(self.cb_pos_y.value())
                    sensor_key = (reg - 1, ch - 1)
                    if sensor_key not in dlgMain.sensor_by_key:
                        dlgMain.add_sensor(name, ch, clr, side, bit_depth, reg, amendment, (x, y))

                    sensor = dlgMain.sensor_by_key.get(sensor_key)
                    if sensor:

                        if sensor not in dlgMain.sensor_list:
                            dlgMain.sensor_list.append(sensor)
                        if sensor not in dlgMain.ourch:
                            dlgMain.ourch.append(sensor)
                        dlgMain.ourch_split.setdefault(sensor.reg, []).append(sensor)
                        dlgMain.sensor_by_name[sensor.name] = sensor
                        dlgMain.do_things()  # ← 1. вызываем сразу при запуске
                    #      self.content_add()

                    else:
                        print(f"[ERROR] sensor not found after add: {sensor_key}")

                    start_grids_index = 2
                    end_grids_index = 3
                    sort_key_index = 5
                if count == 4 and objct == 'RU':
                    count += 1
                    f.write(
                        f'{self.cb_name_ru.currentText() + self.cb_name_runumber.currentText()} {config["ORIENTATION"].get(self.cb_orientate.currentText())} {self.cb_chr_open.currentText()} {self.cb_chr_close.currentText()} {self.cb_chdv_open.currentText()} {self.cb_chdv_close.currentText()} {self.cb_reg_ru.currentIndex() + 1} ({int(self.cb_pos_x.value())} {int(self.cb_pos_y.value())})\n')
                    start_grids_index = 4
                    end_grids_index = 5
                    sort_key_index = 6
                if count == 6 and objct == 'Furn':
                    count += 1
                    f.write(
                        f'Furn F{str(self.number.value())} {str(self.ch_furn.value())} {str(self.max.value())} {str(self.reg_furn.value())} ({str(int(self.cb_pos_x_furn.value()))} {str(int(self.cb_pos_y_furn.value()))})\n')
                    start_grids_index = 6
                    end_grids_index = 7
                    sort_key_index = 4
                if count == 8 and objct == 'Rer':
                    count += 1
                    f.write(
                        f'{self.r1.currentText()}~{self.r2.currentText()} {str(self.r1_sleep.value())} {str(self.r2_sleep.value())} {str(int(self.time_rearrangement.value()))} ({str(int(self.cb_pos_x_rerange.value()))} {str(int(self.cb_pos_y_rerange.value()))})\n')
        if objct != 'Rer':
            self.extract_text_between_grids(start_grids_index, end_grids_index, sort_key_index)

    def get_name(self):
        count = 0
        with open(config['setting'], 'r') as f:
            for i, line in enumerate(f):
                if config['GRID'] in line:
                    count += 1
                if count == 2:
                    lines = [line for line in f if '##' not in line or line == '\n']
                    break
        return lines

    def reboots(self):
        pass
        ## dlgMain.reboots()
        # for widget in dlgMain.topLevelWidgets():
        #    if isinstance(widget, QMainWindow):
        #        widget.close()
        ## Объявление, что мы используем глобальную переменную
        # dlgMain.close()
        # dlgMain = MainShem()
        # dlgMain.run_app()


class GraphWindow(QMainWindow):
    data_for_graph = {}  # Общие данные датчика для всех экземпляров
    name_formuls = []
    formuls = []
    print(data_for_graph)

    def __init__(self):

        super().__init__()
        self.all_impuls = Damper.all_impuls
        self.sensor_data = dlgMain.sensor_list
        self.setWindowTitle('График_0')
        self.menu = self.menuBar().addMenu('Выбор датчиков')
        menu2 = self.menuBar().addMenu('Новое окно(F2)')
        self.actions = {}
        action_reverse = QAction("Обратное состояние F3", self)
        action_reverse.triggered.connect(self.revers_checks)
        self.menu.addAction(action_reverse)

        action_clear_all = QAction("Снять все F4", self)
        action_clear_all.triggered.connect(self.clear_all_checks)
        self.menu.addAction(action_clear_all)

        for item in self.sensor_data + self.name_formuls:
            action = QAction(str(item), self)
            action.setCheckable(True)
            action.setChecked(True)
            action.triggered.connect(lambda checked, sensor=item: self.toggle_sensor(checked, sensor))
            self.menu.addAction(action)
            self.actions[item] = action

        create_action = QAction('Создать новое окно', self)
        create_action.triggered.connect(self.create_new_graph_window)
        menu2.addAction(create_action)
        menu3 = self.menuBar().addMenu('Скрыть рамки(F1)')
        create_action_hide = QAction('Скрыть', self)
        create_action_hide.triggered.connect(self.toggle_visibility)
        menu3.addAction(create_action_hide)

        # Создаем объект графика
        self.graphwidget = pg.PlotWidget(self)
        self.setCentralWidget(self.graphwidget)

        # Настраиваем параметры графика
        self.graphwidget.showGrid(x=True, y=True)
        self.graphwidget.setBackground('#1A1A1A')

        axis = pg.DateAxisItem(orientation='bottom')
        axis.setTickFont(QFont('Arial', 11))
        self.line = pg.PlotCurveItem(pen="g")
        self.graphwidget.addItem(self.line)
        self.graphwidget.setAxisItems({"bottom": axis})
        self.graphwidget.setLabel('bottom',
                                  f'<span style="font-size: 14px;">{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</span>')

        # Инициализируем данные для графика
        self.data = {}
        for sensor in self.sensor_data + self.name_formuls:
            self.data[sensor] = {'x': [], 'y': []}
        legend = pg.LegendItem()
        legend.setParentItem(self.graphwidget.graphicsItem())
        # Создаем кривые для каждого датчика
        self.curves = {}
        self.list_name = []
        # Создаем текстовые элементы для каждого датчика
        self.text_items = {}
        for sensor in self.sensor_data:
            self.curves[sensor] = self.graphwidget.plot(self.data[sensor]['x'], self.data[sensor]['y'],
                                                        pen=pg.mkPen(color=pg.intColor(self.sensor_data.index(sensor)),
                                                                     width=2))
            self.text_items[sensor] = TextItem('', anchor=(0.5, 0))
            self.text_items[sensor].setFont(QFont('Arial', 11))
            self.graphwidget.addItem(self.text_items[sensor])
            self.list_name.append(sensor.name)

        for name in self.name_formuls:
            self.curves[name] = self.graphwidget.plot(self.data[name]['x'], self.data[name]['y'], pen=pg.mkPen(
                color=pg.intColor((self.name_formuls.index(name) + 10) * (-1)),
                width=2))
            self.text_items[name] = TextItem('', anchor=(0.5, 0))
            self.text_items[name].setFont(QFont('Arial', 11))

            self.graphwidget.addItem(self.text_items[name])
            self.list_name.append(name)
        self.graphwidget.setLabel('left',
                                  f'<span style="font-size: 14px;">      {" ".join(str(item) for item in self.list_name)}</span>')
        # Запускаем таймер обновления графика
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_graph)
        self.timer.start(config['graph_step'])  # Обновление каждую секунду
        shortcuts = [
            (Qt.Key_F1, self.toggle_visibility),
            (Qt.Key_F2, self.create_new_graph_window),
            (Qt.Key_F3, self.revers_checks),
            (Qt.Key_F4, self.clear_all_checks),
        ]
        for key, function in shortcuts:
            shortcut = QShortcut(QKeySequence(key), self)
            shortcut.activated.connect(function)
        self.resize_to_quarter_screen()
        keyboard.add_hotkey('PrtScn', self.print_screen)
        self.graphwidget.getAxis('left').setStyle(tickFont=QFont('Arial', 12))

    def clear_all_checks(self):
        for sensor, action in self.actions.items():
            if action.isChecked():
                action.setChecked(False)
                self.toggle_sensor(False, sensor)

    def revers_checks(self):
        for sensor, action in self.actions.items():
            action.setChecked(not action.isChecked())
            self.toggle_sensor(action.isChecked(), sensor)

    def print_screen(self):
        os.makedirs(os.path.dirname(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/'), exist_ok=True)
        self.grab().save(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/' + time.strftime(config['format_time'],
                                                                                              time.localtime()) + '_' + self.windowTitle() + ".jpg")

    def resize_to_quarter_screen(self):
        desktop = QApplication.desktop()
        screen_rect = desktop.screenGeometry()
        width = screen_rect.width() // 2
        height = screen_rect.height() // 2
        self.setGeometry(screen_rect.x(), screen_rect.y(), width, height)

    def toggle_visibility(self):
        # Инвертируем наличие флага Qt.FramelessWindowHint
        is_frameless = not (self.windowFlags() & Qt.FramelessWindowHint)

        # Устанавливаем или убираем флаги в зависимости от значения is_frameless
        self.setWindowFlag(Qt.FramelessWindowHint, is_frameless)
        self.setWindowFlag(Qt.WindowStaysOnTopHint, is_frameless)

        # Отображаем или скрываем меню в зависимости от значения is_frameless
        self.menuBar().setVisible(not is_frameless)

        # Показываем окно
        self.show()

    def create_new_graph_window(self):
        window_name = "График"
        window_number = 1
        while True:
            var_name = f"{window_name}_{window_number}"
            if var_name not in globals():
                break
            window_number += 1
        graph_window = GraphWindow()
        graph_window.setWindowTitle(var_name)
        globals()[var_name] = graph_window
        graph_window_thread = threading.Thread(target=graph_window.show())
        graph_window_thread.start()

    def toggle_sensor(self, checked, sensor):
        # Изменение видимости данных датчика на графике
        sensor_name = sensor.name if hasattr(sensor, 'name') else sensor
        self.curves[sensor].setVisible(checked)
        self.text_items[sensor].setVisible(checked)
        (self.list_name.remove if not checked else self.list_name.append)(sensor_name)
        self.graphwidget.setLabel('left', '    '.join(map(str, self.list_name)))

    def update_graph(self):
        max_points = config['graph_point']
        current_time = time.time()
        current_time_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.graphwidget.getAxis('bottom').setLabel(
            f'<span style="font-size: 14px;">{current_time_str}</span>')

        def update_data(sensor, new_value):
            self.data[sensor]['x'].append(current_time)
            self.data[sensor]['y'].append(new_value)

            if len(self.data[sensor]['x']) > max_points:
                self.data[sensor]['x'] = self.data[sensor]['x'][-max_points:]
                self.data[sensor]['y'] = self.data[sensor]['y'][-max_points:]

            x_vals = self.data[sensor]['x']
            y_vals = [val if val is not None else np.nan for val in self.data[sensor]['y']]
            self.curves[sensor].setData(x_vals, y_vals)
            last_value = self.data[sensor]['y'][-1]
            sensor_name = getattr(sensor, 'name', str(sensor))
            self.text_items[sensor].setText(f'{last_value:.3f}  {sensor_name}')
            self.text_items[sensor].setPos(self.data[sensor]['x'][-1], last_value)

        def setup_impuls_data(sensor_name):
            action = QAction(str(sensor_name), self)
            action.setChecked(True)
            action.setCheckable(True)
            action.triggered.connect(lambda checked, sensor=sensor_name: self.toggle_sensor(checked, sensor))
            self.menu.addAction(action)
            self.actions[sensor_name] = action
            self.data[sensor_name] = {'x': [], 'y': []}
            self.curves[sensor_name] = self.graphwidget.plot(
                self.data[sensor_name]['x'],
                self.data[sensor_name]['y'],
                pen=pg.mkPen(color=pg.intColor(random.randint(0, 255 * 255 * 255)), width=2)
            )
            self.text_items[sensor_name] = TextItem('', anchor=(0.5, 0))
            self.text_items[sensor_name].setFont(QFont('Arial', 11))
            self.graphwidget.addItem(self.text_items[sensor_name])
            self.list_name.append(sensor_name)

        if GraphWindow.data_for_graph:
            flat_datas = [item for sublist in GraphWindow.data_for_graph for item in sublist]
        else:
            flat_datas = []
        for sensor in self.sensor_data:
            value = GraphWindow.data_for_graph.get((sensor.reg, sensor.ch), None)
            if value is None:
                continue
            try:
                new_value = float(f"{value:.3f}")
                update_data(sensor, new_value)
            except Exception:
                pass
        for i, (name, formuls) in enumerate(zip(self.name_formuls, self.formuls)):
            new_value = float(f"{GraphWindow.formuls[i]:.3f}")
            update_data(name, new_value)
        for n, imp in self.all_impuls.items():
            new_value = float(imp)
            if n not in self.data:
                setup_impuls_data(n)
            update_data(n, new_value)


class SetPointWindow(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.resizing = False
        self.setMouseTracking(True)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)
        self.setWindowTitle("Уставки")
        #  self.setMinimumSize(400, 200)
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(4, 4, 4, 4)
        self.main_layout.setSpacing(2)

        # 🔲 кастомный заголовок
        self.title_bar = QWidget()
        self.title_layout = QHBoxLayout(self.title_bar)
        self.title_layout.setContentsMargins(0, 0, 0, 0)

        self.title_label = QLabel("Уставки")
        self.title_label.setFont(QFont("Arial", 12))

        btn_toggle = QPushButton("⚙")
        btn_toggle.setFixedSize(25, 25)
        btn_toggle.clicked.connect(lambda: self.toggle_control_panel(not self.zoom_slider.isVisible()))

        btn_min = QPushButton("−")
        btn_min.setFixedSize(25, 25)
        btn_min.clicked.connect(self.showMinimized)

        btn_close = QPushButton("×")
        btn_close.setFixedSize(25, 25)
        btn_close.clicked.connect(self.close)

        self.title_layout.addWidget(self.title_label)
        self.title_layout.addStretch()
        self.title_layout.addWidget(btn_toggle)
        self.title_layout.addWidget(btn_min)
        self.title_layout.addWidget(btn_close)
        self.main_layout.addWidget(self.title_bar)

        # 🔁 Контейнер уставок
        self.container = QWidget()
        self.container.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)

        self.container_layout = QVBoxLayout(self.container)
        self.container_layout.setContentsMargins(2, 2, 2, 2)
        self.container_layout.setSpacing(2)
        self.container_layout.setSizeConstraint(QLayout.SetMinimumSize)

        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setWidget(self.container)
        self.scroll.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        #  self.scroll.setMinimumHeight(150)
        self.main_layout.addWidget(self.scroll)

        self.set_points = []
        self.index_counter = 0

        for i in range(config['pack']):
            self.add_set_point()

        # 🔧 Масштаб
        self.zoom_slider = QSlider(Qt.Horizontal)
        self.zoom_slider.setRange(-30, 70)
        self.zoom_slider.setValue(0)
        self.zoom_slider.setTickInterval(5)
        self.zoom_slider.setTickPosition(QSlider.TicksBelow)
        self.zoom_slider.valueChanged.connect(self.update_setpoint_scale)
        self.main_layout.addWidget(self.zoom_slider)

        # ➕➖
        self.btn_add = QPushButton("➕ Добавить уставку")
        self.btn_del = QPushButton("➖ Удалить последнюю")
        self.btn_add.clicked.connect(self.add_set_point)
        self.btn_del.clicked.connect(self.remove_set_point)
        self.btn_add.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        self.btn_del.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        self.main_layout.addWidget(self.btn_add)
        self.main_layout.addWidget(self.btn_del)

    def mousePressEvent(self, event):
        margin = 6
        if event.button() == Qt.LeftButton:
            if self.is_near_bottom_right(event.pos(), margin):
                self.resizing = True
                self.drag_position = event.globalPos()
                self.original_size = self.size()
            else:
                self.moving = True
                self.drag_position = event.globalPos() - self.frameGeometry().topLeft()

    def mouseMoveEvent(self, event):
        if self.resizing:
            delta = event.globalPos() - self.drag_position
            new_width = max(self.minimumWidth(), self.original_size.width() + delta.x())
            new_height = max(self.minimumHeight(), self.original_size.height() + delta.y())
            self.resize(new_width, new_height)
        elif getattr(self, 'moving', False) and event.buttons() == Qt.LeftButton:
            self.move(event.globalPos() - self.drag_position)
        else:
            if self.is_near_bottom_right(event.pos(), 6):
                if self.cursor().shape() != Qt.SizeFDiagCursor:
                    self.setCursor(Qt.SizeFDiagCursor)
            else:
                if self.cursor().shape() != Qt.ArrowCursor:
                    self.setCursor(Qt.ArrowCursor)

    def mouseReleaseEvent(self, event):
        self.resizing = False
        self.moving = False

    def is_near_bottom_right(self, pos, margin):
        return (
                abs(pos.x() - self.width()) <= margin and
                abs(pos.y() - self.height()) <= margin
        )

    def toggle_control_panel(self, visible: bool):
        # Показывает или скрывает панель управления
        for widget in [self.zoom_slider, self.btn_add, self.btn_del]:
            widget.setVisible(visible)

    def update_setpoint_scale(self, value):
        for sp in self.set_points:
            if hasattr(sp, "setFont"):  # вдруг был удалён
                sp.scaletext(value)

    def scaletext(self, value):
        try:
            value = int(value)
        except ValueError:
            value = 0

        value = max(-10, min(value, 50))
        font_size = 10 + value
        font = QFont('Arial', font_size)
        for w in self.findChildren(QWidget):
            w.setFont(font)

    #  self.setMinimumHeight(50 + value * 2)

    def add_set_point(self):
        sp = Set_point(self.parent(), self.index_counter)
        self.container_layout.addWidget(sp)
        self.set_points.append(sp)
        self.index_counter += 1

    def remove_set_point(self):
        if not self.set_points:
            return

        sp = self.set_points.pop()

        sp.alive = False  # 🧠 сигнал для потоков: объект уничтожается

        # Безопасно отключаем square_widget
        if hasattr(sp, "square_widget"):
            sp.square_widget.alive = False
            sp.square_widget.setParent(None)
            sp.square_widget.deleteLater()

        # Удаляем сам виджет уставки
        sp.setParent(None)
        sp.deleteLater()

        self.index_counter -= 1


class MainShem(QMainWindow, File_formatter):
    update_sensor_value = pyqtSignal(str, float)  # сигнал: имя сенсора и новое значение

    def __init__(self, parent=None):
        super(MainShem, self).__init__(parent)
        self.update_sensor_value.connect(self.on_update_sensor_value)
        self.timestart_lock = threading.Lock()
        self.do_things()  # ← 1. вызываем сразу при запуске
        self.showFullScreen()
        self.first = True
        self.labelimg = QLabel(self)
        self.pixmap = QPixmap(config['IMG'])
        self.labelimg.setPixmap(self.pixmap)
        self.labelimg.setScaledContents(True)
        self.labelimg.setPixmap(self.pixmap.scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
        self.opacity_effect = QGraphicsOpacityEffect()
        self.labelimg.setGraphicsEffect(self.opacity_effect)
        self.labelimg.setGeometry(25, 25, int(self.width() - 50), int(self.height() - 50))
        self.labelimg.show()

        self.ourch = self.read_file(config['setting'])
        self.sensor_by_name = {s.name: s for s in self.ourch}

        self.ourch_split = defaultdict(list)
        for sensor in self.ourch:
            self.ourch_split[sensor.reg].append(sensor)
            sensor.scaletext(config['sensor_size'])
        self.sensor_by_key = {}
        for sensor in self.ourch:
            self.sensor_by_key[(sensor.reg, sensor.ch)] = sensor

        self.timermup = QTimer()
        self.formuls_math = [fd.mathematics.replace('sqrt', 'cmath.sqrt') for fd in self.formuls]
        self.formuls_math = [fd.mathematics.replace('log', 'cmath.log') for fd in self.formuls]
        self.timermup.timeout.connect(lambda: self.update_label(self.formuls_math))
        self.timermup.start(100)

        self.texttime = QWidget(self)
        w = config.get("textbox_w", 500)
        h = config.get("textbox_h", 180)
        self.texttime.setFixedSize(w, h)

        self.layout = QHBoxLayout()

        stl = "border: 2px solid black;border-radius: 10px;background-color:rgb(213,199,182)"
        self.Time = QLabel()
        self.Time.setGeometry(0, 0, 150, 100)
        self.Time.setFont(QFont('Arial', 30))
        self.Time.setStyleSheet(stl)
        self.layout.addWidget(self.Time)

        self.button = QPushButton('+')
        self.button.clicked.connect(self.Sensoradd)

        self.button.setStyleSheet(stl)
        self.button.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        self.layout.addWidget(self.button)

        self.input = QTextEdit(self)
        self.input.setFont(QFont('Arial', 24))
        self.input.setStyleSheet(stl)
        self.layout.addWidget(self.input)

        self.input.textChanged.connect(self.text_changed)
        self.timerfile = QTimer(self)
        self.timerfile.setSingleShot(True)
        self.timerfile.timeout.connect(self.input.clearFocus)

        self.texttime.setLayout(self.layout)
        self.texttime.show()
        self.old_pos = None

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.showTime)
        self.timer.start()

        self.checkBox = QCheckBox()
        self.checkBox.stateChanged.connect(self.on_checkbox_changed)
        self.layout.addWidget(self.checkBox)

        self.timerfile = QTimer()
        self.timerfile.timeout.connect(self.do_things)
        self.timerfile.start(3600000)

        top_right_point = QApplication.desktop().availableGeometry().topRight()

        self.reboot = QPushButton(self)
        self.reboot.setGeometry(555, 555, 25, 25)
        self.reboot.move(top_right_point / 1.0525)
        self.reboot.clicked.connect(self.rebo)
        self.reboot.setText('↻')
        self.reboot.setFont(QFont('Arial', 16))
        self.reboot.show()

        self.exit = QPushButton(self)
        self.exit.setGeometry(555, 555, 25, 25)
        self.exit.move(top_right_point / 1.015)
        self.exit.clicked.connect(self.close_event)
        self.exit.setText('X')
        self.exit.setFont(QFont('Arial', 14))
        self.exit.show()

        self.full = QPushButton(self)
        self.full.setGeometry(555, 555, 25, 25)
        self.full.move(top_right_point / 1.0275)
        self.full.clicked.connect(self.full_roll)
        self.full.setFont(QFont('Arial', 16))
        self.full.setText('❒')
        self.full.show()

        self.roll = QPushButton(self)
        self.roll.setGeometry(555, 555, 25, 25)
        self.roll.move(top_right_point / 1.04)
        self.roll.clicked.connect(self.showMinimized)
        self.roll.setText('_')
        self.roll.show()
        keyboard.add_hotkey('PrtScn', self.print_screen)
        self.out = []

        self.set_window = SetPointWindow(self)
        self.set_window.setWindowModality(Qt.NonModal)  # ← это важно
        self.set_window.show()
        main_geom = self.geometry()
        set_geom = self.set_window.frameGeometry()

        x = main_geom.x() + (main_geom.width() - set_geom.width()) // 2
        y = main_geom.y() + main_geom.height() - set_geom.height() - 10  # отступ 10px от низа

        self.set_window.move(x, y)
        QTimer.singleShot(1000, self.setup_network)

        self.damper_timer = QTimer(self)
        self.damper_timer.timeout.connect(self.update_all_dampers)
        self.damper_timer.start(200)

    #  for w in self.findChildren(QWidget):
    #      rect = w.geometry()
    #      if "QWidget" in str(type(w)) and rect.width() > 100 and rect.y() > 700:
    #          print(f"[FOUND] QWidget at {rect} →", w)
    #          w.setStyleSheet("background: rgba(255, 0, 0, 40); border: 2px dashed red;")
    #          import traceback
    #          print("[CREATED SQUARE]", traceback.format_stack())

    #  for child in self.findChildren(QWidget):
    #      if hasattr(child, 'name'):
    #          continue  # пропускаем нормальные элементы (sensor, damper...)

    #      g = child.geometry()
    #      label = QLabel(f"{type(child).__name__} @ {g.x()},{g.y()} {g.width()}x{g.height()}", child)
    #      label.setStyleSheet("color: red; background: rgba(255,255,255,200); font-size: 10px;")
    #      label.move(5, 5)
    #      label.show()

    #      child.setStyleSheet("background: rgba(0, 0, 255, 20); border: 1px dashed blue;")

    def update_all_dampers(self):
        for damper in self.dampers_list:
            damper.update_lab_color()

    def setup_network(self):
        try:
            self.sendol = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sendol.connect((config["ip"], config["port"]))
            print("[setup_network] Connected")
        except Exception as e:
            print(f"[setup_network ERROR] {e}")
            self.sendol = None

    def text_changed(self):
        self.timerfile.start(36000)

    def add_sensor(self, name, ch, clr, side, bit_depth, reg, amendment, pos):
        sensor = Sensor(name, ch, clr, side, bit_depth, reg, amendment, self)
        sensor.move(*pos)
        sensor.show()
        self.ourch.append(sensor)

        # Обновляем индексированные структуры
        self.sensor_by_name[name] = sensor
        self.sensor_by_key[(sensor.reg, sensor.ch)] = sensor
        self.ourch_split[sensor.reg].append(sensor)

    def rebo(self, event):
        reply = QMessageBox.question(self, 'Message',
                                     "Вы уверены, что хотите перезагрузить?", QMessageBox.Yes |
                                     QMessageBox.No, QMessageBox.No)
        self.reboots() if reply == QMessageBox.Yes else event.ignore()

    def close_event(self, event):
        reply = QMessageBox.question(self, 'Message',
                                     "Вы уверены, что хотите выйти?", QMessageBox.Yes |
                                     QMessageBox.No, QMessageBox.No)
        os._exit(1) if reply == QMessageBox.Yes else event.ignore()

    def remove_sensor(self, name: str):
        sensor = self.sensor_by_name.get(name)
        if not sensor:
            print(f"[Удаление] Датчик {name} не найден")
            return

        key = (sensor.reg, sensor.ch)

        # Удаляем виджет
        sensor.hide()
        sensor.setParent(None)

        # Удаляем из внутренних списков
        self.ourch.remove(sensor)
        self.sensor_by_key.pop(key, None)
        self.ourch_split[sensor.reg].remove(sensor)
        self.sensor_by_name.pop(name, None)

        print(f"[Удаление] Датчик {name} удалён из интерфейса")

    def full_roll(self):
        if self.isFullScreen():
            self.showNormal()
            self.showMaximized()
        else:
            self.showFullScreen()

    def do_things(self):
        with self.timestart_lock:
            self.timestart = time.strftime(config['format_time'], time.localtime())

    def on_checkbox_changed(self, value):
        for item in [self.ourch, self.dampers_list, self.formuls, self.const, self.lamps]:
            for i in range(len(item)):
                item[i].moveon = Qt.CheckState(value) == Qt.CheckState.Checked
        if Qt.CheckState(value) == Qt.CheckState.Unchecked:
            for item in [self.ourch, self.dampers_list]:
                for i in range(len(item)):
                    item[i].moveon = False
        #    self.close()
        #   QProcess.startDetached(sys.executable, sys.argv)

    def redakt(self, text):
        with fileinput.FileInput(config['setting'], inplace=True,
                                 backup='.bak') as f:
            for line in f:
                if text[:text.find(' ')] + ' ' in line:
                    def find_2nd(string, substring):
                        return string.find(
                            substring, string.find(substring) + 8)

                    if '+' in text:
                        print(line[:find_2nd(line, ' ')] +
                              ' ' +
                              text[text.find('+') +
                                   1:] +
                              line[line.find(' ('):], end='')
                    elif '-' in text:
                        print(line[:find_2nd(line, ' ')] +
                              ' ' +
                              text[text.find('-'):] +
                              line[line.find(' ('):], end='')
                else:
                    print(line, end='')
            self.close()
            QProcess.startDetached(sys.executable, sys.argv)

    def Sensoradd(self):
        s = Setting()
        s.central_widget.show()
        s.show()

    def showTime(self):
        self.Time.setText(QDateTime.currentDateTime().toString('d/M/yy\nhh:mm:ss'))

    def tofile(self, data_by_key, fd):
        """
        Сохраняет текущие значения сенсоров и формул в CSV-отчёт.
        """

        report_path = config["IZDELIE"] + f'/report_{config["IZDELIE"]}/'
        os.makedirs(report_path, exist_ok=True)
        file_path = os.path.join(report_path, f'{self.timestart}.txt')

        try:
            ordered_sensors = sorted(self.sensor_list, key=lambda s: (s.reg, s.ch))
            sensor_names = [f'{s.name.lstrip("#")}_{s.ch + 1}_{s.reg + 1}' for s in ordered_sensors]
            sensor_values = [data_by_key.get((s.reg, s.ch), float('nan')) for s in ordered_sensors]

            self.df = pd.DataFrame([sensor_values], columns=sensor_names)
            self.df.insert(0, 'Time', datetime.now().strftime('%H:%M:%S.%f')[:-3])
            self.df.insert(0, 'Data', datetime.now().strftime('%d/%m/%y'))

            # Добавляем формулы
            for i, formula in enumerate(self.formuls):
                try:
                    value = float(fd[i])
                    formatted = f"{value:.{formula.bit_depth}f}"
                except (ValueError, TypeError, IndexError):
                    formatted = "nan"
                self.df[formula.name] = formatted

            numeric_columns = self.df.select_dtypes(include=[np.number]).columns
            self.df[numeric_columns] = self.df[numeric_columns].astype('float32')

            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            write_header = not os.path.isfile(file_path)

            self.df.to_csv(
                file_path,
                mode='a',
                sep=';',
                index=False,
                header=write_header,
                float_format='%.4f',
                decimal=','
            )

        except Exception as e:
            print(f"[report] ❌ Ошибка при сохранении отчёта: {e}")
            self.do_things()

    def update_label(self, copy_formuls):
        QTimer.singleShot(0, lambda: self._process_update(copy_formuls.copy()))

    # self.calculate_formulas([f.mathematics.replace('sqrt', 'cmath.sqrt') for f in self.formuls])

    def _process_update(self, formuls):
        try:
            raw_data = self._fetch_data()
            data_by_key = {}
            for reg_index, data_group in enumerate(raw_data):
                sensors = self.ourch_split.get(reg_index, [])
                for sensor, value in zip(sensors, data_group):
                    data_by_key[(sensor.reg, sensor.ch)] = value

            self._distribute_data(data_by_key)
            fd = self._update_ui_and_formulas(data_by_key, formuls)
            self._finalize_output(data_by_key, fd)

        except Exception as e:
            print(f"[update_label error] {e}")
            warning_window(str(e))

    def _fetch_data(self):
        if config['imitation']:
            return [[box.value() for box in self.spin_boxes]]
        else:
            return fetch_live_data()

    def _distribute_data(self, data):
        GraphWindow.data_for_graph = \
            Timers.sensor_data = \
            Set_point.sensor_data = \
            Damper.sensor_data = \
            Furnace.sensor_data = data

    def _update_ui_and_formulas(self, data, formuls):
        self.update_sensor_data(data, formuls)
        fd = self.calculate_formulas()
        return fd

    def _finalize_output(self, data, fd):
        if not config['imitation']:
            self.tofile(data, fd)
            ServerSocket.data = data

    # end_time = time.time()
    # execution_time = end_time - start_time
    # print(f"update_lable: {execution_time} секунд")
    @pyqtSlot(str, float)
    def on_update_sensor_value(self, sensor_name):
        sensor = self.sensor_by_name.get(sensor_name)
        if sensor:
            value = self.sensor_data.get((sensor.reg, sensor.ch), float('nan'))
            sensor.l2.setText(f"{value + sensor.amendment:.{sensor.bit_depth}f}")


    def update_sensor_data(self, data_by_key, formuls):
        """
        Обновляет значения сенсоров и переменные для формул.

        :param data_by_key: Dict[(reg, ch)] = value
        :param formuls: список строк формул
        """
        updated_vars = {}

        self.sensor_data = data_by_key
        for sensor in self.ourch:
            key = (sensor.reg, sensor.ch)
            value = data_by_key.get(key, float('nan'))
            updated_vars[sensor.name] = value
            self.update_sensor_value.emit(sensor.name, value)

        # Обновляем глобальные структуры
        GraphWindow.data_for_graph = data_by_key
        Timers.sensor_data = data_by_key
        Set_point.sensor_data = data_by_key
        Damper.sensor_data = data_by_key
        Furnace.sensor_data = data_by_key

        # Обновляем переменные в формулах (без вычисления пока)
        from re import compile as re_compile
        rx = re_compile(r'\b[a-zA-Z_]\w*\b')
        for i in range(len(formuls)):
            formuls[i] = rx.sub(lambda m: str(updated_vars.get(m.group(), 'nan')), formuls[i])

    def calculate_formulas(self, _=None):
        try:
            variable_map = self._build_variable_map()

            def prepare_expression(expr: str):
                # 1. сначала заменим math-функции
                math_funcs = [
                    'sqrt', 'log', 'exp',
                    'sin', 'cos', 'tan',
                    'asin', 'acos', 'atan',
                    'sinh', 'cosh', 'tanh'
                ]
                for func in math_funcs:
                    expr = re.sub(rf'\b{func}\s*\(', f'cmath.{func}(', expr)

                # 2. затем — подставим переменные (гарантированно с границами)
                for key, val in variable_map.items():
                    if val is None:
                        val = float('nan')
                    pattern = re.compile(r'\b{}\b'.format(re.escape(key)))
                    expr = pattern.sub(str(val), expr)

                return expr

            aeval = Interpreter(usersyms={
                "cmath": __import__('cmath'),
                "math": __import__('math')
            }, minimal=True)

            length = len(self.formuls)
            GraphWindow.formuls = [float('nan')] * length
            Timers.formuls = [float('nan')] * length
            Set_point.formuls = [float('nan')] * length

            results = []
            for i, f in enumerate(self.formuls):
                expression = prepare_expression(f.mathematics)
                try:
                    result = aeval(expression)
                    if isinstance(result, complex):
                        if result.imag == 0:
                            result = result.real
                        else:
                            raise ValueError(f"Complex result with imaginary part: {result}")

                    if (
                            result is None or
                            not isinstance(result, (int, float)) or
                            math.isnan(result) or
                            math.isinf(result)
                    ):
                        raise ValueError("Bad result")

                    rounded = round(float(result), f.bit_depth)

                except Exception as e:
                    print(f"[FORMULA] {f.name}: {f.mathematics} = {result}")
                    print(f"[FORMULA ERROR] {f.name}: {e}")
                    rounded = float('nan')
                    with open('formula_errors.log', 'a') as log:
                        log.write(f"[{datetime.now()}] {f.name}: {expression} :: {e}\n")

                f.l2.setText(f"{rounded}")
                GraphWindow.formuls[i] = rounded
                Timers.formuls[i] = rounded
                Set_point.formuls[i] = rounded
                variable_map[f.name] = rounded
                results.append(rounded)

            return results

        except Exception as e:
            print('[calculate_formulas]', e)
            warning_window(f'Ошибка в формулах: {e}', False)

    def _build_variable_map(self):
        variables = {}
        for sensor in self.ourch:
            value = Damper.sensor_data.get((sensor.reg, sensor.ch), float('nan'))
            variables[sensor.name] = value
        for const in self.const:
            variables[const.name] = const.const
        return variables

    def _prepare_expression(self, formula: str, variable_map: dict):
        # Заменяем переменные на значения, без использования .replace()
        pattern = re.compile(r'\b[a-zA-Z_]\w*\b')
        return pattern.sub(lambda match: str(variable_map.get(match.group(), 'nan')), formula)

    def _evaluate_expression(self, expr: str):
        """
        Безопасный расчет выражения с помощью asteval.
        Поддерживает math-функции и cmath.

        :param expr: строка выражения
        :return: числовой результат (float)
        """
        aeval = Interpreter(usersyms={"cmath": __import__('cmath'), "math": __import__('math')}, minimal=True)
        result = aeval(expr)
        if aeval.error:
            raise ValueError(f"[FORMULA ERROR] {aeval.error[0].get_error()}")
        return float(result)

    def create_damper(self, setting_row):
        """
        Создает объект заслонки и добавляет его в список заслонок.

        Args:
            setting_row (list): Список параметров для создания заслонки.
            move (list): Список параметров движения.

        Returns:
            None
        """
        # Распаковываем параметры из списков
        name, pos, chdo1, chdo2, chdi1, chdi2, pos_auto, reg, pos_x, pos_y = setting_row
        print(name, pos, chdo1, chdo2, chdi1, chdi2, pos_auto, reg, pos_x, pos_y)
        DAMPER_WIDTH = 150
        DAMPER_WIDTH_V = 65
        DAMPER_HEIGHT = 70
        DAMPER_HEIGHT_V = 110
        damper = Damper(name, pos, int(chdo1), int(chdo2), int(chdi1), int(chdi2), pos_auto, int(reg), self)
        self.dampers_list.append(damper)

        if pos == 'V':
            damper_height = DAMPER_HEIGHT_V
            damper_width = DAMPER_WIDTH_V
        else:
            damper_height = DAMPER_HEIGHT
            damper_width = DAMPER_WIDTH
        damper_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": damper_width,
            "height": damper_height
        }
        if '#' in name:
            return
        self.show_element(damper, damper_data)

    def create_translate(self, row_translate):
        """
        Создает объект перекладки и добавляет его в список перекладок.

        Args:
            row_translate (list[str]): Список строк с параметрами для создания перекладки.

        Returns:
            None

        """
        # Извлекаем параметры из списка слов
        dampers, damper1_sleep, damper2_sleep, time, x, y = row_translate
        damper1, damper2 = dampers.split('~')
        translate = Translate(damper1, damper2, self.dampers_list, damper1_sleep, damper2_sleep, time, self)
        self.translate_list.append(translate)
        if '#' in row_translate:
            return
        translate.move(int(x), int(y))
        translate.show()

    def create_furnace(self, row_furnace):
        """
           Создает объект печи и добавляет его в список печей.

           Args:
               row_furnace (list[str]): Строка с параметрами для создания печи.

           Returns:
               None
           """
        furn, name, ch_ae, diapason, reg, x, y = row_furnace
        furnace = Furnace(name, int(ch_ae), float(diapason), int(reg), x, y, self)  # Furn F2 3 20 1
        self.furnace_list.append(furnace)
        if '#Furn' in row_furnace:
            return
        furnace.move(int(x), int(y))
        furnace.show()

    def create_const(self, math_config):
        """
        Создает объект математической формулы и добавляет его в список формул.

        Args:
            math_config (list): Список параметров для создания математической формулы.

        Returns:
            None
        """
        MATH_WIDTH = 120
        MATH_HEIGHT = 60

        # Распаковываем параметры из списка math_config
        const_type, name, const, color, side_name, unit, pos_x, pos_y, *extra_params = math_config

        # Создаем данные для отображения формулы
        math_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": MATH_WIDTH,
            "height": MATH_HEIGHT
        }

        # Создаем объект формулы
        math_const = Const(name, const, color, side_name, int(unit))

        # Устанавливаем родительский элемент
        math_const.setParent(self)

        # Добавляем формулу в список формул
        self.const.append(math_const)

        # Проверяем, есть ли символ '#' в имени, и если есть, пропускаем отображение
        if '#' in name:
            return

        # Отображаем формулу
        self.show_element(math_const, math_data)

    def create_math(self, math_config):
        """
        Создает объект математической формулы и добавляет его в список формул.

        Args:
            math_config (list): Список параметров для создания математической формулы.

        Returns:
            None
        """
        MATH_WIDTH = 120
        MATH_HEIGHT = 60

        # Распаковываем параметры из списка math_config
        math_type, name, formula, color, side_name, unit, pos_x, pos_y, *extra_params = math_config

        # Создаем данные для отображения формулы
        math_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": MATH_WIDTH,
            "height": MATH_HEIGHT
        }

        # Создаем объект формулы
        math_formula = Formula(name, formula, color, side_name, int(unit))

        # Устанавливаем родительский элемент
        math_formula.setParent(self)

        # Добавляем формулу в список формул
        self.formuls.append(math_formula)

        # Проверяем, есть ли символ '#' в имени, и если есть, пропускаем отображение
        if '#' in name:
            return

        # Отображаем формулу
        self.show_element(math_formula, math_data)

    def create_sensor(self, row_config):
        """
        Создает объект сенсора и добавляет его в список сенсоров.

        Args:
            row_config (list[str]): Строка с параметрами для создания сенсора.

        Returns:
            None
        """
        SENSOR_WIDTH = 120
        SENSOR_HEIGHT = 60
        name, channel, color, side_name, unit, reg, fix, pos_x, pos_y, *extra_params = row_config
        sensor_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": SENSOR_WIDTH,
            "height": SENSOR_HEIGHT
        }
        sensor = Sensor(name, int(channel), color, side_name, int(unit), int(reg), float(fix), self)
        self.sensor_list.append(sensor)
        if '#' in name:
            return
        self.show_element(sensor, sensor_data)

    def show_element(self, element, element_data):
        """
        Общая функция для отображения разных элементов.

        Args:
            element: Объект элемента для отображения (например, заслонка, сенсор, и т.д.).
            element_data: Данные элемента, такие как координаты и размер.

        Returns:
            None
        """
        # Логика отображения элемента
        element.setGeometry(element_data["x"], element_data["y"], element_data["width"], element_data["height"])
        element.show()

    def read_file(self, setting_row):
        """
        Чтение и обработка файла конфигурации.

        Args:
            setting_row (str): Путь к файлу конфигурации.

        Returns:
            list: Список сенсоров, созданных на основе данных из файла.
        """
        config['setting_file'] = setting_row
        # Словарь, сопоставляющий ключевые слова с соответствующими функциями
        KEYWORDS_MAP = {
            "zu": self.create_damper,
            "ru": self.create_damper,
            "ruru": self.create_translate,
            "furn": self.create_furnace,
            "math": self.create_math,
            'const': self.create_const
        }

        # Ключевые слова, которые будут пропущены при обработке файла
        SKIP_KEYWORDS = ['##', '=']
        self.extract_text_between_grids(2, 3, 5)
        try:
            self.sensor_list = []  # Список сенсоров
            self.dampers_list = []  # Список заслонок
            self.translate_list = []  # Список перекладок
            self.furnace_list = []  # Список печей
            self.formuls = []  # Список формул
            self.const = []
            self.lamps = []

            for row_config in self.rw_lines('r'):
                if row_config.strip() == "" or any(x in row_config for x in SKIP_KEYWORDS):
                    continue
                # Сохраняем строку как есть
                original_row = row_config.strip()

                # Извлекаем координаты отдельно
                pos_match = re.search(r'\((\d+)\s+(\d+)\)', original_row)
                coords = (int(pos_match[1]), int(pos_match[2])) if pos_match else (0, 0)

                # Убираем координаты из строки, остальное сохраняем (включая скобки в формулах!)
                row_wo_coords = re.sub(r'\(\d+\s+\d+\)', '', original_row).strip()
                row_config = row_wo_coords.split()
                row_config.extend(map(str, coords))  # добавим x и y как два последних аргумента

                keyword = re.match(r'[a-zA-Z]+', row_config[0])
                keyword = keyword.group(0).lower() if keyword else ''
                if keyword == 'lamp':
                    try:
                        name = row_config[1]
                        reg = int(row_config[2])
                        ch = int(row_config[3])
                        x = int(row_config[-2])
                        y = int(row_config[-1])

                        lamp = IndicatorLamp(name, reg, ch, parent=self)
                        lamp.name = name
                        lamp.move(x, y)
                        lamp.show()
                        lamp.raise_()
                        self.lamps.append(lamp)
                    except Exception as e:
                        print(f"[LAMP ERROR] {row_config}: {e}")
                    continue

                try:
                    # row_config[-3] — это позиция 'reg' перед x y координатами
                    if keyword in ['ru', 'dd', 'da']:  # ← только для устройств
                        if len(row_config) >= 3 and row_config[-3].isdigit():
                            reg = int(row_config[-3]) - 1
                            if reg < 0 or reg >= len(config.get("IPS", {})):
                                print(f"[SKIP] Пропуск строки с некорректным reg={reg + 1}: {' '.join(row_config)}")
                                continue

                except Exception as e:
                    print(f"[reg-check error] {row_config}: {e}")
                    continue
                KEYWORDS_MAP[keyword](row_config) if keyword in KEYWORDS_MAP else self.create_sensor(row_config)
            GraphWindow.name_formuls = [i.name for i in self.formuls]
            Timers.name_formuls = [i.name for i in self.formuls]
            self.const_names = [obj.name for obj in self.const]
            return self.sensor_list
        except Exception as error:
            # Обработка и вывод ошибки, если что-то пошло не так
            warning_window(f'{row_config}\n {error} неправильный параметр')

    def print_screen(self):
        """
        Создание и сохранение скриншота текущего состояния окна.

        Returns:
            None
        """
        # Создание директории для сохранения скриншотов, если её не существует
        os.makedirs(os.path.dirname(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/'), exist_ok=True)

        # Сохранение скриншота в формате .jpg с уникальным именем
        self.grab().save(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/' + time.strftime(config['format_time'],
                                                                                              time.localtime()) + ".jpg")

    def reboots(self):
        """
        Перезапуск приложения.

        Закрывает текущее окно (если оно является экземпляром GraphWindow) и запускает
        приложение заново.

        Returns:
            None
        """
        # Проверка, является ли текущее окно экземпляром GraphWindow
        global dlgMain

        for widget in dlgMain.app.topLevelWidgets():
            widget.close()
        # Объявление, что мы используем глобальную переменную
        dlgMain.stop_event = threading.Event()  # Create an event object
        dlgMain.stop_event.set()  # Set the flag to signal stop
        dlgMain.t1.join()  # Wait for the thread to finish
        dlgMain.close()
        os.execl(sys.executable, os.path.abspath(__file__), *sys.argv)

    def get_dlg_main_ourch(self):
        return (self.ourch, self.dampers_list)

    def closeEvent(self, event):
        print("[DEBUG] closeEvent triggered")
        import os
        os._exit(0)

    def run_app(self):
        try:
            self.app = QApplication(sys.argv)
            self.show()
            self.dlg_ourch, self.dlg_dampers_list = self.get_dlg_main_ourch()
            self.t1 = threading.Thread(target=process_data_channel, args=(self.dlg_ourch, self.dlg_dampers_list))
            self.t1.start()
            # s1 = ServerSocket()
            # s1.start()
            graph_window_0 = GraphWindow()
            graph_window_0.show()
            self.algoritms = None
            """
            algoritms = Timers(parent=self)
            screen_resolution = QApplication.desktop().screenGeometry().size()
            screen_height = screen_resolution.height()
            algoritms.setGeometry(400, screen_height - 250, 400, 200)
            algoritms.hide_timer_settings()
            algoritms.show()
            """
            sleep(2)
            [damper._update_shutter_display_color() for damper in self.dlg_dampers_list]
            sys.exit(self.app.exec_())

        except Exception as e:
            print(f'Ошибка при запуске приложения: {e}')
            warning_window(e)


if __name__ == '__main__':
    import sys
    from PyQt5.QtWidgets import QApplication

    dlgMain = MainShem()
    #  sleep(1)
    dlgMain.run_app()

#pyinstaller --onefile --windowed  main9metran.py --copy-metadata nidaqmx
import ast
import asyncio
import fileinput
import io
import itertools
import os
import queue
import random
import re
import struct
import subprocess
import sys
import threading
import time
import warnings
from datetime import datetime
from time import sleep
import OpenOPC
import keyboard
import nidaqmx
import nidaqmx.system
import numpy as np
import pandas as pd
import pyqtgraph as pg
from PyQt5.QtCore import Qt, QDateTime, QTimer, QPoint, QProcess, \
    QRegExp, QFile, QSettings, pyqtSignal, QTime, QEvent, QSize, QRect
from PyQt5.QtGui import QFont, QRegExpValidator, QPixmap, QKeySequence, QPainter, QColor
from PyQt5.QtWidgets import QAbstractSpinBox, QSlider, QDesktopWidget, QTabWidget, \
    QLineEdit, QScrollArea, QInputDialog, QColorDialog, \
    QFileDialog, QApplication, QMessageBox, QMainWindow, \
    QHBoxLayout, QTextEdit, QSizePolicy, QGraphicsOpacityEffect, \
    QPushButton, QCheckBox, QGridLayout, QComboBox, \
    QWidget, QLabel, QDoubleSpinBox, QVBoxLayout, QTimeEdit, QAction, QShortcut, QSpinBox
from nidaqmx.constants import VoltageUnits
from ping3 import ping
from pyModbusTCP.client import ModbusClient
from pymodbus.constants import Endian
from pymodbus.payload import BinaryPayloadDecoder
from pyqtgraph import TextItem
from functools import partial


def measure_time(func):
    """
    Декоратор для измерения времени выполнения функции.
    Параметры:
    - func (function): Функция, время выполнения которой необходимо измерить.
    Возвращает:
    - function: Обернутая функция, которая выводит время выполнения и возвращает результат выполнения исходной функции.
    """

    def wrapper(*args, **kwargs):
        """
        Обертка вокруг исходной функции для измерения времени выполнения.
        Параметры:
        - *args: Позиционные аргументы для исходной функции.
        - **kwargs: Именованные аргументы для исходной функции.
        Возвращает:
        - Результат выполнения исходной функции.
        """
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции {func.__name__}:", execution_time)
        return result

    return wrapper


warnings.simplefilter(action='ignore', category=FutureWarning)


class ServerSocket(threading.Thread):
    """
    Класс для создания асинхронного сервера на основе сокетов в отдельном потоке.
    Сервер слушает входящие соединения и отправляет клиентам данные из атрибута data.
    """
    data = []

    def __init__(self, host='', port=8888):
        """
        Инициализация сервера.

        :param host: IP-адрес для прослушивания. По умолчанию слушает все доступные интерфейсы.
        :param port: Порт для прослушивания. По умолчанию 8888.
        """
        super().__init__()
        self.host = host
        self.port = port

    async def handle_client(self, reader, writer):
        """
        Асинхронная функция для обработки подключенного клиента.

        :param reader: объект для чтения данных от клиента.
        :param writer: объект для отправки данных клиенту.
        """
        writer.get_extra_info('peername')
        message = ';'.join([str(item) for item in ServerSocket.data])
        writer.write(message.encode('utf-8'))
        await writer.drain()
        writer.close()
        await writer.wait_closed()

    async def run_server(self):
        """
        Асинхронная функция для запуска сервера.
        """
        server = await asyncio.start_server(self.handle_client, self.host, self.port)
        async with server:
            await server.serve_forever()

    def run(self):
        """
        Запуск асинхронного сервера в отдельном потоке.
        """
        asyncio.run(self.run_server())


class WarningWindow(QMessageBox):
    """
    Класс для создания окна предупреждения с возможностью завершения программы.
    """
    def __init__(self, sometext='', out=True):
        """
                Инициализация окна предупреждения.

                Параметры:
                - sometext (str): Текст, который будет отображаться в окне предупреждения.
                - out (bool): Если True, программа будет завершена при нажатии на кнопку "Ok". Если False, окно просто закроется.
        """
        super().__init__()

        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        self.setWindowTitle("Error")
        self.setText(str(sometext))
        self.setIcon(QMessageBox.Warning)
        self.setFont(QFont("Arial", 23))
        self.setStandardButtons(QMessageBox.Ok)
        self.button(QMessageBox.Ok).clicked.connect(lambda: os._exit(1) if out else self.close())
        self.show()


def warning_window(sometext, out=True):
    """
       Функция для создания и отображения окна предупреждения.

       Параметры:
       - sometext (str): Текст, который будет отображаться в окне предупреждения.
       - out (bool, опционально): Если True, программа будет завершена при нажатии на кнопку "Ok".
                                 Если False, окно просто закроется. По умолчанию True.

       Пример использования:
       warning_window("Произошла ошибка!", out=False)
       """
    WarningWindow(sometext=sometext, out=out).exec_()


WORK_DIR = ''                           # Рабочая директория, где хранятся или будут сохраняться файлы и данные

class Window(QWidget):
    """
    Окно для выбора схемы из списка доступных схем.
    """
    my_signal = pyqtSignal(str)                                       # Сигнал для передачи выбранной схемы
    qsettings = QSettings('Teplo', 'm7m')                             # Настройки приложения
    program_directory = os.path.dirname(os.path.abspath(sys.argv[0])) # Директория программы

    def __init__(self):
        super().__init__()

        # Установка стиля окна без рамки
        self.setWindowFlags(Qt.FramelessWindowHint)

        # Горизонтальное размещение элементов
        self.horizont = QHBoxLayout(self)
        self.setGeometry(500, 500, 450, 100)

        # Выпадающий список для выбора схемы
        self.combo_box = QComboBox()
        self.combo_box.setGeometry(50, 50, 250, 30)

        # Добавление доступных схем в выпадающий список
        self._populate_combobox_with_schemes(self.program_directory)
        # Установка текущего индекса на основе сохраненного значения
        last_index = Window.qsettings.value('last_index', 0)
        self.combo_box.setCurrentIndex(last_index)

        # Кнопки управления
        self.btn1 = QPushButton('ок')
        self.btn2 = QPushButton('+')
        self.btn3 = QPushButton('вых')
        self._setup_buttons()

        # Чекбокс для активации режима имитации
        self.checkbox_config = QCheckBox()
        self.checkbox_config.stateChanged.connect(self.imitation)
        self.horizont.addWidget(self.checkbox_config)

        # Таймер для автоматического выбора схемы
        self._setup_timer()
        self.setFont(QFont('Arial', 14))
        self.flag = False

    def _populate_combobox_with_schemes(self, program_directory):
        """Заполнение выпадающего списка доступными схемами."""
        for folder_name in os.listdir(program_directory):
            folder_path = os.path.join(program_directory, folder_name)
            if os.path.isdir(folder_path) and folder_name != "__pycache__":
                self.combo_box.addItem(folder_name)

    def _setup_buttons(self):
        """Настройка кнопок и их сигналов."""
        self.horizont.addWidget(self.combo_box, 4)
        self.horizont.addWidget(self.btn1)
        self.horizont.addWidget(self.btn2)
        self.horizont.addWidget(self.btn3)
        self.btn1.clicked.connect(self.return_selected_scheme)
        self.btn2.clicked.connect(self.add_new_scheme)
        self.btn3.clicked.connect(lambda: os._exit(0))

    def _setup_timer(self):
        """Настройка таймера для автоматического выбора схемы."""
        self.timer = QTimer(self)
        self.timer.setSingleShot(True)
        self.timer.setInterval(10000)
        self.timer.timeout.connect(self.return_selected_scheme)
        self.timer.start()
        self.combo_box.currentTextChanged.connect(self.timer.stop)

    def imitation(self):
        """Активация режима имитации при выборе чекбокса."""
        config['imitation'] = self.checkbox_config.isChecked()

    def return_selected_scheme(self):
        """Выбор и возврат текущей схемы."""
        Window.qsettings.setValue('last_index', self.combo_box.currentIndex())
        self.close()
        self.my_signal.emit(self.combo_box.currentText())

    def add_new_scheme(self):
        """Добавление новой схемы."""
        self.timer.stop()

        folder_name = self._get_folder_name()
        if not folder_name:
            return

        new_folder_path = self._create_new_folder(folder_name, self.program_directory)
        if not new_folder_path:
            return

        self._set_image_for_scheme(new_folder_path)
        self._set_settings_for_scheme(new_folder_path)

        self.my_signal.emit(os.path.join(self.program_directory, folder_name))
        self.reformat_combobox(os.path.join(new_folder_path, "setting1.txt"), folder_name)

    def _get_folder_name(self):
        """Получение имени новой схемы от пользователя."""
        folder_name, ok_pressed = QInputDialog.getText(self, 'Название', 'Введите название')
        if ok_pressed and folder_name and self.combo_box.findText(folder_name) == -1:
            self.combo_box.addItem(folder_name)
            self.combo_box.setCurrentIndex(self.combo_box.count() - 1)
            return folder_name
        return None

    def _create_new_folder(self, folder_name, settings_directory):
        """Создание новой папки для схемы."""
        new_folder_path = os.path.join(settings_directory, folder_name)
        if not os.path.exists(new_folder_path):
            os.makedirs(new_folder_path)
            return new_folder_path
        return None

    def _set_image_for_scheme(self, new_folder_path):
        """Выбор и установка изображения для новой схемы."""
        selected_image = QFileDialog.getOpenFileName(self, "Выберите изображение", new_folder_path,
                                                     "Images (*.png *.xpm *.jpg *.bmp)")[0]
        target_file_path = os.path.join(new_folder_path, "BG.png")
        if selected_image:
            QFile.copy(selected_image, target_file_path)
        else:
            open(target_file_path, 'a').close()

    def _set_settings_for_scheme(self, new_folder_path):
        """Выбор и установка файла настроек для новой схемы."""
        selected_txt = QFileDialog.getOpenFileName(self, "Выберите настройки", new_folder_path,
                                                   "Текстовые файлы (*.txt)")[0]
        if selected_txt:
            target_file_path = os.path.join(new_folder_path, os.path.basename(selected_txt))
            QFile.copy(selected_txt, target_file_path)
        else:
            default_file_path = "setting1_default.txt"
            new_file_name = "setting1.txt"
            target_file_path = os.path.join(new_folder_path, new_file_name)
            QFile.copy(default_file_path, target_file_path)
            QFile(target_file_path).rename(os.path.join(new_folder_path, new_file_name))

    def reformat_combobox(self, target_file_path, folder_name):
        """
           Обновление рабочего каталога и настроек IP в конфигурационном файле.

           Аргументы:
               target_file_path (str): Путь к конфигурационному файлу.
               folder_name (str): Название, которое будет присвоено ключу 'IZDELIE' в конфигурационном файле.

           Возвращает:
               list: Список обновленных строк в конфигурационном файле.
           """
        def update_config_ips(lines):
            updated_lines = []
            for line in lines:
                if "IZDELIE" in line:
                    line = f'{"IZDELIE"}= "{folder_name}"\n'
                if 'IPS' in line and "##" not in line:
                    num_ips = QInputDialog.getInt(self, 'Input Dialog', 'Число ip:', 1)[0]
                    ips = 'IPS = {'
                    for _ in range(num_ips):
                        ips += get_ip_config()
                    ips += '}\n'
                    line = ips
                updated_lines.append(line)
            return updated_lines

        def get_ip_config():
            """
              Эта функция создает диалоговое окно для ввода конфигурации IP-адреса и типа соединения.
              Пользователю предоставляется выбор типа соединения (например, 'modbus', 'opc', 'daq', 'elemer') и
              возможность ввести начальное значение IP-адреса. После ввода, функция возвращает
              конфигурацию IP-адреса и типа в формате ключ-значение (в виде строки), готовую для дальнейшего использования.
              """
            self.widget = QWidget()
            self.layout = QVBoxLayout()
            self.widget.setLayout(self.layout)
            self.label = QLabel('Выберите тип:')
            self.layout.addWidget(self.label)
            self.combo_box_net = QComboBox()
            self.combo_box_net.addItems(['modbus', 'opc', 'daq', 'elemer'])
            self.inpt = QInputDialog()
            self.inpt.setTextValue('192.168.')
            self.layout.addWidget(self.combo_box_net)
            self.layout.addWidget(self.inpt)
            self.widget.show()
            if self.inpt.exec_():
                self.widget.close()
                return f'"{self.inpt.textValue()}":"{self.combo_box_net.currentText()}",'


        with open(target_file_path, 'r') as f:
            lines = f.readlines()

        updated_lines = update_config_ips(lines)

        with open(target_file_path, 'w') as f:
            f.writelines(updated_lines)

        items = [self.combo_box.itemText(i) for i in range(self.combo_box.count())]
        sorted_items = sorted(items)
        self.combo_box.clear()
        self.combo_box.addItems(sorted_items)
        self.combo_box.setCurrentText(folder_name)

if __name__ == '__main__':
    app0 = QApplication(sys.argv)
    window = Window()
    def get_dir(dir):
        """Обновление рабочего каталога."""
        global WORK_DIR
        WORK_DIR = dir
    window.my_signal.connect(get_dir)
    window.show()
    app0.exec_()

config_defaults = {
    'imitation': False,                       # Флаг для определения, работает ли программа в режиме имитации (например, тестирование или демонстрация)
    'adjust_index': (lambda x: x - 1),          #корекция инлекса
    'IZDELIE': '',  # Название изделия. По умолчанию пустое значение.
    'IMG': WORK_DIR + '\BG.png',  # Путь к фоновому изображению для приложения.
    'setting': WORK_DIR + "\setting1.txt",  # Путь к файлу настроек приложения.
    'IPS': {},  # Словарь для хранения IP-адресов и их типов.
    'sensor_size': 14,  # Размер шрифта для отображения данных с датчиков.
    'hidename': 0,  # Переменная для управления отображением имени (0 - скрыть, 1 - показать).
    'format_time': "%H_%M_%S__%d-%m-%y",  # Формат отображения времени и даты.
    'PACK': 4, # Переменная для хранения информации о пакете (количесиво отслеживание сенсеров)
    'GRID':'###############################################################################',# Разделительная линия для вывода или логирования
    'COLORS': {
        "Красный": "FF5733",
        "Зелёный": "00ff00",
        "Синий": "50b4bd",
        'Черный': '000000',
        'Голубой': '01fdfc',
        'Тёмносерый': '49423d',
        'Серый': '808080',
        'Светлосерый': 'bbbbbb',
        'Пурпурный': 'e600e6',
        'Жёлтый': 'fde910',
        'Прозрачный': 'transparent'
    },  # Словарь цветов для использования в приложении.
    'daq_prefix':['net','.device01'],
    'SIDE': {'Лево': 'l', 'Право': 'r', 'Верх': 't', 'Низ': 'b'},  # Словарь для определения положения элемента.
    'ORIENTATION': {"Горизантально": 'H', 'Вертикально': 'V'}  # Словарь для определения ориентации элемента.
}

def update_config_from_file(filename, config):
    """
       Обновляет словарь конфигурации на основе содержимого файла.
       :param filename: Путь к файлу конфигурации.
       :param config: Словарь конфигурации, который нужно обновить.
       :return: Обновленный словарь конфигурации.
       """
    with open(filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                config[key.strip()] = ast.literal_eval(value)
    return config

config = update_config_from_file(config_defaults['setting'], config_defaults)
del config_defaults
def check_and_warn_about_connection(config):
    """Проверяет соединение с каждым IP-адресом и выводит предупреждение при потере соединения."""
    def ping_and_warn(ip, retries=3, delay=5):
        """Пытается пинговать IP-адрес заданное количество раз и выводит предупреждение при неудаче."""
        for _ in range(retries):
            if ping(ip):
                return True
            warning_window('wait and try connect again', False)
            time.sleep(delay)
        return False
    if not config['imitation']:
        for ip in config['IPS'].keys():
            if not ping_and_warn(ip):
                warning_window(f"{ip} \n lost connection")
                break

check_and_warn_about_connection(config)


def initialize_data_streams(channels):
    """Создает потоки для различных протоколов в сети для получения данных."""

    queue_names = []

    function_dict = {
        'modbus': partial(fetch_data_from_modbus, device_type='modbus'),
        'elemer': partial(fetch_data_from_modbus, device_type='elemer'),
        'daq': fetch_daq_data,
        'opc': partial(fetch_opc_data),
    }

    # Проход по каждому протоколу в конфигурации.
    for index, (ip_address, protocol_type) in enumerate(config['IPS'].items()):
        queue_name = f'data_{protocol_type}_{index}'
        config[queue_name] = queue.Queue()
        queue_names.append(config[queue_name])

        # Создание клиента для определенных протоколов.
        client = ModbusClient(host=ip_address, port=502, unit_id=1, auto_open=True) if protocol_type in [
            'modbus', 'elemer'] else None

        # Проверка, существует ли функция для данного протокола.
        if function_dict.get(protocol_type):
            if client:
                args = (index, client, channels, config[queue_name])
            elif protocol_type=='daq':
                args = (config[queue_name], protocol_type)
            elif protocol_type=='opc':
                args = (index,ip_address,channels,config[queue_name])
            data_thread = threading.Thread(target=function_dict.get(protocol_type), args=args)
            data_thread.start()
        else:
            warning_window(protocol_type)
    return queue_names


def format_modopc(ip_address):
    """Формирование имени модуля для OPC сервера на основе IP-адреса."""
    ip_part = config['daq_prefix'][0]+''.join([part.zfill(3) for part in ip_address.split('.', 2)[2].split('.')])+config['daq_prefix'][1]
    return ip_part

def fetch_opc_data(protocol_index, server_ip, channels, data_queue):
    """
    Функция для чтения данных с OPC сервера и помещения их в очередь.

    :param protocol_index: Индекс протокола.
    :param server_ip: IP-адрес OPC сервера.
    :param channels: Список каналов для чтения.
    :param data_queue: Очередь для помещения прочитанных данных.
    """

    # Фильтрация датчиков по индексу протокола.
    sensors = [sensor for sensor in channels if sensor.reg == protocol_index]
    # Инициализация OPC клиента.
    opc = OpenOPC.client()
    # Формирование имени модуля для OPC сервера.
    opc_module_name = format_modopc(server_ip)
    # Бесконечный цикл чтения данных с OPC сервера.
    while True:
        try:
            # Чтение данных с датчиков.
            sensor_data = list(read_sensors_ops(sensors, opc_module_name, opc))
        except Exception as e:
            print(f"Error reading from OPC: {e}")
            # В случае ошибки использование резервной копии данных.
            sensor_data = backup_data.copy()
        else:
            # Создание резервной копии данных при успешном чтении.
            backup_data = sensor_data.copy()
        # Помещение прочитанных данных в очередь.
        data_queue.put(sensor_data)



def read_sensors_ops(sensors, opc_device, opc_client):
    """
    Читает значения датчиков с OPC сервера.

    :param sensors: Список датчиков, значения которых необходимо прочитать.
    :param opc_device: Идентификатор устройства на OPC сервере.
    :param opc_client: Клиент для подключения к OPC серверу.
    :return: Генератор, возвращающий значения датчиков.
    """
    # Подключение к OPC серверу
    opc_client.connect('Metran-910.OPC')

    # Чтение данных для каждого датчика
    for sensor in sensors:
        sensor_value = opc_client.properties(f"{opc_device}.AI{sensor.ch + 1:02d}Value", 2)
        yield round(sensor_value, 4)

    # Закрытие соединения с OPC сервером
    opc_client.close()

def fetch_data_from_modbus(protocol_index, modbus_client, channels, data_queue, device_type='modbus'):
    """
    Функция для получения данных с Modbus или Modbus Elemer устройства и помещения их в очередь.

    :param protocol_index: Индекс протокола.
    :param modbus_client: Клиент для связи с Modbus устройством.
    :param channels: Список каналов для чтения.
    :param data_queue: Очередь для помещения прочитанных данных.
    :param device_type: Тип устройства ('modbus' или 'elemer').
    """
    try:
        relevant_sensors = [sensor for sensor in channels if sensor.reg == protocol_index]
        backup_data = []

        while True:
            try:
                modbus_data = list(fetch_sensor_data(relevant_sensors, modbus_client, device_type))
                backup_data = modbus_data.copy()
            except Exception:
                modbus_data = backup_data.copy()

            data_queue.put(modbus_data)
            time.sleep(0.05)
    except Exception:
        warning_window(f'{device_type.capitalize()} connection failed')


def fetch_sensor_data(sensor_list, modbus_client, device_type='modbus'):
    """
    Функция для чтения данных с датчиков через Modbus или Modbus Elemer.

    :param sensor_list: Список датчиков для чтения.
    :param modbus_client: Клиент для связи с Modbus устройством.
    :param device_type: Тип устройства ('modbus' или 'elemer').
    """
    for sensor in sensor_list:
        if device_type == 'modbus':
            register_address = sensor.ch * 2
        else:  # device_type == 'elemer'
            register_address = 0x4000 + sensor.ch * 4

        response = modbus_client.read_input_registers(register_address, 2 if device_type == 'modbus' else 4)
        decoded_value = BinaryPayloadDecoder.fromRegisters(response, Endian.BIG, wordorder=Endian.LITTLE).decode_32bit_float()
        yield round(decoded_value, 4)


def generate_daq_configuration(ips_config):
    """
    Генерирует конфигурацию DAQ устройства на основе доступных модулей и их типов.

    Параметры:
    - ips_config: словарь с IP-адресами устройств.

    Возвращает:
    - daq_config: словарь с информацией о доступных модулях и их типах.
    """

    # Словарь моделей модулей и их типов
    MODULE_MAPPINGS = {
        '9208': 'ai', '9403': 'do', '9425': 'di',
        '9265': 'ao', '9213': 'tc', '9214': 'tc',
        '9217': 'rtd', '9222': 'vi'
    }

    # Инициализация системы и получение списка доступных устройств
    system = nidaqmx.system.System.local()
    devices_list = system.devices
    daq_config = {}

    # Обработка каждого устройства в списке (проверяет ip)
    for device_identifier in devices_list.device_names:
        try:
            device_ip = devices_list[device_identifier].tcpip_ethernet_ip
        except Exception:
            continue

        # Если IP устройства присутствует в конфигурации
        if device_ip in ips_config:
            current_device = devices_list[device_identifier]
            current_device.reserve_network_device(True)

            # Получение списка модулей для текущего устройства
            modules_info = {module.name: module.product_type for module in current_device.chassis_module_devices}

            for module_name, module_type in modules_info.items():
                module_key = next((key for key, value in MODULE_MAPPINGS.items() if key in module_type), None)
                if module_key:
                    daq_config[f"{module_name}/{module_key}/{MODULE_MAPPINGS[module_key]}"] = ips_config.get(
                        module_name.replace('_', '-'), '')

    return daq_config


# Проверка условия config['imitation] и наличие 'daq' в значениях словаря config['IPS']
if not config['imitation'] and any(value == 'daq' for value in config['IPS'].values()):
    config['daq_configuration'] = generate_daq_configuration(config['IPS'])


def fetch_daq_data(data_queue, channel_type):
    """
    Функция для чтения данных с DAQ устройства и помещения их в очередь.

    :param data_queue: Очередь для помещения прочитанных данных.
    :param channel_type: Тип канала (например, 'daq').
    """

    # Получение индексов DAQ устройств из конфигурации.
    daq_indices = [i for i, value in config['IPS'].values() if value == 'daq']

    # Определение количества каналов в модуле.
    channel_count_per_module = 16 if channel_type == 'daq' else 32

    # Фильтрация модулей, которые имеют диапазон каналов.
    active_modules = {k: v for k, v in config['daq_configuration'].items() if v}
    daq_channel_ranges = {}
    task = nidaqmx.Task()

    for module_index, (module_name, channel_ranges) in enumerate(active_modules.items()):
        module_name_cleaned = re.sub(r"/\d+/", "/", module_name)

        # Фильтрация датчиков по индексу и модулю.
        relevant_sensors = [sensor for sensor in dlgMain.sensor_list if
                            sensor.reg in daq_indices and sensor.ch // channel_count_per_module == module_index]

        for sensor in relevant_sensors:
            adjusted_channel = sensor.ch % channel_count_per_module
            task.ai_channels.add_ai_current_chan(f"{module_name_cleaned}{adjusted_channel}")
            daq_channel_ranges[f'{adjusted_channel + 1}_{module_index}'] = channel_ranges[adjusted_channel + 1]

    # Настройка задачи для чтения данных с DAQ.
    task.timing.cfg_samp_clk_timing(rate=13, sample_mode=nidaqmx.constants.AcquisitionType.CONTINUOUS)
    task.start()

    try:
        while True:
            raw_values = task.read()
            processed_data = [
                round(((value * 1000 - 4) * (channel_range[1] - channel_range[0])) / 16 + channel_range[0], 4)
                for channel_range, value in zip(daq_channel_ranges.values(), raw_values)
            ]
            data_queue.put(processed_data)

    except Exception as e:
        warning_window(f'DAQ failed. Возможно, канала нет в настройках. Ошибка: {e}', False)


def process_data_channel(data_channel):
    """
    Функция обрабатывает данные из каналов стримов. Если канал пуст, функция ожидает, пока он не будет заполнен.
    После получения данных из канала, функция обрабатывает их и помещает в очередь.

    :param data_channel: Канал, из которого будут извлекаться данные.
    """

    data_channel_condition = threading.Condition()
    config['processed_data_queue']= queue.Queue()

    with data_channel_condition:
        # Ожидание данных в канале.
        while data_channel is None:
            sleep(1)
            data_channel_condition.wait()

        # Если не в режиме имитации, обработать данные и получает очереди.get(self, timeout=None)
        if not config['imitation']:
            data_sources = initialize_data_streams(data_channel)
            while True:
                fetched_data = [data_queue.get() for data_queue in data_sources]
                config['processed_data_queue'].put(fetched_data)

def fetch_live_data(max_attempts=5):
    """
    Пытается извлечь данные из очереди. Если очередь пуста, функция будет ждать и пытаться снова.

    :param max_attempts: Максимальное количество попыток чтения из очереди.
    :return: Извлеченные данные или None, если очередь пуста после всех попыток.
    """
    attempts = 0
    while attempts < max_attempts:
        try:
            items = config['processed_data_queue'].get_nowait()
            config['processed_data_queue'].queue.clear()
            return items
        except queue.Empty:
            sleep(3)
            attempts += 1
    return None


class Damper(QWidget):
    sensor_data = []
    all_impuls = {}
    modbus_instances = {}  # Dictionary to store ModbusClient instances by modules
    opc_instances = {}  # Dictionary to store opc instances by modules
    lock = threading.Lock()
    DEFAULT_NAME = 'ЗУ'
    DEFAULT_SIDE = 'G'
    def __init__(self, name=DEFAULT_NAME, side=DEFAULT_SIDE, chr_open=1, chr_close=2, chdv_open=1, chdv_close=2, reg=1, parent=None):
        """Damper Initialization"""
        super().__init__(parent=parent)

        self.valve_widget = None
        self.modbus_lock = threading.Lock()
        self.reg = config['adjust_index'](reg)
        if not 0 <= self.reg < len(config['IPS']):
            raise ValueError("Invalid 'reg' value")
        self.ip = list(config['IPS'].keys())[self.reg]

        handlers = {
            'opc': self.initialize_opc_connection,
            'elemer': lambda: self.initialize_modbus_connection('elemer'),
            'modbus': lambda: self.initialize_modbus_connection('modbus'),
            'daq': self.initialize_daq_channels
        }
        handlers[config['IPS'].get(self.ip)]()

        self.chdv_open = config['adjust_index'](chdv_open)
        self.chdv_close = config['adjust_index'](chdv_close)
        self.chr_open = config['adjust_index'](chr_open)
        self.chr_close = config['adjust_index'](chr_close)

        self.widget_automat = None
        self.name = name
        self.side = side
        self.widget = QWidget(self)
        self.layout = QGridLayout()

        self.setup_ui_elements()

    def setup_ui_elements(self):
        """Setup UI elements for the damper."""
        self.lab = QPushButton(f'{self.name}')
        self.lab.clicked.connect(self.info)
        self.lab.setStyleSheet(
            'font:bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0;text-align: top;')

        self.moveon = False
        self.widget.setLayout(self.layout)
        self.widget.setStyleSheet(
            ".QWidget {border: 1px solid black;border-radius: 25;background-color: rgb(255, 255, 255);}")

        self.setup_buttons()
        self.layout.setVerticalSpacing(0)
        self.layout.setHorizontalSpacing(0)
        self.widget.setFixedSize(120, 60)

        self.layout.addWidget(self.lab, 0, 0, 1, 2)
        self.layout.addWidget(self.red_button, 1, 0, 4, 1)
        self.layout.addWidget(self.green_button, 1, 1, 4, 1)

        if self.side == 'V':
            self.adjust_for_vertical_side()

        self.chkb = QCheckBox()
        self.chkb.stateChanged.connect(self.automatvisibl)
        self.chkb.setStyleSheet("QCheckBox::indicator { width: 10; height: 10;}")
        self.layout.addWidget(self.chkb, 0, 0, 3, 1)

        self.lab.clicked.connect(self.info)
        self.update_shutter_display_color()

    def setup_buttons(self):
        """Setup buttons for the damper."""
        self.red_button = QPushButton()
        self.red_button.pressed.connect(lambda: self.onButtonPressed('turnOnRed'))
        self.red_button.released.connect(lambda: self.onButtonPressed('turnOffRed'))

        self.green_button = QPushButton()
        self.green_button.pressed.connect(lambda: self.onButtonPressed('turnOnGreen'))
        self.green_button.released.connect(lambda: self.onButtonPressed('turnOffGreen'))

        self.update_button_styles(self.red_button, self.green_button, '13px')
        self.red_button.setFixedSize(50, 35)
        self.green_button.setFixedSize(50, 35)
        self.lab.setFixedSize(100, 25)

    def adjust_for_vertical_side(self):
        """Adjust UI elements for vertical side."""
        self.update_button_styles(self.red_button, self.green_button, '0px')
        self.layout.setHorizontalSpacing(1)
        self.widget.setFixedSize(65, 110)
        self.red_button.setFixedSize(25, 50)
        self.green_button.setFixedSize(25, 50)
        self.lab.setFixedSize(25, 95)
        self.layout.addWidget(self.lab, 0, 1, 2, 1)
        self.layout.addWidget(self.red_button, 1, 0, 1, 1)
        self.layout.addWidget(self.green_button, 0, 0, 1, 1)

    def initialize_modbus_connection(self, attribute_name):
        """
        Инициализирует соединение с Modbus и сохраняет клиентское соединение в атрибуте объекта.

        :param attribute_name: Имя атрибута, в котором будет сохранен клиент Modbus.
        """
        try:
            # Создание нового клиента Modbus.
            modbus_client = ModbusClient(host=self.ip, port=502, unit_id=1, auto_open=True)

            # Обновление словаря экземпляров Modbus.
            Damper.modbus_instances.update({self.ip: modbus_client})

            # Установка атрибута объекта с клиентом Modbus.
            setattr(self, attribute_name, Damper.modbus_instances[self.ip])
        except Exception as error:
            # Вывод предупреждения в случае ошибки.
            warning_window(error, False)

    def initialize_opc_connection(self):
        """
        Инициализирует соединение с OPC и сохраняет клиентское соединение в атрибуте объекта.
        """
        try:
            # Создание нового клиента OPC.
            Damper.opc_instances[self.ip] = OpenOPC.client()

            # Преобразование частей IP-адреса для формирования имени модуля.
            third_part, fourth_part = map(lambda ip_part: f'{int(ip_part):03}', self.ip.split('.')[2:])

            # Формирование имени модуля для OPC сервера.
            self.modopc = f'{config["daq_prefix"][0]}{third_part}{fourth_part}{config["daq_prefix"][1]}'

            # Установка атрибута объекта с клиентом OPC.
            self.opc = Damper.opc_instances[self.ip]
        except Exception as error:
            # Вывод предупреждения в случае ошибки.
            warning_window(error, False)

    def initialize_daq_channels(self):
        """
        Инициализирует каналы ввода/вывода для DAQ устройства на основе конфигурации.
        """
        try:
            # Создание словаря, связывающего типы каналов (ввод/вывод) с именами модулей.
            channel_to_module_map = {
                key.split('/')[-1]: key.split('/')[0]
                for key, value in config['daq_configuration'].items()
                if key.endswith(('do', 'di'))
            }

            # Установка атрибутов объекта с именами модулей для каналов ввода/вывода.
            self.daq_output_module = channel_to_module_map.get('do')
            self.daq_input_module = channel_to_module_map.get('di')
        except Exception as error:
            # Вывод предупреждения в случае ошибки.
            warning_window(error, False)

    def update_button_styles(self, open_button, close_button, margin_top):
        """
        Обновляет стили кнопок "Открыть" и "Закрыть".

        :param open_button: Объект кнопки "Открыть".
        :param close_button: Объект кнопки "Закрыть".
        :param margin_top: Значение верхнего отступа для кнопок.
        """

        open_button_style = f"""
                             QPushButton{{
                             background-color: #A61300;
                             border-bottom-left-radius:10px;
                             border-top-right-radius:10px;
                             margin-top: {margin_top};
                             }}
                             QPushButton:pressed {{ background-color: #FF2800 }}
                             """

        close_button_style = f"""
                              QPushButton{{
                              background-color: #007C21;
                              border-top-left-radius:10px;
                              border-bottom-right-radius:10px;
                              margin-top: {margin_top};
                              }}
                              QPushButton:pressed {{ background-color:#64DF85 }}
                              """

        open_button.setStyleSheet(open_button_style)
        close_button.setStyleSheet(close_button_style)

    def automatvisibl(self):
        # Проверяем, установлен ли флажок
        if self.chkb.isChecked():
            try:
                # Попытка показать существующий valve_widget
                self.valve_widget.show()
            except Exception:
                # Если valve_widget не существует, создаем новый экземпляр ValveControlWidget
                self.valve_widget = ValveControlWidget(self, dlgMain, self.side)
                self.valve_widget.show()
        else:
            # Если флажок не установлен, скрываем valve_widget
            self.valve_widget.hide()

    def update_shutter_display_color(self):
        """
        Обновляет цвет отображения заслонки на основе текущего состояния устройства.
        """
        with threading.Lock():
            try:
                shutter_open, shutter_close = self._fetch_device_state()
                determined_color = self._get_shutter_color(shutter_open, shutter_close)
                self._apply_color_to_label(determined_color)
            except Exception:
                # В случае ошибки устанавливаем цвет отображения в желтый
                self._apply_color_to_label('#FFFF00')

    def _fetch_device_state(self):
        """
        Получает текущее состояние устройства на основе его типа.

        :return: Кортеж из двух состояний: открыто и закрыто.
        """
        device_state_fetchers = {
            'daq': self._read_from_daq,
            'opc': self._read_from_opc,
            'modbus': self._read_from_modbus,
            'elemer': self._read_from_elemer
        }
        return device_state_fetchers[config['IPS'].get(self.ip)]()

    def _get_shutter_color(self, shutter_open, shutter_close):
        """
        Определяет цвет заслонки на основе ее состояния.

        :param shutter_open: Состояние открытой заслонки.
        :param shutter_close: Состояние закрытой заслонки.
        :return: Строка, представляющая цвет в формате HEX.
        """
        return '#00FF00' if shutter_open else ('#FF0000' if shutter_close else '#FFFF00')

    def _apply_color_to_label(self, color):
        """
        Применяет заданный цвет к метке заслонки.

        :param color: Строка, представляющая цвет в формате HEX.
        """
        self.lab.setStyleSheet(
            f"""font:bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0;background-color: {color};text-align: center;""")

    def _read_from_daq(self):
        '''Метод, выполняющий чтение данных из устройства сбора данных (DAQ).

        Действия:
        - Создает задачу (Task) для взаимодействия с устройством DAQ.
        - Добавляет каналы для чтения сигналов открытия и закрытия.
        - Считывает значения с каналов и возвращает их.

        Примечание:
        Этот метод использует библиотеку nidaqmx для работы с DAQ и предоставляет данные сигналов открытия и закрытия.
        '''
        with nidaqmx.Task() as task:
            task.di_channels.add_di_chan(f"{self.daq_in}/port0/line{self.chr_open}")
            task.di_channels.add_di_chan(f"{self.daq_in}/port0/line{self.chr_close}")
            chdv = task.read()
        return chdv[0], chdv[1]

    def _read_from_opc(self):
        '''Метод, выполняющий чтение данных из сервера OPC (OLE for Process Control).

        Действия:
        - Устанавливает соединение с сервером OPC.
        - Получает значения сигналов для открытия и закрытия на основе параметров.
        - Возвращает полученные значения.

        Примечание:
        Этот метод используется для взаимодействия с OPC-сервером и получения данных открытия и закрытия.
        '''
        self.opc.connect('Metran-910.OPC')
        chr_open = self.opc.properties(f'{self.modopc}.DI{self.chr_open + 1:02d}Value', 2)
        chr_close = self.opc.properties(f'{self.modopc}.DI{self.chr_close + 1:02d}Value', 2)
        #self.opc.close()
        return chr_open, chr_close

    def _read_from_modbus(self):
        '''Метод, выполняющий чтение данных из устройства, использующего протокол Modbus.

        Действия:
        - Подключается к устройству, используя Modbus.
        - Считывает значения для открытия и закрытия с устройства.
        - Закрывает соединение с устройством, при необходимости.
        - Возвращает считанные значения.

        Примечание:
        Этот метод предназначен для чтения данных из устройства, работающего по протоколу Modbus, и обеспечивает данные сигналов открытия и закрытия.
        '''
        try:
            sleep(0.05)
            chr_open = self.modbus.read_discrete_inputs(int(self.chr_open + 1), 1)[0]
            sleep(0.05)
            chr_close = self.modbus.read_discrete_inputs(int(self.chr_close + 1), 1)[0]
            #sleep(0.05)
            self.modbus.close()
        except Exception:
            chr_open, chr_close = None, None
        return chr_open, chr_close

    def _read_from_elemer(self):
        '''Метод, выполняющий чтение данных из устройства Elemer.

        Действия:
        - Считывает данные открытия и закрытия из устройства Elemer.
        - Декодирует считанные данные в формат с плавающей запятой.
        - Возвращает считанные значения.

        Примечание:
        Этот метод используется для получения данных с устройства Elemer и предоставляет значения открытия и закрытия в формате с плавающей запятой.
        '''
        sleep(0.05)
        chr_open = BinaryPayloadDecoder.fromRegisters(
            self.elemer.read_input_registers(0x4000 + self.chr_open * 4, 4), Endian.BIG).decode_32bit_float()
        sleep(0.05)
        chr_close = BinaryPayloadDecoder.fromRegisters(
            self.elemer.read_input_registers(0x4000 + self.chr_close * 4, 4), Endian.BIG).decode_32bit_float()
        return chr_open, chr_close


    def onButtonPressed(self, action_name_suffix):
        '''Метод, который выполняется при нажатии кнопки или выполнении определенного действия.

        Параметры:
        - self: ссылка на экземпляр класса, в котором определен этот метод.
        - action_name_suffix: строка, содержащая суффикс имени действия или кнопки.

        Действия:
        - Определяет, включено ли устройство (is_on) на основе наличия подстроки 'On' в action_name_suffix.
        - Определяет тип данных (chdv_type), которые должны быть обработаны, на основе наличия подстроки 'Green' в action_name_suffix.
        - Создает новый поток (thread) для выполнения функции `update_damper` с заданными параметрами.
        - Потоку присваивается имя, содержащее имя экземпляра класса и action_name_suffix.
        - Поток запускается.

        Примечание:
        Этот метод предназначен для выполнения определенных действий при взаимодействии с устройством, например, при включении/выключении чего-то, и он использует многозадачность (потоки) для параллельного выполнения задач.
        '''
        is_on = 'On' in action_name_suffix
        chdv_type = self.chdv_open if 'Green' in action_name_suffix else self.chdv_close
        with Damper.lock:
            trz = threading.Thread(target=self.update_damper,
                                   args=[is_on, chdv_type, action_name_suffix],
                                   name=f'{self.name}_{action_name_suffix}')
            trz.start()

    def _daq_event_write(self, values, channel):
        """
           Метод для записи значений в устройство сбора данных (DAQ).

           Параметры:
           - self: ссылка на экземпляр класса, в котором определен этот метод.
           - values: значения, которые должны быть записаны в устройство.
           - channel: номер канала для записи.

           Действия:
           - Создает задачу (Task) для взаимодействия с устройством DAQ.
           - Добавляет канал для записи.
           - Записывает переданные значения.

           Примечание:
           Этот метод использует библиотеку nidaqmx для взаимодействия с устройством DAQ и записи данных.
        """
        with nidaqmx.Task() as task:
             task.do_channels.add_do_chan(f"{self.daq_out}/port0/line{channel}")
             task.write(values)
             if task.is_task_done() is False:
                 task.close()

    def pressing(self, bt, time):
        """
          Метод, который выполняет действия при нажатии на кнопку в пользовательском интерфейсе.

          Параметры:
          - self: ссылка на экземпляр класса, в котором определен этот метод.
          - bt: тип кнопки (Open или Close).
          - time: время задержки.

          Действия:
          - Определяет действия для каждой кнопки (Open или Close) с использованием лямбда-функций и выполняет их в отдельном потоке.

          Примечание:
          Этот метод используется для обработки действий при нажатии кнопок в пользовательском интерфейсе.

          """
        button_actions = {
            'Open': lambda: (self.onButtonPressed('turnOnGreen'), sleep(time), self.onButtonPressed('turnOffGreen')),
            'Close': lambda: (self.onButtonPressed('turnOnRed'), sleep(time), self.onButtonPressed('turnOffRed'))
        }
        # Получаем нужное действие на основе типа кнопки
        action = button_actions.get(bt)
        if not action:
            return
        # Создаем и запускаем новый поток для выполнения действия
        t1 = threading.Thread(target=action, name=f'{self}_{bt}')
        t1.start()

    def update_damper(self, ch_push_value, channel, calling_function_name):
        """
        Метод, обновляющий интерфейс и выполняющий различные действия в зависимости от переданных параметров.

        Параметры:
        - self: ссылка на экземпляр класса, в котором определен этот метод.
        - ch_push_value: значение для управления заслонкой.
        - channel: номер канала управления.
        - calling_function_name: имя вызывающей функции.

        Действия:
        - Обновляет интерфейс (цвет кнопок) и выполняет действия в зависимости от переданных параметров.

        Примечание:
        Этот метод используется для обработки действий, связанных с управлением заслонкой и обновлением интерфейса.

        """
        with threading.Lock():
            color_map = {
                'turnOnGreen': ('8cd9ad', self.green_button),
                'turnOnRed': ('df022a', self.red_button),
                'turnOffGreen': ('007C21', self.green_button),
                'turnOffRed': ('A61300', self.red_button)
            }
            color, button = color_map.get(calling_function_name, (None, None))
            pattern = r"background-color:\s*#([A-Fa-f0-9]{6})"

            if button:
                current_stylesheet = button.styleSheet()
                match = re.search(pattern, current_stylesheet)
                if match:
                    new_stylesheet = current_stylesheet.replace(match.group(1), color)
                    button.setStyleSheet(new_stylesheet)

            self.lab.setStyleSheet(
                'font:bold;border-radius: 10px;border: 1px solid black;'
                f'margin-bottom: 0;background-color: #{color};text-align: center;')
            if config['imitation']:
                return
            hardware_actions = {
                'daq_out': lambda: self._daq_event_write(ch_push_value, channel),
                'opc': lambda: (self._opc_action(ch_push_value, channel), sleep(0.05)),
                'modbus': lambda: (self.modbus.write_single_coil(channel + 2, ch_push_value), sleep(0.05)),
                'elemer': lambda: (self._elemer_action(ch_push_value, channel), sleep(0.05))
            }
            for attr, action in hardware_actions.items():
                if hasattr(self, attr):
                    action()
                    break
            if calling_function_name in ('turnOffGreen', 'turnOffRed'):
                self.update_shutter_display_color()

    def _opc_action(self, ch_push, ch):
        """Метод для выполнения действий с использованием OPC-сервера.

        Параметры:
        - self: ссылка на экземпляр класса, в котором определен этот метод.
        - ch_push: значение для управления устройством.
        - ch: номер канала или устройства.

        Действия:
        - Попытка подключения к серверу OPC с указанными параметрами.
        - Запись значения `ch_push` в соответствующий канал или устройство на сервере OPC.
        - Закрытие соединения с сервером OPC.

        Примечание:
        Этот метод используется для выполнения действий с OPC-сервером, такими как запись значений в каналы или устройства на сервере.

        """
        try:
            self.opc.connect('Metran-910.OPC')
            self.opc.write([f'{self.modopc}.DO{ch+2:02d}Value', ch_push])
            self.opc.close()
        except Exception:
            print('pass')
    def _elemer_action(self, ch_push, ch):
        """Метод для выполнения действий с устройством Elemer.

        Параметры:
        - self: ссылка на экземпляр класса, в котором определен этот метод.
        - ch_push: значение для управления устройством.
        - ch: номер канала или устройства.

        Действия:
        - Определение значения `push` на основе `ch_push` (применяется 16256, если `ch_push` истинно, в противном случае 0).
        - Запись значения `push` в устройство Elemer в соответствии с номером канала `ch`.

        Примечание:
        Этот метод используется для выполнения действий с устройством Elemer, такими как запись значений в указанные каналы на устройстве.

        """
        push = 16256 if ch_push else 0
        self.elemer.write_single_register(0x3000 + ch * 4, push)

    def mousePressEvent(self, evt):
        if self.moveon:
            self.oldPos = evt.globalPos()

    def mouseMoveEvent(self, evt):
        if self.moveon:
            delta = QPoint(evt.globalPos() - self.oldPos)
            self.move(self.x() + delta.x(), self.y() + delta.y())
            self.oldPos = evt.globalPos()
            with fileinput.FileInput(config['setting'], inplace=True,
                                     backup='.bak') as f:
                for line in f:
                    if self.name in line and '~' not in line:
                        replacement_text = (
                                line[:line.rfind(' (')] + f' ({self.x()} {self.y()})\n')
                        print(line.replace(line, replacement_text), end='')
                    else:
                        print(line, end='')

    def info(self):
        '''Метод для отображения информации о текущем экземпляре класса в новом окне.

        Действия:
        - Создает новое окно (`AnotherWindow`).
        - Устанавливает тексты для меток в новом окне, отображая информацию о текущем экземпляре класса (название, номера каналов и другие параметры).
        - Связывает событие изменения значения слайдера (`slider`) с методом `scaletext`.
        - Задает размеры и отображает элементы интерфейса (метки, кнопки) в новом окне.

        Примечание:
        Этот метод используется для отображения информации о текущем экземпляре класса и взаимодействия с элементами пользовательского интерфейса.

        '''
        self.w = InfoWidget()  # ,chr_open=0, chr_close=1, chdv_open=0, chdv_close=1,
        self.w.label1.setText(f'name {self.name}')
        self.w.label2.setText(
            f'chr_op {self.chr_open} ,chr_cl {self.chr_close} ')
        self.w.label3.setText(
            f'chdv_op {str(self.chdv_open)} ,chdv_cl {str(self.chdv_close)}')
        self.w.label4.setText(f'{self.pos()}')
        self.w.slider.valueChanged.connect(self.scaletext)
        self.wi = self.widget.width()
        self.he = self.widget.height()
        self.wi_lab = self.lab.width()
        self.he_lab = self.lab.height()
        self.wi_b1 = self.red_button.width()
        self.he_b1 = self.red_button.height()
        self.wi_b2 = self.green_button.width()
        self.he_b2 = self.green_button.height()
        self.w.show()

    def scaletext(self, value):
        '''Метод для изменения размера текста и элементов интерфейса на основе значения `value`.

        Параметры:
        - self: ссылка на экземпляр класса, в котором определен этот метод.
        - value: значение, используемое для изменения размера элементов.

        Действия:
        - Изменяет размер шрифта текста и размер элементов интерфейса на основе значения `value`.
        - Обновляет размер и форму виджета и других элементов интерфейса.

        Примечание:
        Этот метод используется для динамического изменения размера текста и элементов интерфейса на основе значения слайдера.

        '''
        custom_font = QFont()
        custom_font.setPointSize(7 + value // 2)
        self.setFixedSize(self.width() + value,
                          int(self.height() + value / 15))
        self.lab.setFont(custom_font)
        self.lab.setFixedSize(self.wi_lab + value, self.he_lab + value)
        self.widget.setFixedSize(self.wi + value * 2, self.he + value * 2)
        self.red_button.setFixedSize(
            int(self.wi_b1 + value / 2), int(self.he_b1 + value / 2))
        self.green_button.setFixedSize(
            int(self.wi_b2 + value / 2), int(self.he_b2 + value / 2))

    #   self.layout.setFixedSize(self.layout.height()+value,self.layout.width()+value)
    #        self.w.show()

    def __str__(self):
        return f"Name:{self.name}"

class ValveControlWidget(QWidget):
    all_impuls_mutex = threading.Lock()

    def __init__(self, pa,gradpa,side):
        super().__init__()
        """
        Конструктор класса ValveControlWidget.

        Args:
            dlgMain: Главное окно (предполагается, что это объект главного окна вашего приложения).
        """
        self.side=side
        self.gradpa=gradpa
        self.pa = pa
        self.widget_automat = None
        self.create_automat_widget()
    def create_automat_widget(self):
        """
        Создает виджет для настройки параметров управления заслонкой, если он еще не создан.
        """
        if self.widget_automat is None:
            self.widget_automat=True
            self.setGeometry(self.calculate_widget_position())
            self.setup_ui_elements()

    def calculate_widget_position(self):
        """
        Рассчитывает позицию и размер виджета относительно главного окна.

        Returns:
            Кортеж с координатами и размерами виджета (x, y, width, height).
        """
        x = self.pa.x()
        y = self.pa.y()
        width = self.pa.size().width()
        height = self.pa.size().height()

        if self.side == 'V':
            x = int(x + width / 3 - 150)-13
        else:
            y = int(y + height / 3)+9

        return QRect(x, y, 100, 200)

    def setup_ui_elements(self):
        """
        Настраивает элементы пользовательского интерфейса внутри виджета.
        """
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        self.comboA = QComboBox()
        self.comboA.view().setMinimumWidth(100)
        self.comboA.addItems([f'{i}' for i in self.gradpa.dlg_ourch])

        self.ustA = QDoubleSpinBox()
        self.ustA.setSuffix(' уставка')
        self.ustA.setDecimals(4)
        self.ustA.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)

        # Добавьте остальные элементы пользовательского интерфейса аналогичным образом
        self.dopskA = QDoubleSpinBox()
        self.dopskA.setSuffix(' допуск')
        self.dopskA.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.dopskA.setDecimals(4)
        self.dopskA.setValue(0.1)
        self.dopskA.setMinimum(0.01)

        self.timesleepaft = QDoubleSpinBox()
        self.timesleepaft.setSuffix(' задержка')
        self.timesleepaft.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.timesleepaft.setDecimals(4)
        self.timesleepaft.setMinimum(0.01)
        self.timesleepaft.setValue(2)

        self.limit = QDoubleSpinBox()
        self.limit.setSuffix(' аварийное')
        self.limit.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.limit.setDecimals(4)
        self.limit.setValue(12)

        self.kp = QDoubleSpinBox()
        self.kp.setSuffix('  Kp')
        self.kp.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.kp.setDecimals(4)
        self.kp.setValue(0.08)

        self.ki = QDoubleSpinBox()
        self.ki.setSuffix('  Ki')
        self.ki.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.ki.setDecimals(4)
        self.ki.setValue(0.005)

        self.kd = QDoubleSpinBox()
        self.kd.setSuffix('  Kd')
        self.kd.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.kd.setDecimals(4)
        self.kd.setValue(0.001)

        self.chkbA = QCheckBox()
        self.chkbA.stateChanged.connect(self.automatwork)

        # Добавьте созданные элементы в макет
        self.layout.addWidget(QLabel(f'{self.pa.name}'))
        self.layout.addWidget(self.comboA)
        self.layout.addWidget(self.ustA)
        self.layout.addWidget(self.dopskA)
        self.layout.addWidget(self.timesleepaft)
        self.layout.addWidget(self.limit)
        self.layout.addWidget(self.kp)
        self.layout.addWidget(self.ki)
        self.layout.addWidget(self.kd)
        self.layout.addWidget(self.chkbA)
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setStyleSheet("border: 1px solid black;")


    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_dragging = True
            self.offset = event.pos()

    def mouseMoveEvent(self, event):
        if self.is_dragging:
            new_pos = event.globalPos() - self.offset
            self.move(new_pos)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_dragging = False
            self.offset = None
    def automatwork(self):
        # Если флажок установлен, запускаем автоматический режим
        if self.chkbA.isChecked():
            self.condition = True
            self.tr_auto = threading.Thread(target=self.p_auto)
            self.tr_auto.start()
        # Если флажок не установлен, останавливаем автоматический режим
        else:
            self.condition = False
            if hasattr(self, 'tr_auto') and self.tr_auto.is_alive():
                self.tr_auto.join()

    def p_auto(self):
        """Основная функция для автоматического управления."""
        try:
            self._initialize_auto_params()
            while self.condition:
                self._process_auto_control()
        except Exception as e:
            print(e,'p_auto')
            sleep(1)

    def _update_pid(self, setpoint, feedback):
        '''
          Функция обновления PID-регулятора.

          Эта функция принимает желаемую уставку (setpoint) и текущую обратную связь (feedback) в качестве аргументов и
          рассчитывает управляющий сигнал PID для регулирования системы.

          Параметры:
          setpoint (float): Желаемая уставка.
          feedback (float): Текущая обратная связь.

          Возвращает:
          float: Управляющий сигнал PID.

          '''
        # Рассчитать абсолютное значение ошибки между желаемой уставкой и текущей обратной связью.
        error = abs(setpoint - feedback)
        # Рассчитать компонент дифференциации (derivative) путем вычисления изменения ошибки с момента последнего обновления.
        derivative = error - self.last_error
        # Накапливать компонент интеграции (integral) путем суммирования ошибки с течением времени.
        self.integral += error
        # Вычислить управляющий сигнал PID на основе коэффициентов P, I и D и компонентов ошибки.
        output = (self.kp.value() * error) + (self.ki.value() * self.integral) + (self.kd.value() * derivative)
        # Обновить последнее значение ошибки для использования в следующей итерации.
        self.last_error = error
        # Вернуть вычисленный управляющий сигнал, который может быть применен для управления системой и минимизации ошибки.
        return output

    def _initialize_auto_params(self):
        """Инициализация параметров для автоматического управления."""
        # Определение датчика на основе выбранного значения в комбо-боксе
        self.sensor_for_auto = next(sensor for sensor in self.gradpa.dlg_ourch if sensor.name in self.comboA.currentText())
        self.index = self.comboA.findText(str(self.sensor_for_auto))

        # Определение диапазона значений
        self.diapozon = np.round(
            np.arange(self.ustA.value() - self.dopskA.value(), self.ustA.value() + self.dopskA.value(), 0.001,
                      dtype=float), 3)

        # Инициализация ошибок для PID-регулятора
        self.last_error = 0.0  # Последняя ошибка
        self.integral = 0.0  # Интеграл ошибки

    def _process_auto_control(self):
        """Логика автоматического управления на основе данных с датчика.

           Эта функция реализует логику автоматического управления на основе данных с датчика.

           1. Получение данных с датчика
           2. Рассчитывает управляющий сигнал для регулирования системы с использованием PID-регулятора.
           3. Определяет действия на основе условий, включая включение и выключение устройств и задержку.
           4. Обновляет информацию об импульсе (управляющем сигнале) и действиях внутри класса.
           5. Выполняет соответствующие действия и задержки.
           6. Обновляет информацию об импульсе и выполняет задержку после выполнения действий.

           """
        self.sensor_data = float(f"{Damper.sensor_data[self.sensor_for_auto.reg][self.index]:.3f}")
        self.impuls = round(max(0, self._update_pid(self.ustA.value(), self.sensor_data) or 0),4) or 0

        # Определение действий на основе условий
        on_action, off_action, value = (
                (self.sensor_data > self.limit.value() and ('turnOnRed', 'turnOffRed', self.timesleepaft.value())) or
                ((self.sensor_data < self.diapozon[0] or self.sensor_data < 0) and ('turnOnGreen', 'turnOffGreen', self.impuls)) or
                (self.sensor_data > self.diapozon[-1] and ('turnOnRed', 'turnOffRed', self.impuls))
        )

        self.pa.onButtonPressed(on_action)
        with self.all_impuls_mutex:
            self.pa.__class__.all_impuls.update({self.pa.name: self.impuls})
        sleep(value)
        self.pa.onButtonPressed(off_action)
        with self.all_impuls_mutex:
            self.pa.__class__.all_impuls.update({self.pa.name:0})
        sleep(self.timesleepaft.value())

class InfoWidget(QWidget):
    #Этот класс представляет собой пользовательский виджет, который может быть использован
    # для отображения информации и управления определенными параметрами в пользовательском интерфейсе.
    def __init__(self):
        super().__init__()
        self.pa=self.sender().parent()

        self.setFont(QFont("Arial", 12))

        self.layoutAW = QVBoxLayout()
        self.label1 = QLabel()
        self.label2 = QLabel()
        self.label3 = QLabel()
        self.label4 = QLabel()
        self.slider = QSlider()
        self.slider.setOrientation(Qt.Horizontal)
        self.slider.setRange(-100, 500)

        self.chk = QCheckBox()
        self.chk.stateChanged.connect(self.toggle_other_element)
        self.chklbl = QLabel()
        self.chklbl.setText('Name hide')
        self.layoutAW.addWidget(self.chk)
        self.layoutAW.addWidget(self.chklbl)

        self.layoutAW.addWidget(self.slider)
        self.layoutAW.addWidget(self.label1)
        self.layoutAW.addWidget(self.label2)
        self.layoutAW.addWidget(self.label3)
        self.layoutAW.addWidget(self.label4)

        self.setLayout(self.layoutAW)
        self.chk.stateChanged.connect(self.toggle_other_element)

    def toggle_other_element(self, state):
        try:
            if state == Qt.Checked:
                self.pa.l1.setText(' ')
            else:
                self.pa.l1.setText(f'{self.pa.name}')
        except AttributeError:pass

class Sensor(QWidget):
    '''
    Класс Sensor представляет пользовательский виджет для отображения информации о сенсорах.

    Атрибуты:
    - name: Название сенсора.
    - reg: Регистр (с учетом смещения на 1).
    - ch: Канал (с учетом смещения на 1).
    - amendment: Поправка.
    - bit_depth: Разрядность.
    - l1: QPushButton с названием сенсора.
    - l2: QLabel с символом '♣'.
    - clr: Цвет сенсора.
    - ip: IP-адрес сенсора на основе регистра.
    - side_name: Название стороны, на которой сенсор отображается.
    - moveon: Флаг для перемещения сенсора.

    Методы:
    - bge(clr): Определяет стиль фона QLabel на основе цвета.
    - layoutside(side_name): Настроить макет в зависимости от выбранной стороны.
    - mousePressEvent(evt): Обрабатывает нажатие кнопки мыши для перемещения сенсора.
    - mouseMoveEvent(evt): Обрабатывает перемещение сенсора мышью и сохраняет его новую позицию.
    - poschange(): Изменяет позицию сенсора и перераспределяет элементы в макете.
    - info(): Отображает информацию о сенсоре в отдельном окне.
    - hidename(h): Скрывает или отображает имя сенсора в зависимости от значения h.
    - scaletext(value): Изменяет размер текста и размеры сенсора в зависимости от значения value.
    - __str__(): Возвращает строковое представление объекта Sensor.

    '''
    def __init__(self, name='♥', ch=1, clr='bl', side_name='l', bit_depth=2, reg=1, amendment=0.0, parent=None):
        super(Sensor, self).__init__(parent)
        self.name = name
        self.reg = config['adjust_index'](reg)
        self.ch = config['adjust_index'](ch)
        self.amendment = amendment
        self.bit_depth = bit_depth
        self.l1 = QPushButton(self.name)
        self.l1.setFont(QFont("Arial", 13))
        self.l1.setStyleSheet('border : 5;background: transparent;')
        self.l2 = QLabel('♣')
        self.l2.setAlignment(Qt.AlignCenter)

        self.clr = clr
        self.ip = list(config['IPS'])[self.reg]

        self.side_name = side_name
        self.layoutside(self.side_name)
        self.l2.setFont(QFont('Times', 18, weight=QFont.Bold))
        self.l2.setStyleSheet(self.bge(self.clr))

        self.l1.clicked.connect(self.info)
        self.moveon = False
        self.scaletext(config['sensor_size'])
        self.hidename(config['hidename'])

    def bge(self, clr):
        #выбор цвета
        clr = clr.lstrip('#')
        colors = {
            'si': '192,192,192',
            'wh': '255,255,255',
            'fu': '255,0,255',
            'pu': '238,130,238',
            're': '255,160,137',
            'ma': '128,0,0',
            'ye': '255,255,0',
            'ol': '128,128,0',
            'li': '0,255,0',
            'gr': '50,205,50',
            'aq': '0,255,255',
            'te': '0,128,128',
            'bl': '153,153,255',
            'na': '0,0,128'
        }

        if clr not in colors:
            return f'.QLabel{{background-color: #{clr};margin:1px;border:1px solid rgb(0,0,0);border-radius: 10px;}}'
        else:
            return f'.QLabel{{background-color: rgb({colors[clr]});margin:1px;border:1px solid rgb(0,0,0);border-radius: 10px;}}'

    def layoutside(self, side_name):
        #выбор стороны
        side_layouts = {
            'left': (150, 20, QHBoxLayout, [self.l1, self.l2]),
            'top': (110, 50, QVBoxLayout, [self.l1, self.l2]),
            'right': (150, 20, QHBoxLayout, [self.l2, self.l1]),
            'bottom': (110, 50, QVBoxLayout, [self.l2, self.l1])
        }

        side_name = side_name.lower()

        if side_name in side_layouts:
            width, height, layout_type, widgets = side_layouts[side_name]
            layout = layout_type(self)
            for widget in widgets:
                layout.addWidget(widget)

    def mousePressEvent(self, evt):
        if self.moveon:
            self.oldPos = evt.globalPos()

    def mouseMoveEvent(self, evt):
        if self.moveon:
            delta = evt.globalPos() - self.oldPos
            self.move(self.x() + delta.x(), self.y() + delta.y())
            self.oldPos = evt.globalPos()
            with open(config['setting'], 'r') as f:
                lines = f.readlines()
            with open(config['setting'], 'w') as f:
                for line in lines:
                    if self.name in line:
                        line = f'{line[:line.rfind(" (")]} ({self.x()} {self.y()})\n'
                    f.write(line)

    def info(self):
        self.w = InfoWidget()
        self.w.label1.setText(f'{self}')
        self.w.label4.setText(f'{self.pos()}')
        self.w.slider.valueChanged.connect(self.scaletext)
        self.w.chk.stateChanged.connect(self.hidename)
        self.w.show()

    def hidename(self, h):
        self.l1.hide() if h == 1 else self.l1.show()

    def scaletext(self, value):
        #функция изменения размера Обекта
        self.l2.setFont(QFont('Times', 14 + value, weight=QFont.Bold))
        self.l2.setFixedSize(100 + value * 5, 35 + value)
        self.setFixedSize(150 + value * 5, 70 + value * 2)

    def __str__(self):
        return f"{self.name}  ch {self.ch}  reg {self.reg}"


class Translate(QPushButton):
    """
        Класс Translate представляет собой пользовательский виджет кнопки, который выполняет операции перекладки между элементами.
        """
    def __init__(self, z1, z2, damper_list, z1_sleep, z2_sleep, time_rearrangement, parent=None):
        super(Translate, self).__init__(parent)
        self.rearrangement_cond = True
        self.setGeometry(self.x(), self.y(), 150, 30)
        self.setFont(QFont("Fira Mono Bold", 13))
        self.name=f' {z1}←→{z2}'
        self.setText(f'{self.name}')
        self.setStyleSheet("QPushButton {padding-top:7px;background-color: lightgreen;font: bold;border-radius: 10px;border: 1px solid black;margin-bottom: 0}")
        self.clicked.connect(self.threading_rearrangement)
        self.z1 = next((i for i in damper_list if z1 in i.name), None)
        self.z2 = next((i for i in damper_list if z2 in i.name), None)
        self.z1_sleep = z1_sleep
        self.z2_sleep = z2_sleep
        self.time_rearrangement = time_rearrangement

    def threading_rearrangement(self):
        self.setEnabled(False)  # Отключите кнопку
        threading.Thread(target=self.rearrangement, args=[self.z1, self.z2]).start()

    def rearrangement(self, z1, z2):
        try:
            self.rearrange_elements(z1, z2)
        except Exception:
            warning_window('Check the limit switches')

    def rearrange_elements(self, active_element, inactive_element):
        """
                Управляет перестановкой элементов, изменением стилей и выполнением операций в отдельных потоках.
                """
        open_color,close_color = '#00FF00','#FF0000'
        active_element.lab.setStyleSheet(f'background-color: {open_color if self.rearrangement_cond else close_color}')
        inactive_element.lab.setStyleSheet(f'background-color: {close_color if self.rearrangement_cond else open_color}')
        active_sleep, inactive_sleep = self.z1_sleep, self.z2_sleep
        button1, button2 = ('Green', 'Red') if self.rearrangement_cond else ('Red', 'Green')
        threading.Thread(target=self.execute, args=(active_element, active_sleep, button1)).start()
        threading.Thread(target=self.execute, args=(inactive_element, inactive_sleep, button2)).start()
        self.rearrangement_cond = not self.rearrangement_cond

    def execute(self, element, sleep_time, indicator_name):
        """
                Выполняет операции над элементом, включая установку цветовых индикаторов и временные задержки.
                """
        sleep(float(sleep_time))
        element.onButtonPressed(f'turnOn{indicator_name}')
        sleep(int(self.time_rearrangement))
        element.onButtonPressed(f'turnOff{indicator_name}')
        self.setEnabled(True)  # Включите кнопку снова


class Formula(Sensor, QWidget):
    def __init__(self, name, mathematics, clr, side_name, bit_depth=1):
        super().__init__()
        self.name = name
        self.clr = clr
        self.l2.setStyleSheet(self.bge(self.clr))
        self.mathematics = mathematics
        self.bit_depth = bit_depth
        self.l1.setText(self.name)
        self.layoutside(side_name)

    def __str__(self):
        return f'{self.name},{self.mathematics}'


class Furnace(QSlider):
    """Печи"""
    def __init__(self, name='♥', ch_ao=1, diapason=8.0, reg=1, x=0, y=0, parent=None):
        super(Furnace, self).__init__(parent)

        self.clicked_once = False
        self.last_warning_time_dp = 0.0
        self.last_warning_time_dt = True
        self.second = 1
        self.condition = False
        self.ch_ao = config['adjust_index'](ch_ao)
        self.reg = config['adjust_index'](reg)
        self.diapason = diapason
        self.ip = list(config['IPS'])[self.reg]
        self.client = ModbusClient(
            host=self.ip,
            port=502,
            unit_id=1,
            auto_open=True)

        handlers = {
            'daq': self.handle_daq,
            'opc': self.handle_opc,
            'modbus': lambda: setattr(self, 'modbus', True),
            'elemer':lambda: setattr(self, 'elemer', True)
        }

        handlers[config['IPS'].get(self.ip)]()
        self.name = name
        self.resize(30,int(parent.frameGeometry().height() / 4))
        self.lb = QLabel(self.parent())
        self.lb.setText('0.0')
        self.lb.setFont(QFont('Arial', 11))
        self.lb.move(int(x),int(y)+self.height())
        self.parent().layout().addWidget(self.lb)
        self.setSingleStep(10)
        self.setRange(0, int(self.diapason * 1000))
        self.valueChanged.connect(lambda v: self.lb.setText(str(v / 1000)))


        # Параметры ПИД-регулятора
        self.setpoint = 0.0  # Уставка ПИД-регулятора
        self.last_error = 0.0  # Последняя ошибка
        self.integral = 0.0  # Интеграл ошибки
        self.output = 0.0  # Выходное значение

        self.container_hight = QWidget(self.parent())
        row_layout_0 = QVBoxLayout(self.container_hight)

        container_widget = QWidget()
        row_layout = QHBoxLayout(container_widget)
        self.button = QCheckBox()
        self.button.stateChanged.connect(self.toggle_pid)
        self.pid_enabled = False

        self.setpoint_value = QDoubleSpinBox()
        self.setpoint_value.setMaximum(999)
        self.setpoint_value.setDecimals(0)

        self.sensordt = QComboBox()
        self.sensordt.currentIndexChanged.connect(self.value_changed)
        self.first_mouse_clickdt = True
        self.sensordt.installEventFilter(self)

        self.sensordp = QComboBox()
        self.sensordp.currentIndexChanged.connect(self.value_changed)
        self.first_mouse_clickdp = True
        self.sensordp.installEventFilter(self)

        row_layout.setContentsMargins(0, 0, 0, 0)  # Устанавливаем отступы в 0 пикселей
        row_layout.addWidget(self.button, 1)  # первый виджет, 1/4 пространства
        row_layout.addWidget(self.setpoint_value, 3)  # второй виджет, 3/4 пространства
        row_layout_0.addWidget(container_widget)
        row_layout_0.addWidget(self.sensordt)
        row_layout_0.addWidget(self.sensordp)
        self.kp = QDoubleSpinBox(self.parent())
        self.kp.setSuffix(' kp')
        row_layout_0.addWidget(self.kp)

        self.kp.setValue(20)
        self.kp.setDecimals(4)
        self.kp.setMinimum(-999)
        self.kp.setMaximum(999)

        self.ki = QDoubleSpinBox(self.parent())
        self.ki.setSuffix(' ki')
        self.ki.setMaximum(999)
        self.ki.setMinimum(-999)

        row_layout_0.addWidget(self.ki)

        self.ki.setDecimals(4)
        self.ki.setValue(0.45)

        self.kd = QDoubleSpinBox(self.parent())
        self.kd.setDecimals(4)
        self.kd.setMaximum(999)
        self.kd.setMinimum(-999)
        self.kd.setSuffix(' kd')
        row_layout_0.addWidget(self.kd)
        self.kd.setValue(200)

        self.T = QDoubleSpinBox(self.parent())
        self.T.setSuffix(' Ti')
        self.T.setDecimals(4)
        self.T.setMaximum(999)
        self.T.setValue(3)
        row_layout_0.addWidget(self.T)

        self.Max_mV = QDoubleSpinBox(self.parent())
        self.Max_mV.setDecimals(4)
        self.Max_mV.setMaximum(20)
        self.Max_mV.valueChanged.connect(lambda value: self.setRange(0, int(value * 1000)))
        row_layout_0.addWidget(self.Max_mV)
        self.container_hight.setGeometry(int(x)+self.width(),int(y), 85, 180)
        self.Max_mV.setValue(self.diapason)

    def handle_daq(self):
        try:
            self.daq = [key.split('/')[0] for key, value in config['daq_configuration'].items() if 'ao' in key][0]
        except Exception:
            pass

    def handle_opc(self):
        ip_part = ''.join([part.zfill(3) for part in self.ip.split('.', 2)[2].split('.')])
        self.modopc = config['daq_prefix'][0] + ip_part  + config['daq_prefix'][1]

        self.opc = OpenOPC.client()

    def mouseReleaseEvent(self, event):
        self.tz()

    def __str__(self):
        return f"{self.name}"

    def mousePressEvent(self, event):
        if not self.clicked_once:
            self.container_hight.show()
            self.clicked_once = True
        super().mousePressEvent(event)

    def eventFilter(self, obj, event):
        if obj == self.sensordt and event.type() == QEvent.MouseButtonPress and event.button() == 1:
                if self.first_mouse_clickdt:
                    self.on_activated('DT')
                    self.first_mouse_clickdt = False
                if self.first_mouse_clickdp:
                    self.on_activated('DA')
                    self.first_mouse_clickdp = False
                return True
        return super().eventFilter(obj, event)

    def on_activated(self, type):
        if type == 'DT':
            self.sensordt.addItems([f'{sn.name}_{sn.ch}_{sn.reg}_{i}' for i, sn in enumerate(dlgMain.dlg_ourch) if type in sn.name])
        if type == 'DA':
            self.sensordp.addItems([f'{sn.name}_{sn.ch}_{sn.reg}_{i}' for i, sn in enumerate(dlgMain.dlg_ourch) if type in sn.name])

    def value_changed(self, sender):
        try:
            if sender == 'DT':
                vl = self.sensordt.currentText().split('_')
                datavl = fetch_live_data()[int(vl[2])][int(vl[3])]
                return datavl
            if sender == 'DA':
                vl = self.sensordp.currentText().split('_')
                datavl = fetch_live_data()[int(vl[2])][int(vl[3])]
                return datavl

        except IndexError:
            warning_window('Выберити датчики для отслеживания PID', False)

    def tz(self):
        if config['imitation']: return
        fr = threading.Thread(target=self.signal, args=[self.value()])
        fr.start()
        fr.join()

    def send_daq_signal(self, value):
        with nidaqmx.Task() as task:
            task.ao_channels.add_ao_current_chan(f"{self.daq}/ao{self.ch_ao}",
                                                 name_to_assign_to_channel="Analog_Output_Channel")
            task.write(value / 1000, auto_start=True)

    def send_opc_signal(self, value):
        # sleep(0.05)
        self.opc.connect('Metran-910.OPC')
        self.opc.write([f'{self.modopc}.AO{self.ch_ao + 1:02d}Value', value])
        # self.opc.close()

    def send_modbus_signal(self, value):
        v = struct.unpack('>l', struct.pack('>f', value / 1000))[0]
        x = [(v & 0xffff), (v >> 16)]
        sleep(0.1)
        self.client.write_multiple_registers(self.ch_ao * 2, x)
        # self.c.close()
    def send_elemer_signal(self, value):
        pass
    def signal(self, value):
        protocol_handlers = {
            'daq': lambda: self.send_daq_signal(value),
            'opc': lambda: self.send_opc_signal(value),
            'modbus': lambda:self.send_modbus_signal(value),
            'elemer': lambda: self.send_elemer_signal(value)
        }
        protocol_handlers[config['IPS'].get(self.ip)]()

    def update_pid(self):
        if self.value_changed('DA') < 0.1:
            current_time = time.time()
            if current_time - self.last_warning_time_dp > 60:  # Проверка времени с последнего предупреждения
                warning_window('Низкое давление PID', False)
                self.last_warning_time_dp = current_time  # Обновление времени последнего предупреждения
            self.setValue(0)
            self.toggle_pid()
            return

        frirst = self.value_changed('DT')
        if self.setpoint_value.value() <= int(frirst) and frirst - self.second >= 0:
            self.condition = True
        if frirst > self.setpoint_value.value() + 5 and self.condition:
            if self.last_warning_time_dt:  # Проверка времени с последнего предупреждения
                self.last_warning_time_dt = False
                self.setValue(int(self.value() / 1.5))
            if frirst - self.second <= 0:
                self.condition = False
            self.second = frirst
            return
        self.last_warning_time_dt = True
        error = self.setpoint_value.value() - self.value_changed('DT')  # Разность между уставкой и текущим значением
        self.integral += error  # Интеграл ошибки
        derivative = error - self.last_error  # Дифференциал ошибки
        self.output = self.kp.value() * error + self.ki.value() * self.integral + self.kd.value() * derivative
        self.last_error = error  # Сохранение текущей ошибки
        self.setValue(int(self.output))

    def toggle_pid(self):
        self.pid_enabled = not self.pid_enabled  # Инвертировать текущее состояние ПИД-регулятора
        self.last_error = 0.0  # Последняя ошибка
        self.integral = 0.0  # Интеграл ошибки
        self.output = 0.0  # Выходное значение

        if self.pid_enabled:
            self.timer = QTimer(self)  # Таймер для обновления ПИД-регулятора
            self.timer.timeout.connect(lambda: threading.Thread(target=self.update_pid()))
            self.timer.start(int(self.T.value()) * 1000)  # Интервал обновления ПИД-регулятора (в миллисекундах)
        else:
            self.setValue(0)
            self.timer.stop()


class SquareWidget(QWidget):
    posChanged = pyqtSignal(tuple)

    def __init__(self, pa, index=0, fill=False, w=400, h=100, check=False, x=120, y=120):
        super().__init__(parent=pa)
        self.square_width = w  # начальная ширина квадрата
        self.square_height = h  # начальная высота квадрата
        self.setFocusPolicy(Qt.StrongFocus)  # устанавливаем фокус на виджет
        self.dragging = False
        self.offset = QPoint()
        self.check = check
        self.index = index
        self.label = QLabel(self)
        self.label.setText(f'{self.pos().x(), self.pos().y()},{self.index + 1}')
        self.label.resize(100, 20)  # Устанавливаем размер метки (ширина, высота)
        self.label.move(150, 25)
        self.label.hide()
        self.fill = fill
        self.x = x
        self.y = y
        self.setGeometry(self.x, self.y, 220, 50)
        self.move(50, self.parent().size().height() - 300)
        self.labl_vision = False
        self.color = 'yeallow'

    def labl_vision_def(self):
        self.label.show() if self.labl_vision else self.label.hide()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and self.check:
            self.dragging = True
            self.offset = event.pos()

    def mouseDoubleClickEvent(self, event):
        if self.check:
            self.fill = not self.fill

    def mouseMoveEvent(self, event):
        if self.dragging and self.check:
            self.move(self.pos() + event.pos() - self.offset)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.check:
            self.dragging = False

            if self.check:
                self.label.setText(f'{self.pos().x(), self.pos().y()},{self.index + 1}')
                self.label.show()
                pos_tuple = (self.pos().x(), self.pos().y())
                self.posChanged.emit(pos_tuple)  # Вызываем сигнал с передачей значения pos_tuple

    def keyPressEvent(self, event):
            if not self.check:
                return
            if event.key() == Qt.Key_Left:
                self.square_width = max(self.square_width - 10, 1)
            elif event.key() == Qt.Key_Right:
                self.square_width += 10
            elif event.key() == Qt.Key_Up:
                self.square_height += 10
            elif event.key() == Qt.Key_Down:
                self.square_height = max(self.square_height - 10, 1)
            else:
                return
            self.updateGeometry()

    def updateGeometry(self):
        parent_rect = self.parent().rect()
        new_width = min(self.square_width, parent_rect.width())
        new_height = min(self.square_height, parent_rect.height())
        self.setGeometry(
            (parent_rect.width() - new_width) // 2,
            (parent_rect.height() - new_height) // 2,
            new_width,
            new_height,
        )

    def set_color(self, color):
        self.color = color

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)  # сглаживание
        pen = painter.pen()

        if not self.fill:
            painter.setBrush(Qt.NoBrush)  # прозрачная заливка
        else:
            painter.setBrush(Qt.black)
        if self.color == 'green':
            pen.setColor(QColor(0, 161, 31))
            pen.setWidth(10)  # увеличить толщину рамки на 5
        elif self.color == 'red':
            pen.setColor(Qt.red)
            pen.setWidth(10)  # увеличить толщину рамки на 5
        else:
            pen.setColor(QColor(244, 169, 0))
            pen.setWidth(10)  # увеличить толщину рамки на 2
            pen.setStyle(Qt.DashLine)  # добавить пунктирный стиль

        painter.setPen(pen)
        x = 0
        y = 0
        width = self.width()
        height = self.height()
        painter.drawRect(x, y, width, height)


class Set_point(QWidget):
    sensor_data = None
    name_formuls = []
    formuls = []

    def __init__(self, pa, index):
        super().__init__(parent=pa)
        self.setWindowTitle("Sensor Configuration")
        self.setFont(QFont('Arial', 14))
        self.index = index
        layout = QGridLayout(self)
        layout.setVerticalSpacing(1)  # Устанавливаем отступ между рядами равным 5 пикселей
        self.sensorlist = pa.sensor_list
        self.formulslist = pa.formuls
        self.description_input = QLineEdit()
        self.description_input.setPlaceholderText("Описание")
        self.description_input.setMinimumSize(85, 17)
        layout.addWidget(self.description_input, 0, 0, 1, 2)  # row 0, column 0

        self.sensor_input = QComboBox()
        self.sensor_input.addItems([i.name for i in self.sensorlist])
        self.sensor_input.addItems([i.name for i in self.formulslist])
        self.sensor_input.setPlaceholderText("Датчик")
        layout.addWidget(self.sensor_input, 0, 2)  # row 0, column 1

        self.setpoint_input = QDoubleSpinBox()
        self.setpoint_input.setSingleStep(0.1)
        self.setpoint_input.setMaximum(999)

        self.setpoint_input.setSuffix("Уст")
        layout.addWidget(self.setpoint_input, 0, 3)  # row 0, column 3, span 1 row and 2 columns

        self.tolerance_input = QDoubleSpinBox()
        self.tolerance_input.setSingleStep(0.1)  # Установить шаг равным 0.1

        self.tolerance_input.setSuffix("Доп")
        layout.addWidget(self.tolerance_input, 0, 4)  # row 0, column 4

        self.checkbox = QCheckBox()
        layout.addWidget(self.checkbox, 0, 5)  # row 0, column 5
        self.square_widget = SquareWidget(pa=pa, index=self.index)
        self.square_widget.show()
        self.square_widget.mouseDoubleClickEvent = self.square_widget_double_click
        self.setLayout(layout)
        self.checkbox.stateChanged.connect(self.checkbox_state_changed)
        self.move(10, self.parent().size().height() - 300)
        self.load_settings()  # Load the saved settings
        self.data_condition_changed()
        self.hide()

    def square_widget_double_click(self, event):
        self.hide() if self.isVisible() else self.show()

    def load_settings(self):
        try:
            settings = QSettings("MyApp", f"SensorSettings_{self.index}")  # Use a unique identifier for each instance
            description = settings.value("description")
            sensor = settings.value("sensor")
            setpoint = settings.value("setpoint")
            tolerance = settings.value("tolerance")
            position = settings.value("square_widget_position", self.square_widget.pos())
            size = settings.value("size")  # Get the size as a QSize object

            self.description_input.setText(description)
            self.sensor_input.setCurrentText(sensor)
            self.setpoint_input.setValue(float(setpoint))
            self.tolerance_input.setValue(float(tolerance))
            self.move(position)
            self.square_widget.move(position)  # Move the square widget to the loaded position
            if size is not None:
                width, height = size.width(), size.height()
            else:
                default_size = QSize(220, 50)  # Set default size
                width, height = default_size.width(), default_size.height()
            self.square_widget.resize(width, height)
        except:
            pass

    def save_settings(self):
        settings = QSettings("MyApp", f"SensorSettings_{self.index}")  # Use a unique identifier for each instance
        description = self.description_input.text()
        sensor = self.sensor_input.currentText()
        setpoint = self.setpoint_input.value()
        tolerance = self.tolerance_input.value()
        position = self.square_widget.pos()
        size = self.square_widget.size()

        settings.setValue("square_widget_position", position)
        settings.setValue("description", description)
        settings.setValue("sensor", sensor)
        settings.setValue("setpoint", setpoint)
        settings.setValue("tolerance", tolerance)
        settings.setValue("size", size)

    def checkbox_state_changed(self, state):
        setattr(self.square_widget, 'check', state)
        setattr(self.square_widget, 'labl_vision', state)
        self.square_widget.labl_vision_def()
        self.save_settings()

    def data_condition_changed(self):
        def check_condition():
            while True:
                sens_dict = {sn.name: sn for sn in self.sensorlist}
                formula_dict = {fr.name: fr for fr in self.formulslist}
                try:
                    sens = sens_dict.get(self.sensor_input.currentText())
                    if sens == None:
                        sens = formula_dict.get(self.sensor_input.currentText())
                        index = self.formulslist.index(sens)
                        sens_data = Set_point.formuls[index]
                    else:
                        index = self.sensorlist.index(sens)
                        sens_data = Set_point.sensor_data[sens.reg][index]
                    setpoint_input = self.setpoint_input.value()
                    tolerance_input = self.tolerance_input.value()
                    if setpoint_input - tolerance_input <= sens_data <= setpoint_input + tolerance_input:
                        self.square_widget.set_color('green')
                    elif setpoint_input + tolerance_input < sens_data:
                        self.square_widget.set_color('red')
                    else:
                        self.square_widget.set_color('yellow')
                except:
                    self.square_widget.set_color(False)
                self.square_widget.update()
                time.sleep(1)  # Пауза в одну секунду

        # Создание и запуск потока
        thread = threading.Thread(target=check_condition)
        thread.start()


class Timers(QWidget):
    sensor_data = None
    name_formuls = []
    formuls = []

    def __init__(self, start_hour=0, start_minute=0, start_second=0,start_msecond=0, parent=None):
        super().__init__(parent=parent)

        self.end = QLabel()
        self.start = QLabel()
        self.setFont(QFont('Arial', 18))
        self.last = False
        self.condition = True
        settings = QSettings('Teplo', 'm7m')
        self.cond = False
        layh = QHBoxLayout()
        self.timers = QComboBox()
        layh.addWidget(self.timers)
        self.timers_settings_build(settings)
        self.timer_numbers = QLineEdit()

        self.input_number_cycles = QSpinBox()
        self.input_number_cycles.setFont(QFont('Arial', 14))
        self.input_number_cycles.setMaximum(1000000)
        self.input_number_cycles.setSuffix('  число циклов')
        layh.addWidget(self.input_number_cycles)

        self.add_timer = QPushButton("Добавить таймер")
        self.exp_timer = QPushButton("Экспорт таймеров")
        self.add_timer.clicked.connect(lambda: self.add_timer_combobox(settings))
        self.exp_timer.clicked.connect(lambda: self.export_registry_directory(r'HKEY_CURRENT_USER\SOFTWARE\Teplo\m7m',
                                                                              fr'{config["IZDELIE"]}\{config["IZDELIE"]}.reg'))

        self.delete_timer = QPushButton("Удалить таймер")
        self.delete_timer.clicked.connect(lambda: self.del_timer_combobox(settings))
        self.action_timers = QComboBox()
        max_width = max(self.action_timers.view().sizeHintForColumn(0), self.action_timers.width())
        self.action_timers.setMinimumWidth(max_width)

        self.start_time = QLabel()
        self.end_time = QLabel()
        self.timers_cb_b = QPushButton("Добавить событие", self)
        self.htimebox = QHBoxLayout()
        self.time_input = QTimeEdit()
        self.time_input.setFont(QFont('Arial', 15))
        self.time_input.setDisplayFormat("HH:mm:ss.zzz")
        self.time_input.setTime(QTime(start_hour, start_minute, start_second, start_msecond))
        self.trlist = dlgMain.translate_list
        self.dmplist = dlgMain.dampers_list
        self.furanceslist = dlgMain.furnace_list
        self.sensorlist = dlgMain.sensor_list
        self.math = Timers.name_formuls
        self.layoutH = QHBoxLayout()

        self.action_cb_list = QComboBox()
        self.action_cb_list.addItem('ожидание')
        self.action_cb_list.addItems([tr.name for tr in self.trlist])
        self.action_cb_list.addItems([dmp.name for dmp in self.dmplist])
        self.action_cb_list.addItems([str(fur) for fur in self.furanceslist])
        self.action_cb_list.addItems([sen.name for sen in self.sensorlist])
        self.action_cb_list.addItems([m for m in self.math])

        self.action_cb_list.currentIndexChanged.connect(self.reset_values)

        self.inptust = QDoubleSpinBox()
        self.inptust.setSuffix('  уст')
        self.inptust.setFont(QFont('Arial', 15))

        self.inptdop = QDoubleSpinBox()
        self.inptdop.setSuffix('  доп')

        self.inptdop.setFont(QFont('Arial', 15))

        self.inptdop.setMaximum(999)
        self.inptust.setMaximum(999)
        self.inptdop.setDecimals(4)
        self.inptust.setDecimals(4)
        self.name_sen = QLineEdit()
        self.name_sen.setPlaceholderText('инпут')
        self.info_input = QLineEdit()
        self.info_input.setPlaceholderText('коментарий')
        self.question_button = QPushButton()
        self.question_button.setText('?')
        self.question_button.setFont(QFont('Arial', 12))
        self.question_button.setToolTip(
            "Поле 'задержка' работает совсеми событиями\nДля 'объекта' 'ожидания' указать продолжительность в поле 'задержки'\nДля отслеживания датчика выбрать 'объект' датчик(DA1)указать уставку и допуск ,а также создать событие 'ожидание' перед событием датчика\nДля работы автомата заслонки выбрать 'объект' заслонку(RU1) указать уставку,допуск и датчик отслеживания ввести в поле инпут: DA1\nДля работы автомата печи выбрать 'объект' печь(F1) неоходима указать уставку и датчики отслеживания ввести в поле инпут: DT1-DA1\nДля подачи сигнала на открытия либо закрытия выбрать 'объект' заслонку(RU1) в поле уставки указать продолжительность в секундах (10 уст) ввести в поле инпут : открыть/закрыть\nДля влкючения/выключения автомата заслонки/печи выбрать 'объект' для манипуляции(RU1/F1) ввести в поле инпут: включить/выключить\nДля выполнение события только 1 раз(первом круге) ввести в поле инпут добавить *: DA1* (для ожидания: *) ")
        self.question_button.setToolTipDuration(30000)
        self.question_button.setStyleSheet('QToolTip { font: bold 18px Arial; color:black;}')
        self.lablobj = QLabel('Объект')
        self.layoutH.addWidget(self.lablobj, 1)
        self.layoutH.addWidget(self.action_cb_list, 1)
        self.layoutH.addWidget(self.inptust, 1)
        self.layoutH.addWidget(self.inptdop, 1)
        self.layoutH.addWidget(self.name_sen, 2)
        self.layoutH.addWidget(self.question_button)
        """    self.button = QCheckBox()
        self.button.stateChanged.connect(self.toggle_pid)
        self.pid_enabled = False

        self.setpoint_value = QDoubleSpinBox()"""
        self.timers_cb_del = QPushButton('Удалить событие')

        self.timers_start_timer = QPushButton('Старт_Логики')
        self.timers_start_timer.setStyleSheet("""
            QPushButton {
                background-color: green;
                color: white; 
                font-family: Arial;
                font-size: 18px;
            }
            QPushButton:pressed {
                background-color: darkgreen;
            }
        """)

        self.timers_start_timer.clicked.connect(lambda: self.start_timer(settings))

        self.continuous_checkbox = QCheckBox('первый круг')
        self.continuous_checkbox.setFont(QFont('Arial', 14))
        self.last_cycle = QCheckBox('завершающий цикл')
        self.last_cycle.setFont(QFont('Arial', 14))
        self.last_cycle.stateChanged.connect(
            lambda state: setattr(self, 'last', True if state == Qt.Checked else False))
        self.reform_action_timers(settings)
        self.timer_stop = QPushButton('Стоп')
        self.timer_stop.setStyleSheet("""
            QPushButton {
                background-color: red;
                color: white;  /* Установите цвет текста кнопки */
                font-family: Arial;
                font-size: 18px;
            }
            QPushButton:pressed {
                background-color: darkred;
            }
        """)

        self.alarm_stop = QPushButton('аварийный')
        self.alarm_stop.setStyleSheet("""
                    QPushButton {
                        background-color: red;
                        color: white;  /* Установите цвет текста кнопки */
                        font-family: Arial;
                        font-size: 18px;
                    }
                    QPushButton:pressed {
                        background-color: darkred;
                    }
                """)
        self.alarm_stop.clicked.connect(self.alarm_stop_def)
        self.lb_cycle = QLabel('Циклов: 0')
        self.timers.currentIndexChanged.connect(
            lambda: self.lb_cycle.setText(settings.value(f'cycle_{self.timers.currentText()}')))

        vbox = QVBoxLayout(self)
        vbox.addLayout(layh)
        hbox0 = QHBoxLayout()
        hbox0.addWidget(self.add_timer)
        hbox0.addWidget(self.exp_timer)
        hbox0.addWidget(self.delete_timer)
        vbox.addLayout(hbox0)
        self.htimebox.addWidget(self.time_input)
        self.htimebox.addWidget(QLabel('    Задержка'))
        vbox.addLayout(self.htimebox)
        vbox.addLayout(self.layoutH)
        vbox.addWidget(self.info_input)
        hbox1 = QHBoxLayout()
        hbox1.addWidget(self.timers_cb_b)
        hbox1.addWidget(self.timers_cb_del)
        vbox.addLayout(hbox1)

        hbox2 = QHBoxLayout()
        hbox2.addWidget(self.continuous_checkbox)
        hbox2.addWidget(self.last_cycle)

        vbox.addWidget(self.action_timers)
        vbox.addLayout(hbox2)

        self.reset_button = QPushButton('Сброс_циклов')
        self.reset_button.clicked.connect(lambda: self.reset_cycle(settings=settings))

        hbox3 = QHBoxLayout()
        hbox3.addWidget(self.timers_start_timer)
        hbox3.addWidget(self.reset_button)
        hbox3.addWidget(self.timer_stop)
        hbox3.addWidget(self.alarm_stop)
        vbox.addLayout(hbox3)
        self.info = QLabel()
        #  vbox.addWidget(self.info)

        hbox4 = QHBoxLayout()
        hbox4.addWidget(self.start_time)
        hbox4.addWidget(QLabel(' - '))
        hbox4.addWidget(self.end_time)
        hbox4.addWidget(self.lb_cycle, 2)
        vbox.addLayout(hbox4)

        hbox5 = QHBoxLayout()
        hbox5.addWidget(self.start)
        hbox5.addWidget(QLabel(' - '))
        hbox5.addWidget(self.end)
        vbox.addLayout(hbox5)

        self.setLayout(vbox)

        self.timers_cb_del.clicked.connect(lambda: self.del_action(settings=settings))
        self.timers_cb_b.clicked.connect(
            lambda: self.add_action_to_combo_box(settings=settings, count=self.action_timers.count()))
        self.iteration_count = 0
        self.setMouseTracking(True)
        self.dragging = False
        self.offset = None

   #def mousePressEvent(self, event):
   #    if event.button() == Qt.LeftButton:
   #        self.dragging = True
   #        self.offset = event.pos()

   #def mouseMoveEvent(self, event):
   #    if self.dragging:
   #        new_pos = self.mapToParent(event.pos() - self.offset)
   #        self.move(new_pos)

   #def mouseReleaseEvent(self, event):
   #    if event.button() == Qt.LeftButton:
   #        self.dragging = False
   #        self.offset = None

    def export_registry_directory(self, key_path, output_file):
        subprocess.run(['reg', 'export', key_path, output_file, '/y'], check=True)

    def alarm_stop_def(self):
        self.timer_stop.click()
        self.iteration_count = 0
        self.timers.setCurrentIndex(self.timers.count() - 1)
        self.action_timers.setCurrentIndex(0)
        self.timers_start_timer.click()

    def reset_cycle(self, settings):
        cycle = settings.value(f'cycle_{self.timers.currentText()}')
        cycle = '0_' + cycle.split('_')[1]
        self.lb_cycle.setText(cycle)
        settings.setValue(f'cycle_{self.timers.currentText()}', cycle)

    def reset_values(self):
        self.inptust.setValue(0.0)
        self.inptdop.setValue(0.0)
        self.name_sen.setText('')
        self.info_input.setText('')
        self.time_input.setTime(QTime(0, 0, 0))

    def timers_settings_build(self, settings):
        self.timers.clear()
        self.timer_settings = [setting for setting in settings.allKeys() if
                               'timer' in setting.lower() and 'cycle_' not in setting.lower()]
        self.timers.addItems(self.timer_settings)
        self.timers.currentIndexChanged.connect(lambda: self.reform_action_timers(settings))

    #   self.input_number_cycles.setValue()

    def add_timer_combobox(self, settings):
        if self.timers.currentIndex() < self.timers.count() - 1 or len(self.timers.currentText()) > 7:
            name = self.timers.currentText()[:7]
            counter = 0
            while settings.contains(name):
                name = name[:7]
                name = f'{name}_{counter}'
                counter += 1
        else:
            try:
                name = f'timer_' + str(int(self.timers.currentText().split('_')[1]) + 1)
            except IndexError:
                name = 'timer_0'
        self.timers.insertItem(self.timers.currentIndex() + 1, name)
        settings.setValue(name, [])
        self.timers_settings_build(settings)
        if not settings.contains(f'cycle_{name}'):
            cycle = '0_' + str(self.input_number_cycles.value())
            settings.setValue(f'cycle_{name}', cycle)

    def del_timer_combobox(self, settings):
        name = self.timers.currentText()
        [settings.remove(key) for key in settings.allKeys() if name in key]
        self.timers.removeItem(self.timers.currentIndex())
        self.timers_settings_build(settings)

    def reform_action_timers(self, settings):
        self.action_timers.clear()
        action_timers = settings.value(self.timers.currentText())
        if action_timers is not None:
            self.action_timers.addItems(action_timers)

    def add_action_to_combo_box(self, settings, count):
        action_list = []
        if self.info_input.text() != '':
            timer_str = f't{count}_{self.time_input.text()}_{self.action_cb_list.currentText()}_{"" if self.inptust.value() == 0 else self.inptust.value()}_{"" if self.inptdop.value() == 0 else self.inptdop.value()}_{self.name_sen.text()}!{self.info_input.text()}'
        else:
            timer_str = f't{count}_{self.time_input.text()}_{self.action_cb_list.currentText()}_{"" if self.inptust.value() == 0 else self.inptust.value()}_{"" if self.inptdop.value() == 0 else self.inptdop.value()}_{self.name_sen.text()}'
        self.action_timers.insertItem(self.action_timers.currentIndex() + 1, timer_str)
        for index in range(self.action_timers.count()):
            action_list.append(self.action_timers.itemText(index))
        settings.setValue(self.timers.currentText(), action_list)

    def del_action(self, settings):
        action_list = []
        current_index = self.action_timers.currentIndex()
        self.action_timers.removeItem(current_index)
        for index in range(self.action_timers.count()):
            action_list.append(self.action_timers.itemText(index))
        settings.setValue(self.timers.currentText(), action_list)

    def hide_timer_settings(self):
        self.add_timer.hide()
        self.info_input.hide()
        self.exp_timer.hide()
        self.question_button.hide()
        self.lablobj.hide()
        self.delete_timer.hide()
        for i in range(self.htimebox.count()):
            widget = self.htimebox.itemAt(i).widget()
            if widget:
                widget.hide()
        self.action_cb_list.hide()
        #  self.action_timers.hide()
        self.timers_cb_b.hide()
        self.timers_cb_del.hide()
        self.inptust.hide()
        self.inptdop.hide()
        self.name_sen.hide()
        self.input_number_cycles.hide()
        self.continuous_checkbox.hide()
        self.timers.hide()
        self.reset_button.hide()

    def resize_setting_widget(self, width, height):

        setting_widget = self.parent().parent().parent().parent()
        if isinstance(setting_widget, Setting):
            setting_widget.resize(width, height)
            setting_widget.btnreboot.hide()

    def start_timer(self, settings):
        with threading.Lock():
            self.initialize_timer_info()
            cycle = self.get_cycle(settings)
            self.lb_cycle.setText(f'  {cycle}')

            current_time = QDateTime.currentDateTime()
            self.start_time.setText(current_time.toString("hh:mm:ss.z"))

            try:
                tname, ttime, tbutton, tust, tdop, tname_sen = self.action_timers.currentText().split('_')
            except ValueError:
                self.handle_timer_value_error()
                return

            total_seconds = self.calculate_total_seconds(ttime)

            self.end_time.setText(current_time.addMSecs(total_seconds).toString("hh:mm:ss.z"))

            self.setup_timer(tbutton, settings, tust, tdop, tname_sen, total_seconds)

    def initialize_timer_info(self):
        if not hasattr(self, 'first_loop'):
            self.start.setText(QDateTime.currentDateTime().toString("hh:mm:ss"))
            self.first_loop = True
            self.hide_timer_settings()

    def get_cycle(self, settings):
        return settings.value(f'cycle_{self.timers.currentText()}', '0_1')

    def handle_timer_value_error(self):
        self.timer_stop.click()
        self.timers.setCurrentIndex(0)
        self.action_timers.setCurrentIndex(0)

    def calculate_total_seconds(self, ttime):
        hours, minutes, seconds_with_fraction = map(float, ttime.split(':'))
        return int((hours * 3600 + minutes * 60 + seconds_with_fraction) * 1000)

    def setup_timer(self, tbutton, settings, tust, tdop, tname_sen, total_seconds):
        self.timer = QTimer()
        self.timer_stop.clicked.connect(lambda: self.timer_action_stop(settings))
        self.timer.setInterval(total_seconds)
        self.timer.timeout.connect(
            lambda: self.timer_action(tbutton, self.iteration_count, settings, tust, tdop, tname_sen))
        self.timer.start()





    def timer_action_stop(self, settings):
        self.end.setText(QDateTime.currentDateTime().toString("hh:mm:ss"))
        self.last = False
        self.last_cycle.setChecked(False)
        if self.continuous_checkbox.isChecked():
            self.first_loop = True
        self.continuous_checkbox.setChecked(False)
        #       self.resize_setting_widget(600,400)
        if hasattr(self, 'first_run'):
            del self.first_run
        self.timer.stop()
        self.start_time.setText('')
        self.end_time.setText('')
        self.info.setText('')
        try:
            if isinstance(self.parent().parent().parent().parent(), Setting):
                self.add_timer.show()
                self.exp_timer.show()
                self.delete_timer.show()
                for i in range(self.htimebox.count()):
                    widget = self.htimebox.itemAt(i).widget()
                    if widget:
                        widget.hide()
                self.action_cb_list.show()
                self.timers_cb_b.show()
                self.timers_cb_del.show()
                self.inptust.show()
                self.inptdop.show()
                self.name_sen.show()
                self.input_number_cycles.show()
                self.continuous_checkbox.show()
                self.timers.show()
                self.reset_button.show()
        except Exception:
            pass
        self.timers.setCurrentIndex(0)
     #   settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')

    def timer_action(self, button, iteration_count, settings, ust, dop, name_sens):
        with threading.Lock():
            if name_sens != '':
                try:
                    self.info.setText(name_sens.split('!')[1])
                except IndexError:
                    self.info.setText(name_sens)
            self.timer.stop()
            cycle_str = self.lb_cycle.text()
            cycle_parts = cycle_str.split('_')
            if int(cycle_parts[0]) != int(cycle_parts[1]):
                if self.first_loop or '*' not in name_sens:
                    tr_dict = {tr.name: tr for tr in self.trlist}
                    dmp_dict = {dm.name: dm for dm in self.dmplist}
                    furn_dict = {fr.name: fr for fr in self.furanceslist}
                    sens_dict = {sn.name: sn for sn in self.sensorlist}
                    math_dict = dict(zip(self.name_formuls, self.formuls))
                    objects = [tr_dict.get(button), dmp_dict.get(button), furn_dict.get(button), sens_dict.get(button),
                               math_dict.get(button)]
                    result = next((obj for obj in objects if obj is not None), None)
                    ust = float(ust) if ust != '' else None
                    dop = float(dop) if dop != '' else None
                    if result is not None:
                        case = {
                            Formula: lambda: self.process_math_case(result, ust, dop, name_sens),
                            Sensor: lambda: self.process_sens_case(result, ust, dop, name_sens),
                            Damper: lambda: self.process_dmpb_case(result, name_sens, ust, dop),
                            Translate: lambda: self.process_trb_case(result, name_sens),
                            Furnace: lambda: self.process_furn_case(result, name_sens, ust),
                        }
                        if type(result) in case:
                            case[type(result)]()
                self.action_timers.setCurrentIndex((self.action_timers.currentIndex() + 1) % self.action_timers.count())

                if self.cond:
                    self.iteration_count -= 1
                elif iteration_count < len(self.action_timers) - 1:
                    self.iteration_count += 1
                else:
                    cycle_parts[0] = str(int(cycle_parts[0]) + 1)
                    result_str = '_'.join(cycle_parts)
                    self.lb_cycle.setText(result_str)
                    settings.setValue(f'cycle_{self.timers.currentText()}', result_str)
                    self.iteration_count = 0
                    self.first_loop = True if self.continuous_checkbox.isChecked() else False
                    self.continuous_checkbox.setChecked(False)
                    if self.last:
                        self.timers.setCurrentIndex(self.timers.count() - 1)
                        self.lb_cycle.setText('0_1')
            else:
                if self.timers.currentIndex() == 0:
                    settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')
                if self.timers.currentIndex() == self.timers.count() - 1:
                    settings.setValue(f'cycle_{self.timers.currentText()}', '0_1')

                self.timers.setCurrentIndex((self.timers.currentIndex() + 1))
                self.first_loop = True
            self.cond = False
            self.start_timer(settings)

    def process_math_case(self, math, ust, dop, name_sens):
        index = self.formuls.index(math)
        math_data = Timers.formuls[index]
        if math_data < ust - dop or ust + dop < math_data:
            self.action_timers.setCurrentIndex(self.action_timers.currentIndex() - 2)
            self.cond = True

    def process_sens_case(self, sens, ust, dop, name_sens):
        index = self.sensorlist.index(sens)
        sens_data = Timers.sensor_data[sens.reg][index]
        if sens_data < ust - dop or ust + dop < sens_data:
            self.action_timers.setCurrentIndex(self.action_timers.currentIndex() - 2)
            self.cond = True

    def process_dmpb_case(self, dmpb, name_sens, ust, dop):
        name_sens = name_sens.rstrip('*')
        if 'откр' in name_sens.lower():
            dmpb.pressing('Open', ust)
        elif 'закр' in name_sens.lower():
            dmpb.pressing('Close', ust)
        elif 'выкл' in name_sens.lower():
            try:
                dmpb.chkbA.setChecked(False)
            except Exception:
                pass
        elif 'вкл' in name_sens.lower():
            try:
                dmpb.chkbA.setChecked(True)
            except Exception:
                pass
        else:
            ust = 0 if ust is None else ust
            dop = 0 if dop is None else dop
            if not dmpb.chkb.isChecked():
                dmpb.chkb.setChecked(True)
            dmpb.comboA.setCurrentIndex(dmpb.comboA.findText(name_sens, flags=Qt.MatchContains))
            dmpb.ustA.setValue(ust)
            dmpb.dopskA.setValue(dop)
            dmpb.chkbA.setChecked(not dmpb.chkbA.isChecked())

    def process_trb_case(self, trb, name_sens):
        name_sens = name_sens.rstrip('*')

        if 'сброс' in name_sens:
            trb.rearrangement_cond = False
        else:
            trb.click()

    def process_furn_case(self, furn, name_sens, ust):
        name_sens = name_sens.rstrip('*')

        if 'вкл' in name_sens.lower():
            furn.button.setChecked(True)
        elif 'выкл' in name_sens.lower():
            furn.button.setChecked(False)
        else:
            furn.setpoint_value.setValue(ust)
            furn.on_activated('DT')
            furn.on_activated('DA')
            dt, da = name_sens.split('-')
            furn.sensordt.setCurrentIndex(furn.sensordt.findText(dt, flags=Qt.MatchContains))
            furn.sensordp.setCurrentIndex(furn.sensordp.findText(da, flags=Qt.MatchContains))
            furn.button.toggle()


class Setting(QWidget):
    CONFIRM = 'Подтвердить'
    _instance = None
    _initialized = False
    def __new__(cls, *args, **kwargs):

        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        self.cb_daq_mod_type = None
        if not self._initialized:
            super().__init__()
            self._initialized = True
            self.sensor_list = dlgMain.sensor_list
            self.dampers_list = dlgMain.dampers_list

            self.setMinimumSize(10, 10)
            self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
            self.setFont(QFont("Arial", 14))
            self.setWindowTitle('Настройки')
            self.setStyleSheet('''QPushButton {font-size: 14pt;background-color: #A3C1DA; border-radius: 8px;}
                              QPushButton:hover {background-color: #49B69F;}
                              QPushButton:pressed {background-color: #5549B6;}''')
            screen = QDesktopWidget().screenGeometry()
            width = screen.width()
            height = screen.height()
            self.checked_items = []

            self.central_widget = SquareWidget(dlgMain, check=True)
            self.central_widget.setGeometry(555, 555, 250, 50)
            self.central_widget.show()

            def handle_value_change(x, y):
                self.central_widget.move(int(x), int(y))

            window0 = QWidget()
            layout0 = QHBoxLayout(window0)
            timer1 = Timers()
            layout0.addWidget(timer1)

            window = QWidget()
            layout1 = QGridLayout(window)

            self.cb_name = QComboBox(self)
            self.cb_name.setToolTip("Имя")
            self.cb_name.addItems(['DA', 'DD', 'dP', 'DT', 'G', 'своё имя'])
            self.cb_name.currentIndexChanged.connect(self.setname)
            self.cb_namenumber = QComboBox(self)
            self.cb_channel = QComboBox(self)
            self.cb_bit_depth = QComboBox(self)
            for i in range(1, 101):
                self.cb_namenumber.addItem(str(i))
                self.cb_channel.addItem(str(i))
                self.cb_bit_depth.addItem(str(i))
            self.cb_color = QComboBox(self)

            self.cb_color.addItems(config['COLORS'].keys())
            self.cb_color.addItem('Свой цвет')
            self.color_label = QLabel(self)
            self.color_label.setText('Цвет')
            self.color_label.setGeometry(50, 100, 200, 50)
            self.color_label.setAutoFillBackground(True)
            self.color_label.setStyleSheet(f"background-color: #FF5733")
            self.cb_color.currentIndexChanged.connect(
                lambda: self.on_combo_box_change(config['COLORS'], self.cb_color, self.color_label))

            self.cb_name_side = QComboBox(self)
            self.cb_name_side.addItems(config['SIDE'].keys())
            self.cb_bit_depth.setCurrentIndex(2)

            self.cb_reg = QComboBox(self)
            for i in config['IPS']:
                self.cb_reg.addItem(i)

            self.cb_pos_x = QDoubleSpinBox(self)
            self.cb_pos_y = QDoubleSpinBox(self)
            self.cb_pos_x.setFont(QFont('Arial', 12))
            self.cb_pos_y.setFont(QFont('Arial', 12))

            self.cb_pos_x.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y.lineEdit().setAlignment(Qt.AlignCenter)
            self.deepxy(width, height, self.cb_pos_x, self.cb_pos_y)
            self.cb_pos_x.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x.value(), self.cb_pos_y.value()))
            self.cb_pos_y.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x.value(), self.cb_pos_y.value()))
            self.central_widget.posChanged.connect(self.handlePosChanged)

            layout1.addWidget(QLabel('Имя'), 0, 0)
            layouth1_1 = QHBoxLayout()
            layouth1_1.addWidget(self.cb_name)
            layouth1_1.addWidget(self.cb_namenumber)
            layout1.addLayout(layouth1_1, 0, 1)

            layout1.addWidget(QLabel('Канал'), 1, 0)
            layout1.addWidget(self.cb_channel, 1, 1)
            layout1.addWidget(self.color_label)
            layout1.addWidget(self.cb_color)
            layout1.addWidget(QLabel('Расположение имени'))
            layout1.addWidget(self.cb_name_side)
            layout1.addWidget(QLabel('Разрядность'))
            layout1.addWidget(self.cb_bit_depth)
            layout1.addWidget(QLabel('Регистратор'), 5, 0)
            layout1.addWidget(self.cb_reg, 5, 1)
            layout1.addWidget(QLabel('Позиция по X и Y'))
            layouth1_2 = QHBoxLayout()
            layouth1_2.addWidget(self.cb_pos_x)
            layouth1_2.addWidget(self.cb_pos_y)
            layout1.addLayout(layouth1_2, 6, 1)

            confirm1 = QPushButton("Подтвердить")
            layout1.addWidget(confirm1, 7, 0, 2, 0)
            confirm1.clicked.connect(lambda: self.create_item('sensor'))

            window2 = QWidget()
            layout2 = QVBoxLayout()
            window2.setLayout(layout2)

            delete = QPushButton('Удалить')
            delete.clicked.connect(self.deletesensor)
            hide = QPushButton('Скрыть/Отбразить')
            hide.clicked.connect(self.hidewidget)
            layout2_1 = QHBoxLayout()

            layout2_1.addWidget(hide)
            layout2_1.addWidget(delete)
            layout2.addLayout(layout2_1)

            widget_2 = QWidget()
            layout = QVBoxLayout()
            self.scroll_area = QScrollArea()
            self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
            self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.scroll_area.setWidgetResizable(True)
            self.scroll_content = QWidget(self.scroll_area)
            self.scrollLayout = QVBoxLayout(self.scroll_content)

            self.scrollLayout.setContentsMargins(0, 0, 0, 0)
            self.scrollLayout.setSpacing(0)
            self.content_add()
            layout.addWidget(self.scroll_area)
            widget_2.setLayout(layout)
            widget_2.setFont(QFont('Arial', 12))
            layout2.addWidget(widget_2)

            window3 = QWidget()
            layout3 = QVBoxLayout()
            window3.setLayout(layout3)
            self.input3 = QLineEdit()
            self.input3.setText('69.5*sqrt(342.15*DA1*dP1*10000)/(273+DT1)')
            self.input3.setPlaceholderText('Формула')
            self.input3_1 = QLineEdit()
            self.input3_1.setPlaceholderText('имя')
            self.cb_bit_depth_math = QComboBox()
            for i in range(0, 10):
                self.cb_bit_depth_math.addItem(str(i))
            self.cb_bit_depth_math.setCurrentIndex(2)
            self.cb_color_math = QComboBox()
            self.cb_color_math.addItems(config['COLORS'].keys())
            self.cb_color_math.addItem("Cвой цвет")

            self.color_label_math = QLabel(self)
            self.color_label_math.setText('Цвет')
            self.color_label_math.setGeometry(50, 100, 200, 50)
            self.color_label_math.setAutoFillBackground(True)
            self.color_label_math.setStyleSheet(f"background-color: #FF5733")
            self.cb_color_math.currentIndexChanged.connect(
                lambda: self.on_combo_box_change(config['COLORS'], self.cb_color_math, self.color_label_math))

            self.cb_name_side_math = QComboBox()
            self.cb_name_side_math.addItems(config['SIDE'].keys())
            self.cb_pos_x_math = QDoubleSpinBox()
            self.cb_pos_y_math = QDoubleSpinBox()
            self.cb_pos_x_math.setFont(QFont("Arial", 12))
            self.cb_pos_y_math.setFont(QFont("Arial", 12))
            self.cb_pos_x_math.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_math.value(), self.cb_pos_y_math.value()))
            self.cb_pos_y_math.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_math.value(), self.cb_pos_y_math.value()))
            self.cb_pos_x_math.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_math.lineEdit().setAlignment(Qt.AlignCenter)

            self.deepxy(width, height, self.cb_pos_x_math, self.cb_pos_y_math)

            layout3_h1 = QHBoxLayout()
            layout3_h1.addWidget(QLabel('Разрядность'))
            layout3_h1.addWidget(self.cb_bit_depth_math)
            layout3_h2 = QHBoxLayout()
            layout3_h2.addWidget(QLabel('Расположение имени'))
            layout3_h2.addWidget(self.cb_name_side_math)
            layout3_h3 = QHBoxLayout()
            layout3_h3.addWidget(self.color_label_math)
            layout3_h3.addWidget(self.cb_color_math)

            layout3_h4 = QHBoxLayout()
            layout3_h4.addWidget(QLabel('Расположение по X и Y'))
            layout3_h4.addWidget(self.cb_pos_x_math)
            layout3_h4.addWidget(self.cb_pos_y_math)

            layout3.addWidget(self.input3)
            layout3.addWidget(self.input3_1)
            layout3.addLayout(layout3_h1)
            layout3.addLayout(layout3_h2)
            layout3.addLayout(layout3_h3)
            layout3.addLayout(layout3_h4)

            confirm3 = QPushButton("Подтвердить")
            layout3.addWidget(confirm3)
            confirm3.clicked.connect(self.addformula)

            #  window4_0 = QWidget(self)
            #  layout4_0 = QVBoxLayout()
            #  window4_0.setLayout(layout4_0)
            #  self.cb_daq = QComboBox()
            #  system = nidaqmx.system.System.local()
            #  devices = system.devices
            #  self.cb_daq.addItems([f'{daq}/{devices[daq].tcpip_ethernet_ip}' for daq in devices.device_names if 'Mod' not in daq])
            #  for index in range(self.cb_daq.count()):
            #      cb_daq = self.cb_daq.itemText(index).split('/')[1]
            #      if cb_daq in config['IPS']:
            #          self.cb_daq.setCurrentIndex(index)
            #          break
            #
            #  self.cb_daq_mod_type = QComboBox()
            #  self.cd_daq_cur(devices)
            #  self.cb_daq.currentIndexChanged.connect(lambda: self.cd_daq_cur(devices))
            #  self.scroll = QScrollArea()  # Создание объекта QScrollArea
            #  self.scroll.setWidgetResizable(True)  # Установка возможности изменения размера виджета внутри QScrollArea
            #  self.update_scroll_content()  # Вызов функции для первоначального заполнения содержимого
            #  self.cb_daq_mod_type.currentIndexChanged.connect(self.update_scroll_content)  # Подключение сигнала к слоту
            #  device_modules = devices[self.cb_daq_mod_type.currentText().split('/')[0]]
            ##   self.cb_daq_mod_type.clear()
            #
            #  self.input4_0_ch = QSpinBox()
            #  self.input4_0_ch.setMinimum(1)
            #  self.input4_0_ch.setMaximum(
            #      len([channel.name for channel in device_modules.ai_physical_chans]) if hasattr(device_modules,
            #                                                                                     'ai_physical_chans') else 32)
            #  self.cb_daq_mod_range_min = QDoubleSpinBox()
            #  self.cb_daq_mod_range_min.setMaximum(999)
            #  self.cb_daq_mod_range_min.setMinimum(-999)
            #  self.cb_daq_mod_range_min.setDecimals(4)
            #  self.cb_daq_mod_range_max = QDoubleSpinBox()
            #  self.cb_daq_mod_range_max.setMaximum(999)
            #  self.cb_daq_mod_range_max.setMinimum(-999)
            #  self.cb_daq_mod_range_min.setDecimals(4)
            #
            #  layout4_0_h = QHBoxLayout()
            #  layout4_0_h.addWidget(QLabel('ch'))
            #  layout4_0_h.addWidget(self.input4_0_ch)
            #  layout4_0_h.addWidget(QLabel('min'))
            #  layout4_0_h.addWidget(self.cb_daq_mod_range_min)
            #  layout4_0_h.addWidget(QLabel('max'))
            #  layout4_0_h.addWidget(self.cb_daq_mod_range_max)
            #
            #  layout4_0.addWidget(self.cb_daq)
            #  layout4_0.addWidget(self.cb_daq_mod_type)
            #  layout4_0.addLayout(layout4_0_h)
            #  self.btn4_0 = QPushButton('add')
            #  self.btn4_0.clicked.connect(self.get_ch_range)
            #  layout4_0.addWidget(QLabel('ch: min, max'))
            #  layout4_0.addWidget(self.scroll)
            #  layout4_0.addWidget(self.btn4_0)

            window4 = QWidget()
            layout4 = QVBoxLayout()
            window4.setLayout(layout4)
            self.input4 = QLineEdit()
            self.input4.setPlaceholderText('192.168.201.1')
            validator = QRegExpValidator(QRegExp("[0-9\\.]*"))
            self.input4.setValidator(validator)
            self.cb_add_type = QComboBox()
            self.cb_add_type.addItems(['modbus','opc','elemer', 'daq'])

            self.cb_ip = QComboBox()
            self.cb_ip.addItems(config['IPS'])

            btn4sed = QPushButton('Отправить ip')
            btn4sed.clicked.connect(self.send_ip)
            btn4del = QPushButton('удалить ip')
            btn4del.clicked.connect(lambda: self.delip(self.cb_ip.currentText()))

            layout4_h = QHBoxLayout()
            layout4_h.addWidget(QLabel('ip адрес'))
            layout4_h.addWidget(self.input4)
            layout4_h.addWidget(QLabel('тип'))
            layout4_h.addWidget(self.cb_add_type)
            layout4.addLayout(layout4_h)

            layout4.addWidget(btn4sed)
            layout4.addWidget(self.cb_ip)
            layout4.addWidget(btn4del)

            window5 = QWidget()
            layout5 = QGridLayout()
            window5.setLayout(layout5)
            self.cb_name_ru = QComboBox()
            self.cb_name_ru.addItems(['RU', 'ZU'])
            self.cb_orientate = QComboBox()
            self.cb_orientate.addItems(config['ORIENTATION'].keys())
            self.cb_name_runumber = QComboBox()
            self.cb_chr_open = QComboBox()
            self.cb_chr_close = QComboBox()
            self.cb_chdv_open = QComboBox()
            self.cb_chdv_close = QComboBox()
            self.cb_reg_ru = QComboBox()

            self.cb_pos_x_ru = QDoubleSpinBox()
            self.cb_pos_y_ru = QDoubleSpinBox()
            self.cb_pos_x_ru.setFont(QFont('Arial', 12))
            self.cb_pos_y_ru.setFont(QFont('Arial', 12))
            self.cb_pos_x_ru.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_ru.value(), self.cb_pos_y_ru.value()))
            self.cb_pos_y_ru.valueChanged.connect(
                lambda: handle_value_change(self.cb_pos_x_ru.value(), self.cb_pos_y_ru.value()))
            self.cb_pos_x_ru.lineEdit().setAlignment(Qt.AlignCenter)
            self.cb_pos_y_ru.lineEdit().setAlignment(Qt.AlignCenter)

            for i in range(1, 101):
                self.cb_name_runumber.addItem(str(i))
                self.cb_chr_open.addItem(str(i))
                self.cb_chr_close.addItem(str(i))
                self.cb_chdv_open.addItem(str(i))
                self.cb_chdv_close.addItem(str(i))

            self.deepxy(width, height, self.cb_pos_x_ru, self.cb_pos_y_ru)

            self.cb_reg_ru.addItems({k: i + 1 for i, k in enumerate(config['IPS'])})

            self.cb_chr_close.setCurrentIndex(1)
            self.cb_chdv_close.setCurrentIndex(1)

            layout5.addWidget(QLabel("Имя"), 0, 0)
            layout5_1 = QHBoxLayout()
            layout5_1.addWidget(self.cb_name_ru)
            layout5_1.addWidget(self.cb_name_runumber)
            layout5.addLayout(layout5_1, 0, 1)

            self.oritntation = QLabel("Ориетирование")
            layout5.addWidget(self.oritntation, 1, 0)
            layout5.addWidget(self.cb_orientate, 1, 1)

            self.chr_open = (QLabel("Канал откр"))
            layout5.addWidget(self.chr_open, 2, 0)
            layout5.addWidget(self.cb_chr_open)

            self.chr_close = (QLabel("Канал закр"))
            layout5.addWidget(self.chr_close, 3, 0)
            layout5.addWidget(self.cb_chr_close)

            self.chdv_open = (QLabel("Концевик откр"))
            layout5.addWidget(self.chdv_open, 4, 0)
            layout5.addWidget(self.cb_chdv_open)

            self.chdv_close = (QLabel("Концевик закр"))
            layout5.addWidget(self.chdv_close, 5, 0)
            layout5.addWidget(self.cb_chdv_close)

            layout5.addWidget(QLabel("Регистратор"), 6, 0)

            layout5.addWidget(self.cb_reg_ru)

            layout5.addWidget(QLabel("Положение по X и Y"), 7, 0)
            layout5_2 = QHBoxLayout()

            layout5_2.addWidget(self.cb_pos_x_ru)
            layout5_2.addWidget(self.cb_pos_y_ru)
            layout5.addLayout(layout5_2, 7, 1)
            self.cb_name_ru.currentIndexChanged.connect(self.Furn)

            confirm5 = QPushButton(self.CONFIRM)
            confirm5.clicked.connect(lambda: self.create_item('RU'))
            layout5.addWidget(confirm5, 9, 0, 2, 0)

            window7 = QWidget()
            layout7 = QGridLayout()
            window7.setLayout(layout7)
            self.r1 = QComboBox()
            self.r2 = QComboBox()
            self.r1_sleep = QDoubleSpinBox()
            self.r2_sleep = QDoubleSpinBox()
            self.r1_sleep.setFont(QFont('Arial', 16))
            self.r2_sleep.setFont(QFont('Arial', 16))
            self.r1_sleep.setSuffix('   задержка для первой заслонки')
            self.r2_sleep.setSuffix('   задержка для второй заслонки')
            confirm7 = QPushButton(self.CONFIRM)
            self.r1.addItems([i.name for i in self.dampers_list])
            self.r2.addItems([i.name for i in self.dampers_list])
            layout7.addWidget(self.r1)
            layout7.addWidget(self.r1_sleep)
            layout7.addWidget(self.r2)
            layout7.addWidget(self.r2_sleep)

            layout7.addWidget(confirm7)
            confirm7.clicked.connect(lambda: self.create_item('Rer'))

            window8 = QWidget()
            layout8 = QGridLayout()
            window8.setLayout(layout8)
            # Furn F1 1 1.6 1
            self.number = QSpinBox()
            self.number.setSuffix(' Номер')
            self.number.setMinimum(1)
            self.number.setFont(QFont('Arial', 16))

            self.ch_furn = QSpinBox()
            self.ch_furn.setMinimum(1)
            self.ch_furn.setSuffix('    Канал')
            self.ch_furn.setFont(QFont('Arial', 16))

            self.max = QDoubleSpinBox()
            self.max.setSuffix('    Максимальный ток')
            self.max.setFont(QFont('Arial', 16))

            self.reg_furn = QSpinBox()
            self.reg_furn.setMinimum(1)
            self.reg_furn.setSuffix('   Регистратор')
            self.reg_furn.setFont(QFont('Arial', 16))

            confirm8 = QPushButton(self.CONFIRM)
            confirm8.clicked.connect(lambda: self.create_item('Furn'))
            layout8.addWidget(self.number)
            layout8.addWidget(self.ch_furn)
            layout8.addWidget(self.max)
            layout8.addWidget(self.reg_furn)
            layout8.addWidget(confirm8)

            window6 = QWidget()
            button6_1 = QPushButton('Графики')
            button6_1.clicked.connect(GraphWindow.create_new_graph_window)

            layout6 = QVBoxLayout()
            layout6.addWidget(button6_1)
            window6.setLayout(layout6)

            hbox6_3 = QHBoxLayout()
            self.ustbtn = QPushButton('Изменить')
            line_edit = QSpinBox()
            line_edit.setAlignment(Qt.AlignCenter)
            line_edit.setFont(QFont('Arial', 14))
            label6_3 = QLabel("Количество уставок:")
            self.ustbtn.clicked.connect(lambda: self.on_ustbtn_click(str(line_edit.value())))
            hbox6_3.addWidget(label6_3)
            hbox6_3.addWidget(line_edit)
            hbox6_3.addWidget(self.ustbtn)
            layout6.addLayout(hbox6_3)

            self.cb_size = QComboBox()
            self.cb_size.setEditable(True)
            self.cb_size.lineEdit().setAlignment(Qt.AlignCenter)
            for i in range(1, 35):
                self.cb_size.addItem(str(i))
            self.cb_size.setCurrentIndex(8)
            self.cb_size_b = QPushButton('Изменить')
            self.cb_size_b.clicked.connect(lambda: self.setting('SENSOR_SIZE'))

            self.ckhidename_b = QPushButton('Отображение имени')
            self.ckhidename_b.clicked.connect(lambda: self.setting('hidename'))

            hbox6_2 = QHBoxLayout()
            label6_2 = QLabel("Размер сенсеров:")
            hbox6_2.addWidget(label6_2)
            hbox6_2.addWidget(self.cb_size)
            hbox6_2.addWidget(self.cb_size_b)
            layout6.addLayout(hbox6_2)
            layout6.addWidget(self.ckhidename_b)

            layout = QVBoxLayout()
            layout.addWidget(QWidget())

            self.tabs = QTabWidget()
            self.tabs.setFont(QFont('Arial', 14))
            self.tabs.setStyleSheet("QTabWidget::pane { border-top: 2px solid #C2C7CB; }"
                                    "QTabBar::tab { height: 30px;  border-top-left-radius: 10px; border-top-right-radius: 10px;margin-right:15px; }"
                                    "QTabBar::tab:hover {background-color: #49B69F;}"
                                    "QTabBar::tab:selected { background-color: #A3C1DA;color:white ; border-top-left-radius: 10px; border-top-right-radius: 10px;}"
                                    "QLabel {font-size: 14pt;}"
                                    "QComboBox {font-size: 14pt;}"
                                    "QLineEdit {font-size: 14pt;}"
                                    """QPushButton {font-size: 14pt;background-color: #A3C1DA; border-radius: 8px;}
                                       QPushButton:hover {background-color: #49B69F;}
                                       QPushButton:pressed {background-color: #5549B6;}

                                       """)
            self.tabs.addTab(window0, "Таймер")
            self.tabs.addTab(window, "Добавление датчика")
            self.tabs.addTab(window2, "Скрыть/Удаление")
            self.tabs.addTab(window3, "Математика")
            # self.tabs.addTab(window4_0, "DAQ_modules")
            self.tabs.addTab(window4, "Добавление/удаление IP")
            self.tabs.addTab(window5, "Добавление заслоки")
            self.tabs.addTab(window8, "Добавление печи")
            self.tabs.addTab(window7, "Добавление перекладки")
            self.tabs.addTab(window6, "Настройка")
            self.tabs.currentChanged.connect(self.on_tab_changed)
            layout = QVBoxLayout()
            layout.addWidget(self.tabs)
            self.btnreboot = QPushButton('Перезагрузка')
            self.btnreboot.clicked.connect(self.reboots)
            layout.addWidget(self.btnreboot)
            custom_font = QFont()
            custom_font.setWeight(18)

            self.setLayout(layout)

    def on_ustbtn_click(self, new_value):
        try:
            with open(config['setting'], 'r') as file:
                lines = file.readlines()
            with open(config['setting'], 'w') as file:
                for line in lines:
                    if line.startswith("PACK"):
                        file.write('PACK=' + new_value + '\n')
                    else:
                        file.write(line)
        except Exception as e:
            print("Error while updating setting:", e)

    def closeEvent(self, event):
        self.central_widget.hide()
        event.accept()

    def handlePosChanged(self, pos_tuple):
        x, y = pos_tuple
        self.cb_pos_x.setValue(x)
        self.cb_pos_x_ru.setValue(x)
        self.cb_pos_x_math.setValue(x)
        self.cb_pos_y.setValue(y)
        self.cb_pos_y_ru.setValue(y)
        self.cb_pos_y_math.setValue(y)

    def content_add(self):
        while self.scrollLayout.count():
            item = self.scrollLayout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        self.f = self.get_name()
        for line in self.f:
            if line.count('#') >= 2 or line == '\n':
                continue
            checkbox = QCheckBox(line)
            if '#' in line:
                checkbox.setStyleSheet('background-color:  #CCCCCC')
            else:
                checkbox.setStyleSheet('background-color: white')
            self.scrollLayout.addWidget(checkbox)
        self.scroll_area.setWidget(self.scroll_content)

    def update_scroll_content(self):

        scroll_content_channls = QWidget()
        scroll_layout = QVBoxLayout(scroll_content_channls)  # Создание нового вертикального макета
        selected_daq = self.cb_daq_mod_type.currentText().split('/')[0].replace('-',
                                                                                '_')  # Получение выбранного значения из combobox
        if selected_daq in globals():
            daq_dict = globals()[selected_daq]
            for key, value in daq_dict.items():
                label = QLabel(f"{str(key)} : {str(value)}", self)
                scroll_layout.addWidget(label)

        self.scroll.setWidget(scroll_content_channls)

    def get_ch_range(self):
        try:
            infile_name = self.cb_daq_mod_type.currentText().split('/')[0].replace('-', '_')
            ch_num = int(self.input4_0_ch.value())
            min_ch = self.cb_daq_mod_range_min.value()
            max_ch = self.cb_daq_mod_range_max.value()
        except ValueError as e:
            warning_window('Добавлены неправильные аргументы \nпроверьте ch min max', False)
            return
        globals()[infile_name].update({ch_num: (min_ch, max_ch)})
        dict_range = globals()[infile_name]
        self.redact(infile_name, dict_range)
        self.update_scroll_content()

    def redact(self, infile_name, dict_range):
        with open(config['setting'], 'r') as file:
            lines = file.readlines()

        flag = False
        with open(config['setting'], 'w') as f:
            for line in lines:
                if infile_name in line:
                    f.write(f'{infile_name} = {dict_range}\n')
                    flag = True
                else:
                    f.write(line)
            if not flag:
                lines.insert(7, infile_name)

    def cd_daq_cur(self, devices):
        selected_device = self.cb_daq.currentText().split('/')[0]
        device_modules = devices[selected_device]
        self.cb_daq_mod_type.clear()
        name_models = {module.name: module.product_type for module in device_modules.chassis_module_devices}
        self.cb_daq_mod_type.addItems(self.detect_module_type(name_models))
        for index in range(self.cb_daq_mod_type.count()):
            cb_daq = self.cb_daq_mod_type.itemText(index)
            if 'ai' in cb_daq:
                self.cb_daq_mod_type.setCurrentIndex(index)
                break

    def detect_module_type(self, name_models):
        names = []

        MODULELIST = {'9208': 'ai', '9403': 'do', '9425': 'di', '9265': 'ao', '9213': 'tc', '9214': 'tc', '9217': 'rtd',
                      '9222': 'vi'}
        for name, module in name_models.items():
            for mod, value in MODULELIST.items():
                if mod in module:
                    names.append(name + '/' + module + '/' + value)
        return names

    def on_tab_changed(self, current_tab_index):
        tab_widget_name = self.tabs.tabText(current_tab_index)
        if tab_widget_name != "Таймер":
            self.btnreboot.show()
        else:
            self.btnreboot.hide()

    def on_combo_box_change(self, colors, cbox, cblabel):
        if cbox.currentText() in colors:
            cblabel.setStyleSheet(f"background-color: #{colors[cbox.currentText()]}")

        elif cbox.currentText() == 'Свой цвет':
            color = QColorDialog.getColor()
            if color.isValid():
                cblabel.setStyleSheet(f"background-color: {color.name()}")
                cbox.addItem(color.name())
                cbox.setCurrentIndex(cbox.count() - 1)

    def set_sensor_size(self, f):
        value = self.cb_size.currentText()
        f.write(f"SENSOR_SIZE = {value}\n")

    def toggle_hidename(self, line, f):
        value = '1' if '0' in line else '0'
        f.write(f"hidename = {value}\n")

    def setting(self, too):
        with open(config['setting'], 'r') as file:
            lines = file.readlines()

        with open(config['setting'], 'w') as f:
            for line in lines:
                if too == 'SENSOR_SIZE' and 'SENSOR_SIZE' in line:
                    self.set_sensor_size(f)
                elif too == 'hidename' and 'hidename' in line:
                    self.toggle_hidename(line, f)
                else:
                    f.write(line)

    def setname(self):
        if 'своё имя' in self.cb_name.currentText():
            text, okpressed = QInputDialog.getText(self, "Имя", "Имя датчика", QLineEdit.Normal, "")
            if okpressed and text != '':
                self.cb_name.addItem(text)
                self.cb_name.setCurrentIndex(self.cb_name.count() - 1)

    def Furn(self):
        if 'Furn' in self.cb_name_ru.currentText():
            self.cb_orientate.hide()
            self.cb_chr_open.hide()
            self.cb_chr_close.hide()
            self.cb_chdv_open.hide()

            self.oritntation.hide()
            self.chr_close.hide()
            self.chr_open.hide()
            self.chdv_open.hide()

            self.cb_chdv_close.clear()
            self.cb_chdv_close.addItems([str(i) for i in range(1, 100, 2)])
            self.chdv_close.setText('Канал печи')
        else:
            self.cb_orientate.show()
            self.cb_chr_open.show()
            self.cb_chr_close.show()
            self.cb_chdv_open.show()

            self.oritntation.show()
            self.chr_close.show()
            self.chr_open.show()
            self.chdv_open.show()

            self.cb_chdv_close.clear()
            self.cb_chdv_close.addItems([str(i) for i in range(1, 100)])
            self.cb_chdv_close.setCurrentIndex(1)

            self.chdv_close.setText("Концевик закр")

    def deepxy(self, width, height, xpos, ypos):
        xpos.setRange(-width, width)
        xpos.setValue(int(width / 2))
        ypos.setRange(-height, height)
        ypos.setValue(int(height / 2))

    def hidewidget(self):
        with open(config['setting'], 'r') as file:
            data = file.readlines()
        for index_item in range(self.scrollLayout.count()):
            widget = self.scrollLayout.itemAt(index_item).widget()
            if isinstance(widget, QCheckBox) and widget.isChecked():
                self.checked_items.append(widget.text())
        data = ['#' + line if line in self.checked_items and '#' not in line else line[
                                                                                  1:] if line in self.checked_items and '#' in line else line
                for line in data]
        with open(config['setting'], 'w') as file:
            file.writelines(data)
        self.checked_items.clear()
        self.content_add()

    def deletesensor(self):
        with open(config['setting'], "r") as f:
            lines = f.readlines()
        for i in range(self.scrollLayout.count()):
            if self.scrollLayout.itemAt(i).widget().isChecked():
                self.checked_items.append(self.scrollLayout.itemAt(i).widget().text())
        with open(config['setting'], 'w') as f:
            for line in lines:
                if line in self.checked_items:
                    continue
                f.write(line)
        self.checked_items.clear()
        self.content_add()

    def addformula(self):
        variables = set(re.findall(r'[a-zA-Z]\w*', self.input3.text()))  # извлечение переменных из формулы
        missing_variables = [var for var in variables if
                             var != 'sqrt' and var not in [i.name for i in self.sensor_list]]

        if missing_variables:
            warning_window(f'Следующие {missing_variables} переменные отсутствуют в базе или скрыты (начинаются с #)',
                           False)
            return

        clr = config['COLORS'].get(self.cb_color_math.currentText(), self.cb_color_math.currentText().lstrip('#'))
        side = config['SIDE'].get(self.cb_name_side.currentText(), 'transparent')

        with open(config['setting'], 'r') as f:
            lines = f.readlines()
            counter = 1
            if self.input3_1.text() == '':
                while any('math' in line for line in lines):
                    counter += 1
                self.input3_1.setText(f'math{counter}')
            for line in lines:
                if self.input3_1.text() in line:
                    warning_window(f'{lines.index(line)} {self.input3_1.text()} уже в настройках', False)
                    return
        with open(config['setting'], 'a') as file:
            file.write(
                f'Math {self.input3_1.text()} {self.input3.text()} {clr} {side} {self.cb_bit_depth_math.currentText()} ({int(self.cb_pos_x_math.value())} {int(self.cb_pos_y_math.value())})')

    def send_ip(self):
        with open(config['setting'], 'r') as file:
            data = file.readlines()
        with open(config['setting'], 'w') as file:
            for line in data:
                if config['IPS'] == '{' in line:
                    if self.input4.text() not in config['IPS']:
                        line = line.replace('}', f',\'{self.input4.text()}\':\'{self.cb_add_type.currentText()}\'}}')

                file.write(line)

    def delip(self, ip_to_delete):
        with open(config['setting'], 'r') as f:
            lines = f.readlines()

        with open(config['setting'], 'w') as f:
            for line in lines:
                if config['IPS'] in line and '##' not in line:
                    del config['IPS'][ip_to_delete]
                    line = f'{config["IPS"]} = {str(config["IPS"])}\n'
                f.write(line)
    def create_item(self, objct):
        # Создание айтима`
        side = config['SIDE'].get(self.cb_name_side.currentText(), 'transparent')
        p = {k: i + 1 for i, k in enumerate(config['IPS'])}
        ip = p.get(self.cb_reg.currentText())
        clr =config['COLORS'].get(self.cb_color.currentText(), self.cb_color.currentText().lstrip('#'))
        with open(config['setting'], 'r') as f:
            lines = f.readlines()
            for line in lines:
                try:
                    words = line.split(' ')
                    if objct == 'sensor' and self.cb_name.currentText() + self.cb_namenumber.currentText() in line or \
                            self.cb_channel.currentText() == words[1] and objct == 'sensor' and str(
                        self.cb_reg.currentIndex() + 1) in words[
                        5]:
                        warning_window(
                            f"Строка {lines.index(line) + 1} {self.cb_name.currentText() + self.cb_namenumber.currentText() + ' ' + self.cb_channel.currentText() + ' ' + str(self.cb_reg.currentIndex() + 1)} sensor уже  присутствует в настройках.",
                            False)
                        return
                    if (objct == 'RU' and self.cb_name_ru.currentText() + self.cb_name_runumber.currentText() in line or \
                        objct == 'RU' and self.cb_chr_open.currentText() == words[2] and str(self.cb_reg_ru.currentIndex()+1) in words[6] or \
                        objct == 'RU' and self.cb_chr_close.currentText() == words[3]and str(self.cb_reg_ru.currentIndex()+1) in words[6] or \
                        objct == 'RU' and self.cb_chdv_open.currentText() == words[4] and str(self.cb_reg_ru.currentIndex()+1) in words[6] or \
                        objct == 'RU' and self.cb_chdv_close.currentText() == words[5] and str(self.cb_reg_ru.currentIndex()+1) in words[6]):
                            warning_window(
                                f"Строка {lines.index(line)} {self.cb_name_ru.currentText() + self.cb_name_runumber.currentText()} RU уже  присутствует в настройках.",
                                False)
                            return
                    if objct == 'Furn' and f'F{str(self.number.value())}' == words[1] or \
                       objct == 'Furn' and 'Furn' in line and str(self.ch_furn.value()) == words[2] and str(self.reg_furn.value()) == words[4]:
                        print(line)
                        warning_window(
                            f"Строка {lines.index(line) + 1} {f'F{str(self.number.value())} '} {str(self.ch_furn.value())} {str(self.reg_furn.value())} Furn уже  присутствует в настройках.",
                            False)
                        return
                except Exception:
                    pass
        with open(config['setting'], 'w') as f:
            count = 0
            for i, line in enumerate(lines):
                f.write(line)
                if config['GRID'] in line:
                    count += 1
                if count == 2 and objct == 'sensor':
                    count += 1
                    f.write(
                        f'{self.cb_name.currentText() + self.cb_namenumber.currentText()} {self.cb_channel.currentText()} {clr} {side} {self.cb_bit_depth.currentText()} {ip} 0.0 ({int(self.cb_pos_x.value())} {int(self.cb_pos_y.value())})\n')
                    start_grids_index = 2
                    end_grids_index = 3
                    sort_key_index = 5
                if count == 4 and objct == 'RU':
                    count += 1
                    f.write(
                        f'{self.cb_name_ru.currentText() + self.cb_name_runumber.currentText()} {config["ORIENTATION"].get(self.cb_orientate.currentText())} {self.cb_chr_open.currentText()} {self.cb_chr_close.currentText()} {self.cb_chdv_open.currentText()} {self.cb_chdv_close.currentText()} {self.cb_reg_ru.currentIndex() + 1} ({int(self.cb_pos_x.value())} {int(self.cb_pos_y.value())})\n')
                    start_grids_index = 4
                    end_grids_index = 5
                    sort_key_index = 6
                if count == 6 and objct == 'Furn':
                    count += 1
                    f.write(
                        f'Furn F{str(self.number.value())} {str(self.ch_furn.value())} {str(self.max.value())} {str(self.reg_furn.value())}\n')
                    start_grids_index = 6
                    end_grids_index = 7
                    sort_key_index = 4
                if count == 8 and objct == 'Rer':
                    count += 1
                    f.write(
                        f'{self.r1.currentText()}←→{self.r2.currentText()} {str(self.r1_sleep.value())} {str(self.r2_sleep.value())}\n')
        if objct != 'Rer':
            self.extract_text_between_grids(start_grids_index, end_grids_index, sort_key_index)

    def extract_text_between_grids(self, start_grids_index, end_grids_index, sort_key_index):
        with open(config['setting'], 'r') as file:
            lines = file.readlines()
        start_count = 0
        inside_grids = False
        result = []
        before_grids = []
        for line in lines:
            if line.strip() == config['GRID']:
                start_count += 1
                if start_count == start_grids_index:
                    inside_grids = True
                    break
            before_grids.append(line)

        start_count = 0
        inside_grids = False
        between_grids = []
        for line in lines:
            if line.strip() == config['GRID']:
                start_count += 1
                if start_count == start_grids_index:
                    inside_grids = True
                if start_count == end_grids_index:
                    inside_grids = False
                    break
            if inside_grids:
                if config['GRID'] not in line and line != '\n' and line.strip() != '':
                    between_grids.append(line)

        # Сортируем текст между config['GRID'
        sorted_by_key_element = sorted(between_grids, key=lambda x: int(x.split()[sort_key_index]))
        # Создаем словарь для хранения подсписков согласно выбранному элементу
        result_dict = {}
        for item in sorted_by_key_element:
            parts = item.split()
            key = int(parts[sort_key_index])
            if key not in result_dict:
                result_dict[key] = []
            result_dict[key].append(item)
        result_list = [result_dict[key] for key in sorted(result_dict.keys())]
        if sort_key_index == 5:
            for index_result, result in enumerate(result_list):
                result_list[index_result] = sorted(result, key=lambda x: int(x.split()[1]))
        merged_list = []
        for sublist in result_list:
            merged_list.extend(sublist)

        before_grids.append(config['GRID'] + '\n')
        after_grids = lines[len(before_grids) + len(merged_list):]
        result = before_grids + merged_list + after_grids
        with open(config['setting'], 'w') as sorted_file:
            sorted_file.write("".join(result))

    def get_name(self):
        count = 0
        with open(config['setting'], 'r') as f:
            for i, line in enumerate(f):
                if config['GRID'] in line:
                    count += 1
                if count == 2:
                    lines = [line for line in f if '##' not in line or line == '\n']
                    break
        return lines

    def reboots(self):
        dlgMain.reboots()


class GraphWindow(QMainWindow):
    sensor_data = None  # Общие данные датчика для всех экземпляров
    name_formuls = []
    formuls = []

    def __init__(self):
        super().__init__()
        self.all_impuls = Damper.all_impuls
        self.sensor_data = dlgMain.sensor_list
        self.setWindowTitle('График_0')
        self.menu = self.menuBar().addMenu('Выбор датчиков')
        menu2 = self.menuBar().addMenu('Новое окно(F2)')
        self.actions = {}
        clear_action = QAction("Обратное состояние F3", self)
        clear_action.triggered.connect(self.revers_checks)
        self.menu.addAction(clear_action)
        clear_action = QAction("Снять все F4", self)
        clear_action.triggered.connect(self.clear_all_checks)
        self.menu.addAction(clear_action)
        for sensor in self.sensor_data:
            action = QAction(str(sensor), self)
            action.setCheckable(True)  # Установка флага, что действие может иметь состояние "checked"
            action.setChecked(True)
            action.triggered.connect(lambda checked, sensor=sensor: self.toggle_sensor(checked, sensor))
            self.menu.addAction(action)
            self.actions[sensor] = action
        for formul in self.name_formuls:
            action = QAction(str(formul), self)
            action.setCheckable(True)  # Установка флага, что действие может иметь состояние "checked"
            action.setChecked(True)
            action.triggered.connect(lambda checked, sensor=formul: self.toggle_sensor(checked, sensor))
            self.menu.addAction(action)
            self.actions[formul] = action
        create_action = QAction('Создать новое окно', self)
        create_action.triggered.connect(self.create_new_graph_window)
        menu2.addAction(create_action)
        menu3 = self.menuBar().addMenu('Скрыть рамки(F1)')
        create_action_hide = QAction('Скрыть', self)
        create_action_hide.triggered.connect(self.toggle_visibility)
        menu3.addAction(create_action_hide)

        # Создаем объект графика
        self.graphwidget = pg.PlotWidget(self)
        self.setCentralWidget(self.graphwidget)

        # Настраиваем параметры графика
        self.graphwidget.showGrid(x=True, y=True)
        self.graphwidget.setBackground('#1A1A1A')

        axis = pg.DateAxisItem(orientation='bottom')
        axis.setTickFont(QFont('Arial', 11))
        self.line = pg.PlotCurveItem(pen="g")
        self.graphwidget.addItem(self.line)
        self.graphwidget.setAxisItems({"bottom": axis})
        self.graphwidget.setLabel('bottom',
                                  f'<span style="font-size: 14px;">{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</span>')

        # Инициализируем данные для графика
        self.data = {}
        for sensor in self.sensor_data:
            self.data[sensor] = {'x': [], 'y': []}
        for formul in self.name_formuls:
            self.data[formul] = {'x': [], 'y': []}

        legend = pg.LegendItem()
        legend.setParentItem(self.graphwidget.graphicsItem())
        # Создаем кривые для каждого датчика
        self.curves = {}
        self.list_name = []
        # Создаем текстовые элементы для каждого датчика
        self.text_items = {}
        for sensor in self.sensor_data:
            self.curves[sensor] = self.graphwidget.plot(self.data[sensor]['x'], self.data[sensor]['y'],
                                                        pen=pg.mkPen(color=pg.intColor(self.sensor_data.index(sensor)),
                                                                     width=2))
            self.text_items[sensor] = TextItem('', anchor=(0.5, 0))
            self.text_items[sensor].setFont(QFont('Arial', 11))
            self.graphwidget.addItem(self.text_items[sensor])
            self.list_name.append(sensor.name)

        for name in self.name_formuls:
            self.curves[name] = self.graphwidget.plot(self.data[name]['x'], self.data[name]['y'], pen=pg.mkPen(
                color=pg.intColor((self.name_formuls.index(name) + 10) * (-1)),
                width=2))
            self.text_items[name] = TextItem('', anchor=(0.5, 0))
            self.text_items[name].setFont(QFont('Arial', 11))

            self.graphwidget.addItem(self.text_items[name])
            self.list_name.append(name)
        self.graphwidget.setLabel('left',
                                  f'<span style="font-size: 14px;">      {" ".join(str(item) for item in self.list_name)}</span>')
        # Запускаем таймер обновления графика
        self.timer = QTimer()
        self.timer.timeout.connect(lambda: threading.Thread(target=self.update_graph()))
        self.timer.start(100)  # Обновление каждую секунду
        shortcuts = [
            (Qt.Key_F1, self.toggle_visibility),
            (Qt.Key_F2, self.create_new_graph_window),
            (Qt.Key_F3, self.revers_checks),
            (Qt.Key_F4, self.clear_all_checks),
        ]
        for key, function in shortcuts:
            shortcut = QShortcut(QKeySequence(key), self)
            shortcut.activated.connect(function)
        self.resize_to_quarter_screen()
        keyboard.add_hotkey('PrtScn', self.print_screen)
        self.graphwidget.getAxis('left').setStyle(tickFont=QFont('Arial', 12))

    def clear_all_checks(self):
        for k, v in self.actions.items():
            if v.isChecked():
                v.setChecked(False)  # Toggle the check state
                self.toggle_sensor(False, k)  # Toggle the sensor state

    def revers_checks(self):
        for k, v in self.actions.items():
            if v.isChecked():
                v.setChecked(False)
                self.toggle_sensor(False, k)
            else:
                v.setChecked(True)
                self.toggle_sensor(True, k)

    def print_screen(self):
        os.makedirs(os.path.dirname(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/'), exist_ok=True)
        self.grab().save(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/' + time.strftime(config['format_time'],
                                                                          time.localtime()) + '_' + self.windowTitle() + ".jpg")

    def resize_to_quarter_screen(self):
        desktop = QApplication.desktop()
        screen_rect = desktop.screenGeometry()
        width = screen_rect.width() // 2
        height = screen_rect.height() // 2
        self.setGeometry(screen_rect.x(), screen_rect.y(), width, height)

    def toggle_visibility(self):
        # Проверяем текущий стиль рамки окна
        if self.windowFlags() & Qt.FramelessWindowHint:
            # Если безрамочный стиль установлен, удаляем его
            self.setWindowFlag(Qt.FramelessWindowHint, False)
            self.setWindowFlag(Qt.WindowStaysOnTopHint, False)
            self.show()
            self.menuBar().show()

        else:
            # Если безрамочный стиль не установлен, устанавливаем его
            self.setWindowFlag(Qt.FramelessWindowHint)
            self.setWindowFlag(Qt.WindowStaysOnTopHint)

            self.show()
            self.menuBar().hide()

    def create_new_graph_window(self):
        window_name = "График"
        window_number = 1
        while True:
            var_name = f"{window_name}_{window_number}"
            if var_name not in globals():
                break
            window_number += 1
        graph_window = GraphWindow()
        graph_window.setWindowTitle(var_name)
        globals()[var_name] = graph_window
        graph_window_thread = threading.Thread(target=graph_window.show())
        graph_window_thread.start()

    def toggle_sensor(self, checked, sensor):
        print(checked, sensor)
        # Изменение видимости данных датчика на графике
        self.curves[sensor].setVisible(checked)
        self.text_items[sensor].setVisible(checked)
        if checked:
            self.list_name.append(sensor.name if hasattr(sensor, 'name') else sensor)
        else:
            self.list_name.remove(sensor.name if hasattr(sensor, 'name') else sensor)

        label = '    '.join(str(item) for item in self.list_name)
        self.graphwidget.setLabel('left', label)

    def update_graph(self):
        # Получаем текущее время в миллисекундах
        max_points =1000
        current_time = time.time()
        current_time_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.graphwidget.getAxis('bottom').setLabel(
            f'<span style="font-size: 14px;">{current_time_str}</span>')
        prev_reg_value = None
        for sensor in self.sensor_data:
            try:
                if prev_reg_value != sensor.reg:
                    reg_counter = 0
                    prev_reg_value = sensor.reg
                new_value = float(f"{GraphWindow.sensor_data[sensor.reg][reg_counter]:.3f}")
                reg_counter += 1
                self.data[sensor]['x'].append(current_time)
                self.data[sensor]['y'].append(new_value)

                # Ограничиваем количество отображаемых точек (не более 100)
                if len(self.data[sensor]['x']) > max_points:
                    self.data[sensor]['x'] = self.data[sensor]['x'][-max_points:]
                    self.data[sensor]['y'] = self.data[sensor]['y'][-max_points:]

                # Обновляем данные на графике
                self.curves[sensor].setData(self.data[sensor]['x'], self.data[sensor]['y'])
                last_value = self.data[sensor]['y'][-1]
                self.text_items[sensor].setText(f'{last_value:.3f}  {sensor.name}')
                self.text_items[sensor].setPos(self.data[sensor]['x'][-1], last_value)
            except Exception:
                pass
        for n, imp in self.all_impuls.items():
            new_value = float(imp)
            if n not in self.data:
                action = QAction(str(n), self, checkable=True)
                action.setChecked(True)
                action.setCheckable(True)
                # Установка изначального состояния
                action.triggered.connect(lambda checked, sensor=n: self.toggle_sensor(checked, sensor))
                self.menu.addAction(action)
                self.actions[n] = action

                # Добавляем ключ 'RU4' в self.data
                self.data[n] = {'x': [], 'y': []}
                self.data[n]['x'].append(current_time)
                self.data[n]['y'].append(new_value)
                self.curves[n] = self.graphwidget.plot(self.data[n]['x'], self.data[n]['y'],

                                                       pen=pg.mkPen(
                                                           color=pg.intColor(random.randint(0, 255 * 255 * 255)),
                                                           width=2))

                self.text_items[n] = TextItem('', anchor=(0.5, 0))
                self.text_items[n].setFont(QFont('Arial', 11))
                self.graphwidget.addItem(self.text_items[n])
                self.list_name.append(n)
            # Добавляем новые данные в список
            self.data[n]['x'].append(current_time)
            self.data[n]['y'].append(new_value)

            # Ограничиваем количество отображаемых точек (не более 100)
            if len(self.data[n]['x']) > max_points:
                self.data[n]['x'] = self.data[n]['x'][-max_points:]
                self.data[n]['y'] = self.data[n]['y'][-max_points:]

            # Обновляем данные на графике
            self.curves[n].setData(self.data[n]['x'], self.data[n]['y'])
            last_value = self.data[n]['y'][-1]
            self.text_items[n].setText(f'{last_value:.3f}  {n}')
            self.text_items[n].setPos(self.data[n]['x'][-1], last_value)

        for i, (name, formuls) in enumerate(zip(self.name_formuls, self.formuls)):
            new_value = float(f"{GraphWindow.formuls[i]:.3f}")
            # Добавляем новые данные в список
            self.data[name]['x'].append(current_time)
            self.data[name]['y'].append(new_value)

            # Ограничиваем количество отображаемых точек (не более 100)
            if len(self.data[name]['x']) > max_points:
                self.data[name]['x'] = self.data[name]['x'][-max_points:]
                self.data[name]['y'] = self.data[name]['y'][-max_points:]

            # Обновляем данные на графике
            self.curves[name].setData(self.data[name]['x'], self.data[name]['y'])
            last_value = self.data[name]['y'][-1]
            self.text_items[name].setText(f'{last_value:.3f}  {name}')
            self.text_items[name].setPos(self.data[name]['x'][-1], last_value)


class MainShem(QMainWindow):
    def __init__(self, parent=None):
        super(MainShem, self).__init__(parent)
        self.timestart_lock = threading.Lock()
        self.timestart = time.strftime(config['format_time'], time.localtime())
        self.showFullScreen()
        self.first = True
        self.labelimg = QLabel(self)
        self.pixmap = QPixmap(config['IMG'])
        self.labelimg.setPixmap(self.pixmap)
        self.labelimg.setScaledContents(True)
        self.labelimg.setPixmap(self.pixmap.scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
        self.opacity_effect = QGraphicsOpacityEffect()
        self.opacity_effect.setOpacity(0.7)
        self.labelimg.setGraphicsEffect(self.opacity_effect)
        self.labelimg.setGeometry(25, 25, int(self.width() - 50), int(self.height() - 50))
        self.labelimg.show()

        self.ourch = self.read_file(config['setting'])
        self.timermup = QTimer()
        self.formuls_math = [fd.mathematics.replace('sqrt', 'cmath.sqrt') for fd in self.formuls]
        self.timermup.timeout.connect(lambda: self.update_label(self.formuls_math))
        self.timermup.start(94)

        self.texttime = QWidget(self)
        self.texttime.setGeometry(0, 0, 600, 145)
        self.layout = QHBoxLayout()

        stl = "border: 2px solid black;border-radius: 10px;background-color:rgb(213,199,182)"
        self.Time = QLabel()
        self.Time.setGeometry(0, 0, 150, 100)
        self.Time.setFont(QFont('Arial', 30))
        self.Time.setStyleSheet(stl)
        self.layout.addWidget(self.Time)

        self.button = QPushButton('+')
        self.button.clicked.connect(self.Sensoradd)

        self.button.setStyleSheet(stl)
        self.button.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        self.layout.addWidget(self.button)

        self.input = QTextEdit(self)
        self.input.setFont(QFont('Arial', 24))
        self.input.setStyleSheet(stl)
        self.layout.addWidget(self.input)
        self.input.textChanged.connect(self.text_changed)

        self.texttime.setLayout(self.layout)
        self.texttime.show()
        self.old_pos = None

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.showTime)
        self.timer.start()

        self.checkBox = QCheckBox()
        self.checkBox.stateChanged.connect(self.on_checkbox_changed)
        self.layout.addWidget(self.checkBox)

        self.timerfile = QTimer()
        self.timerfile.timeout.connect(self.do_things)
        self.timerfile.start(3600000)

        top_right_point = QApplication.desktop().availableGeometry().topRight()

        self.reboot = QPushButton(self)
        self.reboot.setGeometry(555, 555, 25, 25)
        self.reboot.move(top_right_point / 1.0525)
        self.reboot.clicked.connect(self.rebo)
        self.reboot.setText('↻')
        self.reboot.setFont(QFont('Arial', 16))
        self.reboot.show()

        self.exit = QPushButton(self)
        self.exit.setGeometry(555, 555, 25, 25)
        self.exit.move(top_right_point / 1.015)
        self.exit.clicked.connect(self.close_event)
        self.exit.setText('X')
        self.exit.setFont(QFont('Arial', 14))
        self.exit.show()

        self.full = QPushButton(self)
        self.full.setGeometry(555, 555, 25, 25)
        self.full.move(top_right_point / 1.0275)
        self.full.clicked.connect(self.full_roll)
        self.full.setFont(QFont('Arial', 16))
        self.full.setText('❒')
        self.full.show()

        self.roll = QPushButton(self)
        self.roll.setGeometry(555, 555, 25, 25)
        self.roll.move(top_right_point / 1.04)
        self.roll.clicked.connect(self.showMinimized)
        self.roll.setText('_')
        self.roll.show()
        self.sendol = self.sendall()
        keyboard.add_hotkey('PrtScn', self.print_screen)
        self.out = []

        self.central_widget = QWidget(self)  # Создаем центральный виджет
        self.central_widget.setGeometry(10, self.size().height() - 300, 450, 150)
        layout = QVBoxLayout(self.central_widget)  # Создаем вертикальный макет
        self.central_widget.setContentsMargins(0, 0, 0, 0)
        for index in range(config['PACK']):  # Create instances of Set_point with unique indexes
            set_point = Set_point(self, index)
            layout.addWidget(set_point)
        self.central_widget.resize(400, 200)
        self.layout.setSpacing(0)
        self.central_widget.show()

    def text_changed(self):
        self.timerfile = QTimer()
        self.timerfile.timeout.connect(self.input.clearFocus)
        self.timerfile.start(36000)

    def rebo(self, event):
        reply = QMessageBox.question(self, 'Message',
                                     "Вы уверены, что хотите перезагрузить?", QMessageBox.Yes |
                                     QMessageBox.No, QMessageBox.No)
        self.reboots() if reply == QMessageBox.Yes else event.ignore()

    def close_event(self, event):
        reply = QMessageBox.question(self, 'Message',
                                     "Вы уверены, что хотите выйти?", QMessageBox.Yes |
                                     QMessageBox.No, QMessageBox.No)
        os._exit(1) if reply == QMessageBox.Yes else event.ignore()

    def full_roll(self):
        if self.isFullScreen():
            self.showNormal()
            self.showMaximized()
        else:
            self.showFullScreen()

    def do_things(self):
        with self.timestart_lock:
            self.timestart = time.strftime(config['format_time'], time.localtime())

    def on_checkbox_changed(self, value):
        for item in [self.ourch, self.dampers_list, self.formuls]:
            for i in range(len(item)):
                item[i].moveon = Qt.CheckState(value) == Qt.CheckState.Checked
        if Qt.CheckState(value) == Qt.CheckState.Unchecked:
            for item in [self.ourch, self.dampers_list]:
                for i in range(len(item)):
                    item[i].moveon = False
        #    self.close()
        #   QProcess.startDetached(sys.executable, sys.argv)

    def redakt(self, text):
        with fileinput.FileInput(config['setting'], inplace=True,
                                 backup='.bak') as f:
            for line in f:
                if text[:text.find(' ')] + ' ' in line:
                    def find_2nd(string, substring):
                        return string.find(
                            substring, string.find(substring) + 8)

                    if '+' in text:
                        print(line[:find_2nd(line, ' ')] +
                              ' ' +
                              text[text.find('+') +
                                   1:] +
                              line[line.find(' ('):], end='')
                    elif '-' in text:
                        print(line[:find_2nd(line, ' ')] +
                              ' ' +
                              text[text.find('-'):] +
                              line[line.find(' ('):], end='')
                else:
                    print(line, end='')
            self.close()
            QProcess.startDetached(sys.executable, sys.argv)

    def Sensoradd(self):
        s = Setting()
        s.central_widget.show()
        s.show()

    def showTime(self):
        self.Time.setText(QDateTime.currentDateTime().toString('d/M/yy\nhh:mm:ss'))

    def tofile(self, main_window_data, fd):
        report_path = config["IZDELIE"] + f'/report_{config["IZDELIE"]}/'
        file_path = report_path + self.timestart + '.txt'
        self.df = pd.DataFrame(list(itertools.chain.from_iterable(main_window_data))).T
        write_header = not os.path.isfile(file_path)
        if write_header:
            os.makedirs(os.path.dirname(report_path), exist_ok=True)
            self.df.columns = list(f'{sens.name.lstrip("#")}_{sens.ch+1}_{sens.reg + 1}' for sens in self.sensor_list)
        self.df.insert(0, 'Time', str(datetime.now().strftime('%H:%M:%S.%f')[:-3]))
        self.df.insert(0, 'Data', str(datetime.now().strftime('%d/%m/%y')))
        for formula in self.formuls:
            self.df[formula.name] = ("{:.{}f}".format(fd[self.formuls.index(formula)], formula.bit_depth))
        numeric_columns = self.df.select_dtypes(include=[np.number]).columns
        self.df[numeric_columns] = self.df[numeric_columns].astype('float32')

        with io.open(file_path, 'a', newline='', buffering=8192) as f:
            csv_data = self.df.to_csv(sep=';', header=write_header, index=False, float_format='%.4f')
            csv_data = csv_data.replace('.', ',')
            f.write(csv_data)

    def update_label(self, copy_formuls):
       # start_time = time.time()

        formuls = copy_formuls.copy()
        if config['imitation'] and self.first:
            self.widget_imit = QWidget()
            self.widget_imit.resize(150, self.widget_imit.height())
            layout = QVBoxLayout()  # Создание вертикальной компоновки
            self.spin_boxes = []  # Создание списка для хранения QDoubleSpinBox
            for i in dlgMain.sensor_list:
                l_w = QWidget()
                line = QHBoxLayout()
                inpt = QDoubleSpinBox()
                inpt.setMinimum(-100)
                inpt.setMaximum(999.99)
                inpt.setSingleStep(0.1)
                line.addWidget(QLabel(f'{i.name}'))
                line.addWidget(inpt)
                l_w.setLayout(line)
                layout.addWidget(l_w)
                self.spin_boxes.append(inpt)  # Добавление QDoubleSpinBox в список

            self.widget_imit.setLayout(layout)
            self.widget_imit.show()
            self.first = False

        def update_label_thread():
            try:
                if config['imitation']:
                    main_window_data = [[spin_box.value() for spin_box in self.spin_boxes]]

                else:
                    main_window_data = fetch_live_data()

                GraphWindow.sensor_data = main_window_data
                Timers.sensor_data = main_window_data
                Set_point.sensor_data = main_window_data
                Damper.sensor_data = main_window_data
                self.update_sensor_data(main_window_data, formuls)
                self.calculate_formulas(formuls)
                if not config['imitation']:
                    self.tofile(main_window_data, formuls)
                    ServerSocket.data=main_window_data

            except Exception as e:
                warning_window(str(e))

        thread = threading.Thread(target=update_label_thread, name=f'Thread-777')
        thread.start()
        thread.join()
      # end_time = time.time()

      # execution_time = end_time - start_time
      # print(f"update_lable: {execution_time} секунд")


    def update_sensor_data(self, main_window_data, formuls):
        if not hasattr(self, 'lens'):
            self.lens = [len(i) for i in main_window_data]
            self.ourch_split = []
            start_idx = 0
            for length in self.lens:
                sublist = self.ourch[start_idx:start_idx + length]
                self.ourch_split.append(sublist)
                start_idx += length
        for index_in_reg, sensors in enumerate(self.ourch_split):
            for index_sens, sensor in enumerate(sensors):
                try:
                    data = main_window_data[index_in_reg][index_sens] + sensor.amendment
                    formuls[:] = list(f.replace(sensor.name.lstrip('#'), str(data)) for f in formuls)
                    sensor.l2.setText(f"{data:.{sensor.bit_depth}f}")
                except ValueError as error:
                    warning_window(f'{sensor}\n{error}')
                    continue



    def calculate_formulas(self, formuls):
        try:
            formuls[:] = (round(eval(f).real, self.formuls[i].bit_depth) for i, f in enumerate(formuls))
            for i, f in enumerate(self.formuls):
                f.l2.setText(f"{formuls[i]}")

            GraphWindow.formuls = formuls
            Timers.formuls = formuls
            Set_point.formuls = formuls
        except Exception as error:

            warning_window(f'Проверьте формулу и её переменные\n{error}')

    def sendall(self):
        return {i: sensor for i, sensor in enumerate(self.sensor_list)}

    def create_damper(self, setting_row):
        """
        Создает объект заслонки и добавляет его в список заслонок.

        Args:
            setting_row (list): Список параметров для создания заслонки.
            move (list): Список параметров движения.

        Returns:
            None
        """
        # Распаковываем параметры из списков
        name, pos, chdo1, chdo2, chdi1, chdi2, reg, pos_x, pos_y = setting_row

        DAMPER_WIDTH = 150
        DAMPER_WIDTH_V=65
        DAMPER_HEIGHT = 150
        DAMPER_HEIGHT_V=110
        damper = Damper(name, pos, int(chdo1), int(chdo2), int(chdi1), int(chdi2), int(reg), self)
        self.dampers_list.append(damper)

        if pos == 'V':
            damper_height = DAMPER_HEIGHT_V
            damper_width = DAMPER_WIDTH_V
        else:
            damper_height = DAMPER_HEIGHT
            damper_width = DAMPER_WIDTH
        damper_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": damper_width,
            "height": damper_height
        }
        if '#' in name:
            return
        self.show_element(damper, damper_data)

    def create_translate(self, row_translate):
        """
        Создает объект перекладки и добавляет его в список перекладок.

        Args:
            row_translate (list[str]): Список строк с параметрами для создания перекладки.

        Returns:
            None

        """
        # Извлекаем параметры из списка слов
        dampers, damper1_sleep, damper2_sleep, time ,x,y= row_translate
        damper1, damper2 = dampers.split('~')
        translate = Translate(damper1, damper2, self.dampers_list, damper1_sleep, damper2_sleep, time,self)
        self.translate_list.append(translate)
        if '#' in row_translate:
            return
        translate.move(int(x),int(y))
        translate.show()

    def create_furnace(self, row_furnace):
        """
           Создает объект печи и добавляет его в список печей.

           Args:
               row_furnace (list[str]): Строка с параметрами для создания печи.

           Returns:
               None
           """
        furn,name, ch_ae, diapason, reg,x,y=row_furnace
        furnace = Furnace(name, int(ch_ae), float(diapason), int(reg),x,y,self)  # Furn F2 3 20 1
        self.furnace_list.append(furnace)
        if '#Furn' in row_furnace:
            return
        furnace.move(int(x),int(y))
        furnace.show()

    def create_math(self, math_config):
        """
        Создает объект математической формулы и добавляет его в список формул.

        Args:
            math_config (list): Список параметров для создания математической формулы.

        Returns:
            None
        """
        MATH_WIDTH = 120
        MATH_HEIGHT = 60

        # Распаковываем параметры из списка math_config
        math_type, name, formula, color, side_name, unit, pos_x, pos_y, *extra_params = math_config

        # Создаем данные для отображения формулы
        math_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": MATH_WIDTH,
            "height": MATH_HEIGHT
        }

        # Создаем объект формулы
        math_formula = Formula(name, formula, color, side_name, int(unit))

        # Устанавливаем родительский элемент
        math_formula.setParent(self)

        # Добавляем формулу в список формул
        self.formuls.append(math_formula)

        # Проверяем, есть ли символ '#' в имени, и если есть, пропускаем отображение
        if '#' in name:
            return

        # Отображаем формулу
        self.show_element(math_formula, math_data)

    def create_sensor(self, row_config):
        """
        Создает объект сенсора и добавляет его в список сенсоров.

        Args:
            row_config (list[str]): Строка с параметрами для создания сенсора.

        Returns:
            None
        """
        SENSOR_WIDTH=120
        SENSOR_HEIGHT=60
        name, channel, color, side_name, unit, reg, fix, pos_x, pos_y, *extra_params = row_config
        sensor_data = {
            "x": int(pos_x),
            "y": int(pos_y),
            "width": SENSOR_WIDTH,
            "height": SENSOR_HEIGHT
        }
        sensor = Sensor(name, int(channel), color, side_name, int(unit), int(reg), float(fix), self)
        self.sensor_list.append(sensor)
        if '#' in name:
            return
        self.show_element(sensor,sensor_data)

    def show_element(self, element, element_data):
        """
        Общая функция для отображения разных элементов.

        Args:
            element: Объект элемента для отображения (например, заслонка, сенсор, и т.д.).
            element_data: Данные элемента, такие как координаты и размер.

        Returns:
            None
        """
        # Логика отображения элемента
        element.setGeometry(element_data["x"], element_data["y"], element_data["width"], element_data["height"])
        element.show()

    def read_file(self, setting_row):
        """
        Чтение и обработка файла конфигурации.

        Args:
            setting_row (str): Путь к файлу конфигурации.

        Returns:
            list: Список сенсоров, созданных на основе данных из файла.
        """

        # Словарь, сопоставляющий ключевые слова с соответствующими функциями
        KEYWORDS_MAP = {
            "zu": self.create_damper,
            "ru": self.create_damper,
            "ruru": self.create_translate,
            "furn": self.create_furnace,
            "math": self.create_math
        }

        # Ключевые слова, которые будут пропущены при обработке файла
        SKIP_KEYWORDS = ['##', '=']

        try:
            with open(setting_row) as file:
                # Инициализация списков для хранения объектов различных типов
                self.sensor_list = []  # Список сенсоров
                self.dampers_list = []  # Список заслонок
                self.translate_list = []  # Список перекладок
                self.furnace_list = []  # Список печей
                self.formuls = []  # Список формул

                for row_config in file:
                    # Пропуск пустых строк и строк с ключевыми словами для пропуска
                    if row_config.strip() == "" or any(x in row_config for x in SKIP_KEYWORDS):
                        continue

                    # Удаление скобок и разделение строки на отдельные слова
                    cleaned_row_config = row_config.replace("(", "").replace(")", "")
                    cleaned_row_config = cleaned_row_config.split()
                    # Извлечение ключевого слова (первого слова) и преобразование его в нижний регистр
                    keyword = ''.join(filter(str.isalpha, cleaned_row_config[0].lower()))

                    # Вызов соответствующей функции в зависимости от ключевого слова
                    if keyword in KEYWORDS_MAP:
                        KEYWORDS_MAP[keyword](cleaned_row_config)
                    else:
                        # Создание сенсора, если ключевое слово не найдено
                        self.create_sensor(cleaned_row_config)

                # Формирование списков имен для формул (и других списков, если необходимо)
                GraphWindow.name_formuls = [i.name for i in self.formuls]
                Timers.name_formuls = [i.name for i in self.formuls]

                # Возврат списка сенсоров
                return self.sensor_list
        except Exception as error:
            # Обработка и вывод ошибки, если что-то пошло не так
            warning_window(f'{row_config}\n {error} неправильный параметр')

    def print_screen(self):
        """
        Создание и сохранение скриншота текущего состояния окна.

        Returns:
            None
        """
        # Создание директории для сохранения скриншотов, если её не существует
        os.makedirs(os.path.dirname(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/'), exist_ok=True)

        # Сохранение скриншота в формате .jpg с уникальным именем
        self.grab().save(config["IZDELIE"] + f'/screens_{config["IZDELIE"]}/' + time.strftime(config['format_time'],
                                                                                              time.localtime()) + ".jpg")

    def reboots(self):
        """
        Перезапуск приложения.

        Закрывает текущее окно (если оно является экземпляром GraphWindow) и запускает
        приложение заново.

        Returns:
            None
        """
        # Проверка, является ли текущее окно экземпляром GraphWindow
        if isinstance(window, GraphWindow):
            window.close()

        # Запуск приложения заново с теми же аргументами
        os.execl(sys.executable, os.path.abspath(__file__), *sys.argv)

    def get_dlg_main_ourch(self):
        return self.ourch

    def run_app(self):
        try:
            self.app = QApplication(sys.argv)
            self.show()
            time.sleep(1)
            self.dlg_ourch = self.get_dlg_main_ourch()
            t1 = threading.Thread(target=process_data_channel, args=(self.dlg_ourch,))
            t1.start()
            s1 = ServerSocket()
            s1.start()
            graph_window_0 = GraphWindow()
            graph_window_0.show()
            algoritms = Timers(parent=self)
            screen_resolution = QApplication.desktop().screenGeometry().size()
            screen_height = screen_resolution.height()
            algoritms.setGeometry(400, screen_height - 250, 400, 200)
            algoritms.hide_timer_settings()
            algoritms.show()

            sys.exit(self.app.exec_())
        except Exception as e:
            warning_window(e)

if __name__ == '__main__':
    dlgMain = MainShem()
    dlgMain.run_app()
